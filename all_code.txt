// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\main.dart ===
import 'dart:async';
import 'dart:ui';

import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';
import 'package:in_app_purchase/in_app_purchase.dart';
import 'package:in_app_update/in_app_update.dart';
import 'package:provider/provider.dart';

import 'package:snarf/components/call_overlay.dart';
import 'package:snarf/providers/call_manager.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/services/auth_checker.dart';
import 'package:snarf/services/signalr_manager.dart';

import 'utils/api_constants.dart';
import 'utils/app_themes.dart';

Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  await Firebase.initializeApp();
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  await _initializeFirebase();
  _setupErrorHandling();
  await _checkForInAppUpdate();
  await _setupFirebaseMessaging();
  _configureApiConstants();
  await _initializeSignalR();
  final configProvider = ConfigProvider();
  _initializeSubscription(configProvider);

  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider<ConfigProvider>(
          create: (_) => configProvider,
        ),
        ChangeNotifierProxyProvider<ConfigProvider, CallManager>(
          create: (context) => CallManager(context.read<ConfigProvider>()),
          update: (context, config, previous) => CallManager(config),
        ),
      ],
      child: const SnarfApp(),
    ),
  );
}

Future<void> _initializeFirebase() async {
  await Firebase.initializeApp();
}

void _setupErrorHandling() {
  FlutterError.onError = (errorDetails) {
    FirebaseCrashlytics.instance.recordFlutterError(errorDetails);
  };

  FlutterError.onError = (errorDetails) {
    FirebaseCrashlytics.instance.recordFlutterFatalError(errorDetails);
  };

  PlatformDispatcher.instance.onError = (error, stack) {
    FirebaseCrashlytics.instance.recordError(error, stack);
    return true;
  };
}

Future<void> _checkForInAppUpdate() async {
  try {
    final updateInfo = await InAppUpdate.checkForUpdate();
    if (updateInfo.updateAvailability == UpdateAvailability.updateAvailable) {
      if (updateInfo.immediateUpdateAllowed) {
        final appUpdateResult = await InAppUpdate.performImmediateUpdate();
        if (appUpdateResult == AppUpdateResult.success) {}
      } else if (updateInfo.flexibleUpdateAllowed) {
        final appUpdateResult = await InAppUpdate.startFlexibleUpdate();
        if (appUpdateResult == AppUpdateResult.success) {
          await InAppUpdate.completeFlexibleUpdate();
        }
      }
    }
  } catch (e) {}
}

Future<void> _setupFirebaseMessaging() async {
  await FirebaseMessaging.instance.requestPermission(provisional: true);
  FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);
}

void _configureApiConstants() {
  const isRelease = bool.fromEnvironment('dart.vm.product');
  ApiConstants.baseUrl =
      isRelease ? "https://snarf.inovitech.inf.br/api" : ApiConstants.baseUrl;
}

Future<void> _initializeSignalR() async {
  await SignalRManager().initializeConnection();
}

void _initializeSubscription(ConfigProvider configProvider) {
  final InAppPurchase inAppPurchase = InAppPurchase.instance;

  final purchaseUpdates = inAppPurchase.purchaseStream;
  purchaseUpdates.listen((purchases) {
    _processPurchaseUpdates(purchases, configProvider);
  });

  inAppPurchase.restorePurchases();
}

void _processPurchaseUpdates(
  List<PurchaseDetails> purchases,
  ConfigProvider configProvider,
) {
  for (var purchase in purchases) {
    if (purchase.productID == ApiConstants.subscriptionId) {
      if (purchase.status == PurchaseStatus.restored ||
          purchase.status == PurchaseStatus.purchased) {
        configProvider.setIsSubscriber(true);
        return;
      } else {
        configProvider.setIsSubscriber(false);
        return;
      }
    }
  }

  configProvider.setIsSubscriber(false);
}

class SnarfApp extends StatelessWidget {
  const SnarfApp({super.key});

  @override
  Widget build(BuildContext context) {
    final themeProvider = Provider.of<ConfigProvider>(context);

    return MaterialApp(
      title: 'snarf',
      themeMode: themeProvider.isDarkMode ? ThemeMode.dark : ThemeMode.light,
      theme: AppThemes.lightTheme,
      darkTheme: AppThemes.darkTheme,
      builder: (context, child) {
        return Stack(
          children: [
            child!,
            CallOverlay(),
          ],
        );
      },
      home: const AuthChecker(),
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\components\call_overlay.dart ===
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/providers/call_manager.dart';
import 'package:snarf/providers/config_provider.dart';

class CallOverlay extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final config = Provider.of<ConfigProvider>(context, listen: false);
    return Consumer<CallManager>(
      builder: (context, callManager, child) {
        if (callManager.isCallOverlayVisible) {
          return AnimatedPositioned(
            duration: const Duration(milliseconds: 300),
            top: kToolbarHeight + 16,
            left: 16,
            right: 16,
            child: SafeArea(
              child: Container(
                padding:
                    const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                decoration: BoxDecoration(
                  color: config.primaryColor,
                  borderRadius: BorderRadius.circular(12),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black26,
                      blurRadius: 8,
                      offset: const Offset(0, 2),
                    ),
                  ],
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      "Chamada recebida de ${callManager.incomingCallerName}",
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        color: config.textColor,
                        fontWeight: FontWeight.w600,
                        fontSize: 16,
                        decoration: TextDecoration.none,
                      ),
                    ),
                    const SizedBox(height: 12),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                      children: [
                        ElevatedButton.icon(
                          onPressed: callManager.acceptCall,
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.green,
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(8),
                            ),
                          ),
                          icon: Icon(
                            Icons.call,
                            color: config.iconColor,
                          ),
                          label: Text(
                            "Atender",
                            style: TextStyle(
                              color: config.iconColor,
                            ),
                          ),
                        ),
                        ElevatedButton.icon(
                          onPressed: callManager.rejectCall,
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.red,
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(8),
                            ),
                          ),
                          icon: Icon(
                            Icons.call_end,
                            color: config.iconColor,
                          ),
                          label: Text(
                            "Recusar",
                            style: TextStyle(
                              color: config.iconColor,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          );
        }

        if (callManager.isCallRejectedOverlayVisible) {
          return AnimatedPositioned(
            duration: const Duration(milliseconds: 300),
            bottom: kToolbarHeight + 16,
            left: 16,
            right: 16,
            child: SafeArea(
              child: Container(
                padding:
                    const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                decoration: BoxDecoration(
                  color: config.primaryColor,
                  borderRadius: BorderRadius.circular(12),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black26,
                      blurRadius: 8,
                      offset: const Offset(0, 2),
                    ),
                  ],
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      "Chamada rejeitada",
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        color: config.textColor,
                        fontSize: 16,
                        decoration: TextDecoration.none,
                      ),
                    ),
                    const SizedBox(height: 6),
                    Text(
                      callManager.callRejectionReason,
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        color: config.textColor,
                        fontSize: 16,
                        decoration: TextDecoration.none,
                      ),
                    ),
                    const SizedBox(height: 12),
                    ElevatedButton.icon(
                      onPressed: () {
                        callManager.closeRejectionOverlay();
                      },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: config.customRed,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                      ),
                      icon: Icon(
                        Icons.close,
                        color: config.iconColor,
                      ),
                      label: Text(
                        "OK",
                        style: TextStyle(
                          color: config.iconColor,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          );
        }

        return const SizedBox.shrink();
      },
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\components\consumable_purchase_component.dart ===
import 'package:flutter/material.dart';
import 'package:in_app_purchase/in_app_purchase.dart';
import 'package:provider/provider.dart';
import 'package:snarf/providers/config_provider.dart';

typedef BuyConsumableCallback = void Function(ProductDetails productDetails);

class ConsumablePurchaseComponent extends StatelessWidget {
  final List<ProductDetails> consumableProducts;
  final BuyConsumableCallback onBuyConsumable;
  final int purchasedMinutes;

  const ConsumablePurchaseComponent({
    super.key,
    required this.consumableProducts,
    required this.onBuyConsumable,
    required this.purchasedMinutes,
  });

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context, listen: false);

    if (consumableProducts.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(16),
        child: Text(
          'Nenhum produto avulso encontrado. Minutos extras: $purchasedMinutes',
          style: const TextStyle(fontSize: 16),
        ),
      );
    }
    return Column(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        Text(
          'Você comprou no total $purchasedMinutes minutos de video chamada.',
          style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
        ),
        for (final product in consumableProducts)
          Card(
            color: configProvider.secondaryColor,
            margin: const EdgeInsets.all(8),
            child: ListTile(
              title: Text(
                product.description,
                style: TextStyle(
                  color: configProvider.textColor,
                ),
              ),
              trailing: Text(
                product.price,
                style: TextStyle(
                  color: configProvider.textColor,
                ),
              ),
              onTap: () => onBuyConsumable(product),
            ),
          ),
      ],
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\components\custom_modal.dart ===
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/providers/config_provider.dart';

class CustomModal extends StatelessWidget {
  final String title;
  final Widget content;
  final List<Widget> actions;

  const CustomModal({
    super.key,
    required this.title,
    required this.content,
    required this.actions,
  });

  @override
  Widget build(BuildContext context) {
    final config = Provider.of<ConfigProvider>(context);

    return Dialog(
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(30.0),
      ),
      child: Container(
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(30.0),
          border: Border.symmetric(
            horizontal: BorderSide(
              color: config.primaryColor,
              width: 5,
            ),
          ),
          color: config.primaryColor,
        ),
        padding: const EdgeInsets.all(20.0),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              title,
              style: TextStyle(
                color: config.textColor,
                fontSize: 20.0,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 10.0),
            content,
            const SizedBox(height: 20.0),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: actions,
            ),
          ],
        ),
      ),
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\components\loading_elevated_button.dart ===
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/providers/config_provider.dart';

class LoadingElevatedButton extends StatelessWidget {
  final String text;
  final bool isLoading;
  final VoidCallback? onPressed;

  const LoadingElevatedButton({
    super.key,
    required this.text,
    required this.isLoading,
    this.onPressed,
  });

  @override
  Widget build(BuildContext context) {
    final config = Provider.of<ConfigProvider>(context);
    final bool isLightMode = !config.isDarkMode;

    return ElevatedButton(
      onPressed: isLoading ? null : onPressed,
      style: ElevatedButton.styleFrom(
        backgroundColor: config.secondaryColor,
        foregroundColor:
            isLightMode ? config.darkPrimaryColor : config.textColor,
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(10.0),
        ),
      ),
      child: isLoading
          ? CircularProgressIndicator(
              color: isLightMode ? config.darkPrimaryColor : Colors.white,
            )
          : Text(
              text,
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: isLightMode ? config.darkPrimaryColor : config.textColor,
              ),
            ),
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\components\loading_outlined_button.dart ===
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/providers/config_provider.dart';

class LoadingOutlinedButton extends StatelessWidget {
  final String text;
  final bool isLoading;
  final VoidCallback? onPressed;

  const LoadingOutlinedButton({
    super.key,
    required this.text,
    required this.isLoading,
    this.onPressed,
  });

  @override
  Widget build(BuildContext context) {
    final config = Provider.of<ConfigProvider>(context);
    final bool isLightMode = !config.isDarkMode;

    return OutlinedButton(
      onPressed: isLoading ? null : onPressed,
      style: OutlinedButton.styleFrom(
        side: BorderSide(color: config.secondaryColor, width: 2),
        foregroundColor:
            isLightMode ? config.darkPrimaryColor : config.textColor,
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(10.0),
        ),
      ),
      child: isLoading
          ? CircularProgressIndicator(
              color: isLightMode ? config.darkPrimaryColor : Colors.white,
            )
          : Text(
              text,
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: isLightMode ? config.darkPrimaryColor : config.textColor,
              ),
            ),
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\components\themed_text_field.dart ===
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/providers/config_provider.dart';

class ThemedTextField extends StatelessWidget {
  final TextEditingController controller;
  final String labelText;
  final IconData icon;
  final bool obscureText;
  final TextInputType keyboardType;

  const ThemedTextField({
    super.key,
    required this.controller,
    required this.labelText,
    required this.icon,
    this.obscureText = false,
    this.keyboardType = TextInputType.text,
  });

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);

    return TextField(
      controller: controller,
      obscureText: obscureText,
      keyboardType: keyboardType,
      style: TextStyle(color: configProvider.textColor),
      decoration: InputDecoration(
        labelText: labelText,
        labelStyle: TextStyle(color: configProvider.textColor),
        prefixIconColor: configProvider.iconColor,
        prefixIcon: Icon(icon),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(15),
        ),
      ),
    );
  }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\actions.dart ===
enum Actions {
  ballPlay,
  cuddle,
  fingering,
  fisting,
  fucking,
  frotting,
  jerkOff,
  rimming,
  massage,
  makeout,
  oral,
  oralReceiving,
  oralGiving,
  oralSwallow,
}

extension ActionsLabel on Actions {
  static const _pt = {
    Actions.ballPlay: 'Brincar com Bolas',
    Actions.cuddle: 'Abraçar',
    Actions.fingering: 'Dedilhando',
    Actions.fisting: 'Punho / Fisting',
    Actions.fucking: 'Foda',
    Actions.frotting: 'Pau com Pau',
    Actions.jerkOff: 'Bater',
    Actions.rimming: 'Rimming',
    Actions.massage: 'Massagem',
    Actions.makeout: 'Beijos',
    Actions.oral: 'Boquete',
    Actions.oralReceiving: 'Boquete (Somente recebimento)',
    Actions.oralGiving: 'Boquete (Dê somente)',
    Actions.oralSwallow: 'Boquete (Engolir)',
  };

  String get label => _pt[this]!;
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\base_plan_length.dart ===
enum BasePlanLength {
  weekly,
  everyFourWeeks,
  monthly,
  everyTwoMonths,
  everyThreeMonths,
  everyFourMonths,
  everySixMonths,
  everyEightMonths,
  yearly,
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\bodey_type.dart ===
enum BodyType {
  slim,
  fit,
  muscular,
  average,
  stocky,
  chubby,
  large,
}

extension BodyTypeLabel on BodyType {
  static const _pt = {
    BodyType.slim: 'Magro',
    BodyType.fit: 'Em Forma',
    BodyType.muscular: 'Musculoso',
    BodyType.average: 'Médio',
    BodyType.stocky: 'Robusto',
    BodyType.chubby: 'Gordinho',
    BodyType.large: 'Grande',
  };
  String get label => _pt[this]!;
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\carrying.dart ===
enum Carrying {
  condoms,
  lube,
  naloxone,
  drugTestStrips,
  discuss,
}

extension CarryingLabel on Carrying {
  static const _pt = {
    Carrying.condoms: 'Camisinhas',
    Carrying.lube: 'Lubrificante',
    Carrying.naloxone: 'Naloxona',
    Carrying.drugTestStrips: 'Fitas de teste de drogas',
    Carrying.discuss: 'Conversar',
  };
  String get label => _pt[this]!;
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\drug_abuse.dart ===
enum DrugAbuse {
  alcohol,
  cannabis,
  tobacco,
  poppers,
  pnp,
  other,
  discuss,
}

extension DrugAbuseLabel on DrugAbuse {
  static const _pt = {
    DrugAbuse.alcohol: 'Álcool',
    DrugAbuse.cannabis: 'Cannabis',
    DrugAbuse.tobacco: 'Tabaco',
    DrugAbuse.poppers: 'Poppers',
    DrugAbuse.pnp: 'PnP',
    DrugAbuse.other: 'Outro',
    DrugAbuse.discuss: 'Conversar',
  };
  String get label => _pt[this]!;
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\expression_style.dart ===
enum ExpressionStyle {
  bear,
  biker,
  bro,
  cleanCut,
  corporate,
  daddy,
  discreet,
  femme,
  gaymer,
  nerd,
  goth,
  boyNextDoor,
  jock,
  leather,
  nudist,
  otter,
  poz,
  punk,
  pup,
  rugged,
  skater,
  son,
  sporty,
  surfer,
  swinger,
  trans,
  trendy,
  trucker,
  twink,
  inclusivePlus,
}

extension ExpressionStyleLabel on ExpressionStyle {
  static const _pt = {
    ExpressionStyle.bear: 'Urso',
    ExpressionStyle.biker: 'Motociclista',
    ExpressionStyle.bro: 'Bro',
    ExpressionStyle.cleanCut: 'Estilo Limpo',
    ExpressionStyle.corporate: 'Corporativo',
    ExpressionStyle.daddy: 'Papai',
    ExpressionStyle.discreet: 'Discreto',
    ExpressionStyle.femme: 'Femme',
    ExpressionStyle.gaymer: 'Gaymer',
    ExpressionStyle.nerd: 'Nerd',
    ExpressionStyle.goth: 'Gótico',
    ExpressionStyle.boyNextDoor: 'Rapaz da Porta ao Lado',
    ExpressionStyle.jock: 'Atleta',
    ExpressionStyle.leather: 'Couro',
    ExpressionStyle.nudist: 'Nudista',
    ExpressionStyle.otter: 'Lontra',
    ExpressionStyle.poz: 'Positivo',
    ExpressionStyle.punk: 'Punk',
    ExpressionStyle.pup: 'Cachorro',
    ExpressionStyle.rugged: 'Rústico',
    ExpressionStyle.skater: 'Skatista',
    ExpressionStyle.son: 'Filho',
    ExpressionStyle.sporty: 'Esportivo',
    ExpressionStyle.surfer: 'Surfista',
    ExpressionStyle.swinger: 'Troca de Casais',
    ExpressionStyle.trans: 'Trans',
    ExpressionStyle.trendy: 'Na moda',
    ExpressionStyle.trucker: 'Caminhoneiro',
    ExpressionStyle.twink: 'Twink',
    ExpressionStyle.inclusivePlus: 'I+',
  };

  String get label => _pt[this]!;
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\fetish.dart ===
enum Fetish {
  bodyArmpits,
  bodyAss,
  bodyBodyHair,
  bodyBulges,
  bodyCocksHard,
  bodyCocksSoft,
  bodyCocksHung,
  bodyCum,
  bodyFacialHair,
  bodyFeet,
  bodyHands,
  bodyHappyTrail,
  bodyLongHair,
  bodyMuscles,
  bodyMusk,
  bodyNipples,
  bodyPecs,
  bodyPiercings,
  bodyPubesNatural,
  bodyPubesShaved,
  bodyPubesTrimmed,
  bodyScars,
  bodySpit,
  bodyTatoos,
  clothingBaseballCaps,
  clothingBoots,
  clothingDenim,
  clothingLeather,
  clothingLingerie,
  clothingMasks,
  clothingOnsies,
  clothingRubber,
  clothingSagging,
  clothingSinglets,
  clothingSocks,
  clothingSpandexLycra,
  clothingSpeedos,
  clothingSportsUniforms,
  clothingSportsGear,
  clothingSuits,
  clothingUniforms,
  clothingUnderwear,
  clothingUnderwearBoxers,
  clothingUnderwearBoxerBriefs,
  clothingUnderwearBriefs,
  clothingUnderwearJockstraps,
  clothingUnderwearMesh,
  clothingUnderwearNylons,
  clothingUnderwearPanties,
  clothingUnderwearUsed,
  clothingUnderwearTightyWhities,
}

extension FetishLabel on Fetish {
  static const _pt = {
    Fetish.bodyArmpits: 'Axilas',
    Fetish.bodyAss: 'Bunda',
    Fetish.bodyBodyHair: 'Pelos no Corpo',
    Fetish.bodyBulges: 'Pacotes',
    Fetish.bodyCocksHard: 'Pau Duro',
    Fetish.bodyCocksSoft: 'Pau Mole',
    Fetish.bodyCocksHung: 'Pau Dotado',
    Fetish.bodyCum: 'Porra',
    Fetish.bodyFacialHair: 'Barba',
    Fetish.bodyFeet: 'Pés',
    Fetish.bodyHands: 'Mãos',
    Fetish.bodyHappyTrail: 'Trilha de Pelos',
    Fetish.bodyLongHair: 'Cabelo Longo',
    Fetish.bodyMuscles: 'Músculos',
    Fetish.bodyMusk: 'Cheiro Natural',
    Fetish.bodyNipples: 'Mamilos',
    Fetish.bodyPecs: 'Peitorais',
    Fetish.bodyPiercings: 'Piercings',
    Fetish.bodyPubesNatural: 'Bush (púbis)',
    Fetish.bodyPubesShaved: 'Raspado (púbis)',
    Fetish.bodyPubesTrimmed: 'Aparado (púbis)',
    Fetish.bodyScars: 'Cicatrizes',
    Fetish.bodySpit: 'Cuspe',
    Fetish.bodyTatoos: 'Tatuagens',
    Fetish.clothingBaseballCaps: 'Bonés de Beisebol',
    Fetish.clothingBoots: 'Botas',
    Fetish.clothingDenim: 'Denim',
    Fetish.clothingLeather: 'Couro',
    Fetish.clothingLingerie: 'Lingerie',
    Fetish.clothingMasks: 'Máscaras',
    Fetish.clothingOnsies: 'Macacões',
    Fetish.clothingRubber: 'Borracha',
    Fetish.clothingSagging: 'Calças caindo',
    Fetish.clothingSinglets: 'Regatas',
    Fetish.clothingSocks: 'Meias',
    Fetish.clothingSpandexLycra: 'Spandex/Lycra',
    Fetish.clothingSpeedos: 'Sunga',
    Fetish.clothingSportsUniforms: 'Uniformes Esportivos',
    Fetish.clothingSportsGear: 'Equipamento Esportivo',
    Fetish.clothingSuits: 'Ternos',
    Fetish.clothingUniforms: 'Uniformes',
    Fetish.clothingUnderwear: 'Roupa Íntima',
    Fetish.clothingUnderwearBoxers: 'Cuecas',
    Fetish.clothingUnderwearBoxerBriefs: 'Samba-canção',
    Fetish.clothingUnderwearBriefs: 'Slips',
    Fetish.clothingUnderwearJockstraps: 'Jockstraps',
    Fetish.clothingUnderwearMesh: 'Malha',
    Fetish.clothingUnderwearNylons: 'Meias-calças',
    Fetish.clothingUnderwearPanties: 'Calcinhas',
    Fetish.clothingUnderwearUsed: 'Roupa Íntima Usada',
    Fetish.clothingUnderwearTightyWhities: 'Cuecas Brancas',
  };

  String get label => _pt[this]!;
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\hiv_status.dart ===
enum HivStatus {
  negative,
  prep,
  positive,
  undetectable,
  unknown,
  private_,
}

extension HivStatusLabel on HivStatus {
  static const _pt = {
    HivStatus.negative: 'Negativo',
    HivStatus.prep: 'PrEP',
    HivStatus.positive: 'Positivo',
    HivStatus.undetectable: 'Indetectável',
    HivStatus.unknown: 'Desconhecido',
    HivStatus.private_: 'Privado',
  };
  String get label => _pt[this]!;
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\hosting_status.dart ===
enum HostingStatus { host, travel }

extension HostingStatusLabel on HostingStatus {
  String get label => this == HostingStatus.host ? 'Hospedo' : 'Viajo';
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\immunization_status.dart ===
enum ImmunizationStatus {
  covid1,
  monkeypox1,
  doxyPep,
  condoms,
}

extension ImmunizationStatusLabel on ImmunizationStatus {
  static const _pt = {
    ImmunizationStatus.covid1: 'COVID-19 (1 dose)',
    ImmunizationStatus.monkeypox1: 'Varíola dos macacos (1 dose)',
    ImmunizationStatus.doxyPep: 'DoxyPEP',
    ImmunizationStatus.condoms: 'Camisinhas',
  };
  String get label => _pt[this]!;
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\interaction.dart ===
enum Interaction {
  anonymous,
  blindfolded,
  bukkake,
  cumAndGo,
  dirtyTalk,
  doorOpen,
  dropPants,
  edging,
  eyeContact,
  flip,
  gloryhole,
  gooning,
  noRecip,
  mildToWild,
  mutual,
  pumpAndDump,
  rough,
  understall,
  vanilla,
  watchOnly,
  worship,
}

extension InteractionLabel on Interaction {
  static const _pt = {
    Interaction.anonymous: 'Anônimo',
    Interaction.blindfolded: 'Vendado',
    Interaction.bukkake: 'Bukake',
    Interaction.cumAndGo: 'Gozar e ir',
    Interaction.dirtyTalk: 'Conversa Suja',
    Interaction.doorOpen: 'Porta Aberta',
    Interaction.dropPants: 'Tire as Calças',
    Interaction.edging: 'Edging',
    Interaction.eyeContact: 'Contato Visual',
    Interaction.flip: 'Troca',
    Interaction.gloryhole: 'Buraco da Glória',
    Interaction.gooning: 'Gooning',
    Interaction.noRecip: 'Dê só',
    Interaction.mildToWild: 'Leve a Selvagem',
    Interaction.mutual: 'Jogada Mútua',
    Interaction.pumpAndDump: 'Pump and Dump (Gozada Dentro)',
    Interaction.rough: 'Bruto/Agressivo',
    Interaction.understall: 'Banheiro',
    Interaction.vanilla: 'Vanilla',
    Interaction.watchOnly: 'Assistir apenas',
    Interaction.worship: 'Adoração',
  };

  String get label => _pt[this]!;
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\kink.dart ===
enum Kink {
  bdsm,
  bondage,
  chastity,
  cmnm,
  cumPlay,
  edging,
  enimas,
  exhibitionism,
  facials,
  fisting,
  freeballing,
  fleshlights,
  gagsTape,
  gasMasks,
  gloryholes,
  groups,
  humiliation,
  mirrorPlay,
  pigPlay,
  porn,
  sexToys,
  sexDolls,
  shaving,
  sounding,
  spanking,
  voyeurism,
  watersports,
  wedgies,
  whipping,
  agePlay,
  classrooms,
  costumePlay,
  deliveryGuy,
  doctorPatient,
  firstTime,
  furry,
  handyMan,
  publicLockerRooms,
  publicNudity,
  publicRestrooms,
  publicShowers,
  pupPlay,
  slaveMaster,
  sleepPlay,
  slumberParty,
  superhero,
}

extension KinkLabel on Kink {
  static const _pt = {
    Kink.bdsm: 'BDSM',
    Kink.bondage: 'Bondage/Corda',
    Kink.chastity: 'Castidade',
    Kink.cmnm: 'CMNM (Clothed-Male, Nude-Male)',
    Kink.cumPlay: 'Cum Play',
    Kink.edging: 'Edging',
    Kink.enimas: 'Enemas',
    Kink.exhibitionism: 'Exibicionismo',
    Kink.facials: 'Facial',
    Kink.fisting: 'Punho / Fisting',
    Kink.freeballing: 'Sem Cueca',
    Kink.fleshlights: 'Fleshlights',
    Kink.gagsTape: 'Mordaças/Fita',
    Kink.gasMasks: 'Máscaras de gás',
    Kink.gloryholes: 'Buracos de Glória',
    Kink.groups: 'Sexo em Grupo',
    Kink.humiliation: 'Humilhação',
    Kink.mirrorPlay: 'Espelhos',
    Kink.pigPlay: 'Pig (Sujo)',
    Kink.porn: 'Porno',
    Kink.sexToys: 'Brinquedos Sexuais',
    Kink.sexDolls: 'Bonecas sexuais',
    Kink.shaving: 'Depilar',
    Kink.sounding: 'Soando',
    Kink.spanking: 'Espancar / Surra',
    Kink.voyeurism: 'Voyeurismo',
    Kink.watersports: 'Esportes Aquáticos',
    Kink.wedgies: 'Cuecão',
    Kink.whipping: 'Chicotadas/Açoites',
    Kink.agePlay: 'Papai / Filho',
    Kink.classrooms: 'Sala de Aula',
    Kink.costumePlay: 'Fantasia',
    Kink.deliveryGuy: 'Rapaz das entregas',
    Kink.doctorPatient: 'Médico/Paciente',
    Kink.firstTime: 'Primeira vez',
    Kink.furry: 'Furries',
    Kink.handyMan: 'Trabalhador Braçal',
    Kink.publicLockerRooms: 'Vestiários públicos',
    Kink.publicNudity: 'Nudez pública',
    Kink.publicRestrooms: 'Banheiros Públicos',
    Kink.publicShowers: 'Banhos Públicos',
    Kink.pupPlay: 'Pup Play',
    Kink.slaveMaster: 'Escravo/Mestre',
    Kink.sleepPlay: 'Sleep Play',
    Kink.slumberParty: 'Festa do Pijama',
    Kink.superhero: 'Super-herói',
  };

  String get label => _pt[this]!;
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\location_availability.dart ===
enum LocationAvailability {
  none,
  hasPlace,
  canHostGroup,
  gloryHole,
  hotelRoom,
  inCar,
  lookingLivePlay,
}

extension LocationAvailabilityLabel on LocationAvailability {
  static const _pt = {
    LocationAvailability.none: 'Nenhum',
    LocationAvailability.hasPlace: 'Tenho lugar',
    LocationAvailability.canHostGroup: 'Posso receber grupo',
    LocationAvailability.gloryHole: 'Glory hole',
    LocationAvailability.hotelRoom: 'Quarto de hotel',
    LocationAvailability.inCar: 'No carro',
    LocationAvailability.lookingLivePlay: 'Procurando jogo ao vivo',
  };
  String get label => _pt[this]!;
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\practice.dart ===
enum Practice {
  bareback,
  barebackPrep,
  safe,
  saferOnly,
  safeOrBareback,
  letsTalk,
}

extension PracticeLabel on Practice {
  static const _pt = {
    Practice.bareback: 'Bareback',
    Practice.barebackPrep: 'Bareback + PrEP',
    Practice.safe: 'Seguro',
    Practice.saferOnly: 'Apenas mais seguro',
    Practice.safeOrBareback: 'Seguro ou bareback',
    Practice.letsTalk: 'Vamos conversar',
  };
  String get label => _pt[this]!;
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\public_place.dart ===
enum PublicPlace {
  arcade,
  bar,
  bathhouse,
  beach,
  car,
  event,
  gym,
  outdoor,
  park,
  restroom,
  sauna,
  truckstop,
}

extension PublicPlaceLabel on PublicPlace {
  static const _pt = {
    PublicPlace.arcade: 'Fliperama',
    PublicPlace.bar: 'Bar',
    PublicPlace.bathhouse: 'Casa de banho',
    PublicPlace.beach: 'Praia',
    PublicPlace.car: 'Carro',
    PublicPlace.event: 'Evento',
    PublicPlace.gym: 'Academia',
    PublicPlace.outdoor: 'Ao ar livre',
    PublicPlace.park: 'Parque',
    PublicPlace.restroom: 'Banheiro',
    PublicPlace.sauna: 'Sauna',
    PublicPlace.truckstop: 'Parada de caminhões',
  };
  String get label => _pt[this]!;
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\sexual_attitude.dart ===
enum SexualAttitude {
  noPenetration,
  submissiveBottom,
  bottom,
  greedyBottom,
  versatileBottom,
  versatile,
  versatileTop,
  topBottom,
  top,
  dominantTop,
}

extension SexualAttitudeLabel on SexualAttitude {
  static const _pt = {
    SexualAttitude.noPenetration: 'Sem penetração',
    SexualAttitude.submissiveBottom: 'Passivo submisso',
    SexualAttitude.bottom: 'Passivo',
    SexualAttitude.greedyBottom: 'Passivo guloso',
    SexualAttitude.versatileBottom: 'Versátil + passivo',
    SexualAttitude.versatile: 'Versátil',
    SexualAttitude.versatileTop: 'Versátil + ativo',
    SexualAttitude.topBottom: 'Top sub',
    SexualAttitude.top: 'Ativo',
    SexualAttitude.dominantTop: 'Ativo dominante',
  };
  String get label => _pt[this]!;
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\sexual_spectrum.dart ===
enum SexualSpectrum {
  straight,
  straightCurious,
  biCurious,
  bisexual,
  gay,
}

extension SexualSpectrumLabel on SexualSpectrum {
  static const _pt = {
    SexualSpectrum.straight: 'Hétero',
    SexualSpectrum.straightCurious: 'Hétero-curioso',
    SexualSpectrum.biCurious: 'Bicurioso',
    SexualSpectrum.bisexual: 'Bissexual',
    SexualSpectrum.gay: 'Gay',
  };

  String get label => _pt[this]!;
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\enums\signalr_event_type.dart ===
enum SignalREventType {
  UserConnected,
  UserDisconnected,

  MapUpdateLocation,
  MapReceiveLocation,

  PublicChatSendMessage,
  PublicChatReceiveMessage,
  PublicChatDeleteMessage,
  PublicChatReceiveMessageDeleted,
  PublicChatGetPreviousMessages,

  PrivateChatSendMessage,
  PrivateChatReceiveMessage,
  PrivateChatGetRecentChats,
  PrivateChatReceiveRecentChats,
  PrivateChatGetPreviousMessages,
  PrivateChatReceivePreviousMessages,
  PrivateChatMarkMessagesAsRead,
  PrivateChatDeleteMessage,
  PrivateChatDeleteChat,
  PrivateChatSendImage,
  PrivateChatSendVideo,
  PrivateChatSendAudio,
  PrivateChatReceiveMessageDeleted,

  PrivateChatGetFavorites,
  PrivateChatReceiveFavorites,
  PrivateChatAddFavorite,
  PrivateChatRemoveFavorite,

  PrivateChatReactToMessage,
  PrivateChatReceiveReaction,
  PrivateChatReplyToMessage,
  PrivateChatReceiveReply,

  VideoCallInitiate,
  VideoCallIncoming,
  VideoCallAccept,
  VideoCallReject,
  VideoCallCanceled,
  VideoCallEnd,

  PartyChatSendMessage,
  PartyChatGetPreviousMessages,
  PartyChatSendImage,
  PartyChatDeleteMessage,

  PlaceChatSendMessage,
  PlaceChatReceiveMessage,
  PlaceChatDeleteMessage,
  PlaceChatReceiveMessageDeleted,
  PlaceChatGetPreviousMessages,
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\modals\change_email_modal.dart ===
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/components/custom_modal.dart';
import 'package:snarf/components/loading_elevated_button.dart';
import 'package:snarf/components/themed_text_field.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/services/api_service.dart';
import 'package:snarf/utils/show_snackbar.dart';

class ChangeEmailModal extends StatefulWidget {
  const ChangeEmailModal({super.key});

  @override
  State<ChangeEmailModal> createState() => _ChangeEmailModalState();
}

class _ChangeEmailModalState extends State<ChangeEmailModal> {
  final _formKey = GlobalKey<FormState>();
  final TextEditingController _newEmailController = TextEditingController();
  final TextEditingController _currentPasswordController =
      TextEditingController();

  bool _isLoading = false;
  String? _errorMessage;

  Future<void> _changeEmail() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    final newEmail = _newEmailController.text.trim();
    final currentPassword = _currentPasswordController.text.trim();

    try {
      final result = await ApiService.changeEmail(
        newEmail: newEmail,
        currentPassword: currentPassword,
      );

      if (result == null) {
        showSuccessSnackbar(context, 'Email alterado com sucesso!');
        Navigator.pop(context);
      } else {
        setState(() {
          _errorMessage = result;
        });
      }
    } catch (e) {
      setState(() {
        _errorMessage = 'Erro: $e';
      });
    } finally {
      setState(() => _isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);

    return CustomModal(
      title: 'Mudar Email',
      content: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ThemedTextField(
              controller: _newEmailController,
              labelText: 'Novo Email',
              icon: Icons.email,
              keyboardType: TextInputType.emailAddress,
            ),
            const SizedBox(height: 16),
            ThemedTextField(
              controller: _currentPasswordController,
              labelText: 'Senha Atual',
              icon: Icons.lock,
              obscureText: true,
            ),
            if (_errorMessage != null) ...[
              const SizedBox(height: 16),
              Text(
                _errorMessage!,
                style: TextStyle(color: configProvider.customRed),
              ),
            ],
          ],
        ),
      ),
      actions: [
        LoadingElevatedButton(
          text: 'Confirmar',
          isLoading: _isLoading,
          onPressed: _isLoading ? null : _changeEmail,
        ),
      ],
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\modals\change_password_modal.dart ===
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/components/custom_modal.dart';
import 'package:snarf/components/loading_elevated_button.dart';
import 'package:snarf/components/themed_text_field.dart';
import 'package:snarf/modals/forgot_password_modal.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/services/api_service.dart';
import 'package:snarf/utils/show_snackbar.dart';

class ChangePasswordModal extends StatefulWidget {
  const ChangePasswordModal({super.key});

  @override
  State<ChangePasswordModal> createState() => _ChangePasswordModalState();
}

class _ChangePasswordModalState extends State<ChangePasswordModal> {
  final _formKey = GlobalKey<FormState>();
  final TextEditingController _oldPasswordController = TextEditingController();
  final TextEditingController _newPasswordController = TextEditingController();

  bool _isLoading = false;
  String? _errorMessage;

  Future<void> _changePassword() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    final oldPassword = _oldPasswordController.text.trim();
    final newPassword = _newPasswordController.text.trim();

    try {
      final result = await ApiService.changePassword(
        oldPassword: oldPassword,
        newPassword: newPassword,
      );

      if (result == null) {
        showSuccessSnackbar(context, 'Senha alterada com sucesso!');
        Navigator.pop(context);
      } else {
        setState(() {
          _errorMessage = result;
        });
      }
    } catch (e) {
      setState(() {
        _errorMessage = 'Erro: $e';
      });
    } finally {
      setState(() => _isLoading = false);
    }
  }

  void _showForgotPasswordDialog() {
    showDialog(
      context: context,
      builder: (context) => const ForgotPasswordModal(),
    );
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);

    return CustomModal(
      title: 'Mudar Senha',
      content: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ThemedTextField(
              controller: _oldPasswordController,
              labelText: 'Senha Antiga',
              icon: Icons.lock,
              obscureText: true,
            ),
            const SizedBox(height: 16),
            ThemedTextField(
              controller: _newPasswordController,
              labelText: 'Senha Nova',
              icon: Icons.lock_outline,
              obscureText: true,
            ),
            const SizedBox(height: 8),
            Align(
              alignment: Alignment.centerRight,
              child: TextButton(
                onPressed: _showForgotPasswordDialog,
                child: Text(
                  'Esqueci minha senha',
                  style: TextStyle(color: configProvider.textColor),
                ),
              ),
            ),
            if (_errorMessage != null) ...[
              const SizedBox(height: 16),
              Text(
                _errorMessage!,
                style: TextStyle(color: configProvider.customRed),
              ),
            ],
          ],
        ),
      ),
      actions: [
        LoadingElevatedButton(
          text: 'Confirmar',
          isLoading: _isLoading,
          onPressed: _isLoading ? null : _changePassword,
        ),
      ],
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\modals\forgot_password_modal.dart ===
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/components/custom_modal.dart';
import 'package:snarf/components/loading_elevated_button.dart';
import 'package:snarf/components/themed_text_field.dart';
import 'package:snarf/modals/reset_password_modal.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/services/api_service.dart';

class ForgotPasswordModal extends StatefulWidget {
  const ForgotPasswordModal({super.key});

  @override
  State<ForgotPasswordModal> createState() => _ForgotPasswordModalState();
}

class _ForgotPasswordModalState extends State<ForgotPasswordModal> {
  final TextEditingController _emailController = TextEditingController();
  bool _isLoading = false;
  String? _errorMessage;

  Future<void> _requestResetCode() async {
    final email = _emailController.text.trim();

    if (email.isEmpty) {
      setState(() {
        _errorMessage = 'Por favor, insira seu e-mail.';
      });
      return;
    }

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final response = await ApiService.requestResetPassword(email);

      if (response == null) {
        Navigator.pop(context);
        showResetPasswordModal(context, email);
      } else {
        setState(() {
          _errorMessage = response;
        });
      }
    } catch (e) {
      setState(() {
        _errorMessage = 'Erro ao solicitar código: $e';
      });
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);

    return CustomModal(
      title: 'Esqueci Minha Senha',
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            'Insira seu e-mail para receber um código de redefinição de senha.',
            style: TextStyle(
              color: configProvider.textColor,
            ),
          ),
          const SizedBox(height: 16),
          ThemedTextField(
            controller: _emailController,
            labelText: 'E-mail',
            icon: Icons.email,
            keyboardType: TextInputType.emailAddress,
          ),
          if (_errorMessage != null) ...[
            const SizedBox(height: 16),
            Text(
              _errorMessage!,
              style: TextStyle(color: configProvider.customRed),
            ),
          ],
        ],
      ),
      actions: [
        LoadingElevatedButton(
          text: 'Enviar Código',
          isLoading: _isLoading,
          onPressed: _isLoading ? null : _requestResetCode,
        ),
      ],
    );
  }
}

void showResetPasswordModal(BuildContext context, String email) {
  showDialog(
    context: context,
    builder: (context) => ResetPasswordModal(email: email),
  );
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\modals\login_modal.dart ===
import 'dart:ui';
import 'package:firebase_analytics/firebase_analytics.dart';
import 'package:flutter/material.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:provider/provider.dart';
import 'package:snarf/components/custom_modal.dart';
import 'package:snarf/components/loading_elevated_button.dart';
import 'package:snarf/modals/register_modal.dart';
import 'package:snarf/pages/account/initial_page.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/services/api_service.dart';

class LoginModal extends StatefulWidget {
  final VoidCallback onLoginSuccess;

  const LoginModal({super.key, required this.onLoginSuccess});

  @override
  State<LoginModal> createState() => _LoginModalState();
}

class _LoginModalState extends State<LoginModal> {
  final TextEditingController emailController = TextEditingController();
  final TextEditingController passwordController = TextEditingController();
  final ValueNotifier<bool> isPasswordVisible = ValueNotifier(false);
  static const _secureStorage = FlutterSecureStorage();
  bool isLoading = false;
  String? errorMessage;

  final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;

  Future<void> login() async {
    final String email = emailController.text.trim();
    final String password = passwordController.text.trim();

    if (email.isEmpty || password.isEmpty) {
      setState(() {
        errorMessage = 'Por favor, preencha todos os campos.';
      });
      return;
    }

    setState(() {
      isLoading = true;
      errorMessage = null;
    });

    try {
      final loginResponse = await ApiService.login(email, password);

      await _analytics.logEvent(
        name: 'login_attempt',
        parameters: {
          'email': email,
        },
      );

      await _secureStorage.write(key: 'email', value: email);
      await _secureStorage.write(key: 'password', value: password);

      if (loginResponse == null) {
        await _analytics.logEvent(
          name: 'login_success',
          parameters: {
            'email': email,
          },
        );
        widget.onLoginSuccess();
      } else {
        await _analytics.logEvent(
          name: 'login_failure',
          parameters: {
            'email': email,
            'error': loginResponse,
          },
        );
        setState(() {
          errorMessage = loginResponse;
        });
      }
    } catch (e) {
      await _analytics.logEvent(
        name: 'login_exception',
        parameters: {
          'error': e.toString(),
        },
      );
      setState(() {
        errorMessage = 'Ocorreu um erro: $e';
      });
    } finally {
      setState(() {
        isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);

    _analytics.logScreenView(
      screenName: 'LoginModal',
      screenClass: 'LoginModal',
    );

    return BackdropFilter(
      filter: ImageFilter.blur(sigmaX: 5, sigmaY: 5),
      child: CustomModal(
        title: 'Login',
        content: SingleChildScrollView(
          child: Column(
            children: [
              const SizedBox(height: 10),
              TextField(
                controller: emailController,
                style: TextStyle(color: configProvider.textColor),
                decoration: InputDecoration(
                  labelText: 'E-mail',
                  labelStyle: TextStyle(color: configProvider.textColor),
                  prefixIconColor: configProvider.iconColor,
                  prefixIcon: const Icon(Icons.email),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(15),
                  ),
                ),
                keyboardType: TextInputType.emailAddress,
              ),
              const SizedBox(height: 16),
              ValueListenableBuilder(
                valueListenable: isPasswordVisible,
                builder: (context, isVisible, child) {
                  return TextField(
                    controller: passwordController,
                    style: TextStyle(color: configProvider.textColor),
                    decoration: InputDecoration(
                      labelText: 'Senha',
                      labelStyle: TextStyle(color: configProvider.textColor),
                      prefixIconColor: configProvider.iconColor,
                      prefixIcon: const Icon(Icons.lock),
                      suffixIcon: IconButton(
                        icon: Icon(
                          isVisible ? Icons.visibility : Icons.visibility_off,
                        ),
                        color: configProvider.iconColor,
                        onPressed: () {
                          isPasswordVisible.value = !isVisible;
                        },
                      ),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(15),
                      ),
                    ),
                    obscureText: !isVisible,
                  );
                },
              ),
              if (errorMessage != null) ...[
                const SizedBox(height: 16),
                Text(
                  errorMessage!,
                  style: const TextStyle(color: Colors.red),
                ),
              ],
            ],
          ),
        ),
        actions: [
          if (isLoading)
            const Center(child: CircularProgressIndicator())
          else ...[
            LoadingElevatedButton(
              text: 'Entrar',
              isLoading: false,
              onPressed: login,
            ),
            Column(
              children: [
                GestureDetector(
                  onTap: () {
                    Navigator.pop(context);
                    showForgotPasswordModal(context);
                  },
                  child: const Padding(
                    padding: EdgeInsets.only(top: 16.0),
                    child: Text(
                      'Esqueci minha senha',
                      style: TextStyle(
                        color: Colors.blue,
                      ),
                    ),
                  ),
                ),
                GestureDetector(
                  onTap: () {
                    showDialog(
                      context: context,
                      builder: (context) => const RegisterModal(),
                    );
                  },
                  child: Padding(
                    padding: EdgeInsets.only(top: 8.0),
                    child: Column(
                      children: [
                        Text(
                          'Primeira vez no Snarf? ',
                          style: TextStyle(
                            color: configProvider.textColor,
                          ),
                        ),
                        Text(
                          'Criar conta',
                          style: TextStyle(
                            color: Colors.blue,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ],
        ],
      ),
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\modals\register_modal.dart ===
import 'dart:convert';
import 'dart:io';
import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_image_compress/flutter_image_compress.dart';
import 'package:firebase_analytics/firebase_analytics.dart';
import 'package:path_provider/path_provider.dart';
import 'package:provider/provider.dart';
import 'package:snarf/components/custom_modal.dart';
import 'package:snarf/components/loading_elevated_button.dart';
import 'package:snarf/pages/home_page.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/services/api_service.dart';

class RegisterModal extends StatefulWidget {
  const RegisterModal({super.key});

  @override
  State<RegisterModal> createState() => _RegisterModalState();
}

class _RegisterModalState extends State<RegisterModal> {
  final TextEditingController _emailController = TextEditingController();
  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();

  final String _defaultImagePath = 'assets/images/user_anonymous.png';
  bool _isLoading = false;
  String? _errorMessage;

  final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;

  @override
  void initState() {
    super.initState();
    _analytics.logScreenView(
      screenName: 'RegisterModal',
      screenClass: 'RegisterModal',
    );
  }

  Future<File> getAssetFile(String assetPath) async {
    final byteData = await rootBundle.load(assetPath);
    final tempDir = await getTemporaryDirectory();
    final tempFilePath = '${tempDir.path}/user_anonymous.png';
    final file = File(tempFilePath);
    await file.writeAsBytes(byteData.buffer.asUint8List());
    return file;
  }

  Future<void> _register() async {
    final email = _emailController.text.trim();
    final name = _nameController.text.trim();
    final password = _passwordController.text.trim();

    if (email.isEmpty || name.isEmpty || password.isEmpty) {
      setState(() {
        _errorMessage = 'Por favor, preencha todos os campos.';
      });
      return;
    }

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      await _analytics.logEvent(name: 'register_attempt');

      final pickedFile = await getAssetFile(_defaultImagePath);
      String base64Image = '';
      final compressedImage = await FlutterImageCompress.compressWithFile(
        pickedFile.absolute.path,
        quality: 50,
      );
      if (compressedImage != null) {
        base64Image = base64Encode(compressedImage);
      }

      final createResponse =
          await ApiService.register(email, name, password, base64Image);

      if (createResponse == null) {
        final loginResponse = await ApiService.login(email, password);
        if (loginResponse == null) {
          await _analytics.logEvent(name: 'register_success');
          if (mounted) {
            Navigator.pop(context);
            Navigator.pushReplacement(
              context,
              MaterialPageRoute(builder: (context) => const HomePage()),
            );
          }
        } else {
          setState(() {
            _errorMessage = 'Erro ao fazer login após cadastro.';
          });
          await _analytics.logEvent(
            name: 'register_login_error',
            parameters: {'message': _errorMessage!},
          );
        }
      } else {
        setState(() {
          _errorMessage = createResponse;
        });
        await _analytics.logEvent(
          name: 'register_failure',
          parameters: {'error': createResponse},
        );
      }
    } catch (e) {
      setState(() {
        _errorMessage = 'Ocorreu um erro: $e';
      });
      await _analytics.logEvent(
        name: 'register_exception',
        parameters: {'error': e.toString()},
      );
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);

    return BackdropFilter(
      filter: ImageFilter.blur(sigmaX: 5, sigmaY: 5),
      child: CustomModal(
        title: 'Cadastro',
        content: SingleChildScrollView(
          child: Column(
            children: [
              const SizedBox(height: 8),
              TextField(
                controller: _emailController,
                style: TextStyle(color: configProvider.textColor),
                decoration: InputDecoration(
                  labelText: 'E-mail',
                  labelStyle: TextStyle(color: configProvider.textColor),
                  prefixIconColor: configProvider.iconColor,
                  prefixIcon: const Icon(Icons.email),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12.0),
                  ),
                ),
                keyboardType: TextInputType.emailAddress,
              ),
              const SizedBox(height: 16),
              TextField(
                controller: _nameController,
                style: TextStyle(color: configProvider.textColor),
                decoration: InputDecoration(
                  labelText: 'Nome',
                  labelStyle: TextStyle(color: configProvider.textColor),
                  prefixIconColor: configProvider.iconColor,
                  prefixIcon: const Icon(Icons.person),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12.0),
                  ),
                ),
              ),
              const SizedBox(height: 16),
              TextField(
                controller: _passwordController,
                style: TextStyle(color: configProvider.textColor),
                obscureText: true,
                decoration: InputDecoration(
                  labelText: 'Senha',
                  labelStyle: TextStyle(color: configProvider.textColor),
                  prefixIconColor: configProvider.iconColor,
                  prefixIcon: const Icon(Icons.lock),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12.0),
                  ),
                ),
              ),
              const SizedBox(height: 16),
              if (_errorMessage != null)
                Text(
                  _errorMessage!,
                  style: const TextStyle(color: Colors.red),
                ),
            ],
          ),
        ),
        actions: [
          if (_isLoading)
            const Center(child: CircularProgressIndicator())
          else
            LoadingElevatedButton(
              text: 'Cadastrar',
              isLoading: false,
              onPressed: _register,
            ),
        ],
      ),
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\modals\reset_password_modal.dart ===
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/components/custom_modal.dart';
import 'package:snarf/components/loading_elevated_button.dart';
import 'package:snarf/components/themed_text_field.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/services/api_service.dart';

class ResetPasswordModal extends StatefulWidget {
  final String email;

  const ResetPasswordModal({super.key, required this.email});

  @override
  State<ResetPasswordModal> createState() => _ResetPasswordModalState();
}

class _ResetPasswordModalState extends State<ResetPasswordModal> {
  final TextEditingController _codeController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();
  bool _isLoading = false;
  String? _errorMessage;

  Future<void> _resetPassword() async {
    final code = _codeController.text.trim();
    final password = _passwordController.text.trim();

    if (code.isEmpty || password.isEmpty) {
      setState(() {
        _errorMessage = 'Por favor, preencha todos os campos.';
      });
      return;
    }

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final response =
          await ApiService.resetPassword(widget.email, code, password);

      if (response == null) {
        Navigator.pop(context);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('Senha redefinida com sucesso!'),
            backgroundColor: Colors.green,
          ),
        );
      } else {
        setState(() {
          _errorMessage = response;
        });
      }
    } catch (e) {
      setState(() {
        _errorMessage = 'Erro ao redefinir a senha: $e';
      });
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);

    return CustomModal(
      title: 'Redefinir Senha',
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            'Insira o código recebido por e-mail e sua nova senha.',
            style: TextStyle(color: configProvider.textColor),
          ),
          const SizedBox(height: 16),
          ThemedTextField(
            controller: _codeController,
            labelText: 'Código',
            icon: Icons.dataset,
          ),
          const SizedBox(height: 16),
          ThemedTextField(
            controller: _passwordController,
            labelText: 'Nova Senha',
            icon: Icons.lock,
            obscureText: true,
          ),
          if (_errorMessage != null) ...[
            const SizedBox(height: 16),
            Text(
              _errorMessage!,
              style: TextStyle(color: configProvider.customRed),
            ),
          ],
        ],
      ),
      actions: [
        LoadingElevatedButton(
          text: 'Redefinir Senha',
          isLoading: _isLoading,
          onPressed: _isLoading ? null : _resetPassword,
        ),
      ],
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\home_page.dart ===
import 'dart:async';
import 'dart:convert';
import 'dart:developer';
import 'dart:io';
import 'package:firebase_analytics/firebase_analytics.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:geolocator/geolocator.dart';
import 'package:latlong2/latlong.dart';
import 'package:provider/provider.dart';
import 'package:snarf/pages/account/config_profile_page.dart';
import 'package:snarf/pages/account/config_profile_preferences_page.dart';
import 'package:snarf/pages/account/edit_user_page.dart';
import 'package:snarf/pages/account/initial_page.dart';
import 'package:snarf/pages/account/view_user_page.dart';
import 'package:snarf/pages/parties/create_edit_party_page.dart';
import 'package:snarf/pages/parties/party_details_page.dart';
import 'package:snarf/pages/places/create_edit_place_page.dart';
import 'package:snarf/pages/places/place_details_page.dart';
import 'package:snarf/pages/privateChat/private_chat_navigation_page.dart';
import 'package:snarf/pages/public_chat_page.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/providers/intercepted_image_provider.dart';
import 'package:snarf/services/api_service.dart';
import 'package:snarf/services/location_service.dart';
import 'package:snarf/services/signalr_manager.dart';
import 'package:snarf/utils/show_snackbar.dart';
import 'package:snarf/enums/signalr_event_type.dart';

class HomePage extends StatefulWidget {
  final double? initialLatitude;
  final double? initialLongitude;

  const HomePage({super.key, this.initialLatitude, this.initialLongitude});

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  late LocationService _locationService;
  late Position _currentLocation;
  bool _isLocationLoaded = false;
  late MapController _mapController;
  Marker? _userLocationMarker;
  final Map<String, Marker> _userMarkers = {};
  final Map<String, Marker> _partyMarkers = {};
  final Map<String, Marker> _placeMarkers = {};
  late String userImage = '';
  double _opacity = 0.0;
  late Timer _timer;
  String? _fcmToken;
  final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;

  IconData getPartyTypeIcon(int type) {
    switch (type) {
      case 0:
        return Icons.local_fire_department;
      case 1:
        return Icons.bolt;
      case 2:
        return Icons.handshake;
      case 3:
        return Icons.emoji_people;
      case 4:
        return Icons.favorite;
      case 5:
        return Icons.star;
      default:
        return Icons.event;
    }
  }

  IconData getPlaceTypeIcon(int type) {
    switch (type) {
      case 0:
        return Icons.fitness_center;
      case 1:
        return Icons.wc;
      case 2:
        return Icons.local_bar;
      case 3:
        return Icons.local_cafe;
      case 4:
        return Icons.shower;
      case 5:
        return Icons.event;
      case 6:
        return Icons.videogame_asset;
      case 7:
        return Icons.hotel;
      case 8:
        return Icons.device_unknown;
      case 9:
        return Icons.local_shipping;
      case 10:
        return Icons.park;
      case 11:
        return Icons.beach_access;
      case 12:
        return Icons.hot_tub;
      default:
        return Icons.place;
    }
  }

  @override
  void initState() {
    super.initState();
    final cfg = Provider.of<ConfigProvider>(context, listen: false);
    _locationService = LocationService(usePrecise: cfg.usePreciseLocation);
    _initializeApp();
    _mapController = MapController();
    _initializeApp();
    _startOpacityAnimation();
  }

  void _startOpacityAnimation() {
    _timer = Timer.periodic(const Duration(milliseconds: 500), (timer) {
      setState(() {
        _opacity = _opacity == 0.0 ? 1.0 : 0.0;
      });
    });
  }

  Future<void> _initializeApp() async {
    await _loadUserInfo();
    await _getFcmToken();
    await _initializeLocation();
    await _setupSignalRConnection();
    await _fetchFirstMessage();
    await _getAllParties();
    await _getAllPlaces();
    await _analytics
        .logEvent(name: 'app_initialized', parameters: {'screen': 'HomePage'});

    await Future.wait([
      SignalRManager()
          .sendSignalRMessage(SignalREventType.PrivateChatGetRecentChats, {})
    ]);
  }

  Future<void> _getFcmToken() async {
    String? fcmToken = "";
    if (Platform.isIOS) {
      fcmToken = await FirebaseMessaging.instance.getAPNSToken();
    } else if (Platform.isAndroid) {
      fcmToken = await FirebaseMessaging.instance.getToken();
    } else {
      throw Exception("Plataforma não suportada ${Platform.operatingSystem}");
    }
    if (fcmToken != null) {
      _fcmToken = fcmToken;
      await _analytics.logEvent(
          name: 'fcm_token_received',
          parameters: {'token_length': fcmToken.length});
    }
  }

  Future<void> _fetchFirstMessage() async {
    final config = Provider.of<ConfigProvider>(context, listen: false);
    final messageData = await ApiService.getFirstMessageOfDay();
    if (messageData != null && messageData['firstMessageToDay'] != null) {
      config.setFirstMessageToday(
          DateTime.parse(messageData['firstMessageToDay']));
    }
  }

  Future<void> _loadUserInfo() async {
    final userId = await ApiService.getUserIdFromToken();
    if (userId == null) {
      showErrorSnackbar(context, 'Não foi possível obter ID do token');
      await _analytics.logEvent(
          name: 'error', parameters: {'message': 'Falha ao obter ID do token'});
      return;
    }
    final userInfo = await ApiService.getUserInfoById(userId);
    if (userInfo != null) {
      userImage = userInfo['getFirstPhoto'];
    } else {
      showErrorSnackbar(context, 'Erro ao carregar informações do usuário');
      await _analytics.logEvent(name: 'error', parameters: {
        'message': 'Falha ao carregar informações do usuário',
        'user_id': userId
      });
      await _logout(context);
    }
  }

  Future<void> _initializeLocation() async {
    final ok = await _locationService.initialize();
    if (ok) {
      _currentLocation = await _locationService.getCurrentLocation();
      setState(() {
        _isLocationLoaded = true;
        _updateUserMarker(
          _currentLocation.latitude!,
          _currentLocation.longitude!,
        );
      });

      Future.delayed(const Duration(seconds: 60), () {
        _locationService.startUpdates();
      });

      _locationService.onLocationChanged.listen((loc) async {
        setState(() {
          _currentLocation = loc;
          _updateUserMarker(loc.latitude!, loc.longitude!);
        });
        await _sendLocationUpdate();
      });
    } else {
      throw Exception("Erro ao inicializar localização");
    }
  }

  Future<void> _setupSignalRConnection() async {
    SignalRManager().listenToEvent("ReceiveMessage", _onReceiveMessage);
    await _analytics.logEvent(name: 'signalr_connection_initialized');
  }

  void _onReceiveMessage(List<Object?>? args) async {
    if (args == null || args.isEmpty) return;
    try {
      final Map<String, dynamic> message = jsonDecode(args[0] as String);
      final SignalREventType type = SignalREventType.values.firstWhere(
        (e) => e.toString().split('.').last == message['Type'],
        orElse: () => SignalREventType.MapReceiveLocation,
      );
      final dynamic data = message['Data'];
      await _analytics.logEvent(
          name: 'signalr_message_received',
          parameters: {'type': message['Type']});
      switch (type) {
        case SignalREventType.MapReceiveLocation:
          _handleReceiveLocation(data);
          break;
        case SignalREventType.UserDisconnected:
          _handleUserDisconnected(data);
          break;
        default:
          await _analytics.logEvent(
              name: 'signalr_unrecognized_event',
              parameters: {'type': message['Type']});
      }
    } catch (e) {
      await _analytics.logEvent(
          name: 'signalr_process_error', parameters: {'error': e.toString()});
    }
  }

  void _handleReceiveLocation(Map<String, dynamic> data) {
    final config = Provider.of<ConfigProvider>(context, listen: false);
    final userId = data['userId'];
    final latitude = data['Latitude'];
    final longitude = data['Longitude'];
    final userImg = data['userImage'];
    final videoCall = data['videoCall'];
    setState(() {
      _userMarkers[userId] = Marker(
        point: LatLng(latitude, longitude),
        width: 80,
        height: 80,
        child: GestureDetector(
          onTap: () => _openProfile(userId),
          child: Stack(
            alignment: Alignment.center,
            children: [
              Container(
                width: 75,
                height: 75,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  border: Border.all(color: config.customGreen, width: 4.0),
                ),
                child: CircleAvatar(
                  backgroundImage: InterceptedImageProvider(
                    originalProvider: NetworkImage(userImg),
                    hideImages: config.hideImages,
                  ),
                  radius: 25,
                ),
              ),
              if (videoCall)
                Positioned(
                  bottom: 0,
                  left: 0,
                  child: Container(
                    width: 25,
                    height: 25,
                    decoration: BoxDecoration(
                        color: config.customOrange, shape: BoxShape.circle),
                    child: Icon(Icons.videocam,
                        color: config.customWhite, size: 14),
                  ),
                ),
              Positioned(
                top: 0,
                right: 0,
                child: Container(
                  width: 25,
                  height: 25,
                  decoration: BoxDecoration(
                      color: config.customGreen, shape: BoxShape.circle),
                  child:
                      Icon(Icons.person, color: config.customWhite, size: 14),
                ),
              ),
            ],
          ),
        ),
      );
    });
  }

  void _handleUserDisconnected(Map<String, dynamic> data) async {
    final userId = data['userId'];
    setState(() {
      _userMarkers.remove(userId);
    });
    await _analytics
        .logEvent(name: 'user_disconnected', parameters: {'user_id': userId});
  }

  Future<void> _sendLocationUpdate() async {
    try {
      final configProvider =
          Provider.of<ConfigProvider>(context, listen: false);
      await SignalRManager().sendSignalRMessage(
        SignalREventType.MapUpdateLocation,
        {
          "Latitude": _currentLocation.latitude,
          "Longitude": _currentLocation.longitude,
          "FcmToken": _fcmToken,
          "VideoCall": configProvider.hideVideoCall,
        },
      );
      await _analytics.logEvent(
        name: 'location_update_sent',
        parameters: {
          'latitude': _currentLocation.latitude!,
          'longitude': _currentLocation.longitude!,
          "VideoCall": configProvider.hideVideoCall,
        },
      );
    } catch (e) {
      await _analytics.logEvent(
          name: 'location_update_failed', parameters: {'error': e.toString()});
    }
  }

  void _updateUserMarker(double latitude, double longitude) {
    final config = Provider.of<ConfigProvider>(context, listen: false);
    _userLocationMarker = Marker(
      point: LatLng(latitude, longitude),
      width: 80,
      height: 80,
      child: Stack(
        alignment: Alignment.center,
        children: [
          Container(
            width: 75,
            height: 75,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              border: Border.all(color: config.customGreen, width: 4.0),
            ),
            child: CircleAvatar(
              backgroundImage: InterceptedImageProvider(
                originalProvider: NetworkImage(userImage),
                hideImages: false,
              ),
              radius: 25,
            ),
          ),
          if (config.hideVideoCall)
            Positioned(
              bottom: 0,
              left: 0,
              child: Container(
                width: 25,
                height: 25,
                decoration: BoxDecoration(
                    color: config.customOrange, shape: BoxShape.circle),
                child:
                    Icon(Icons.videocam, color: config.customWhite, size: 20),
              ),
            ),
          Positioned(
            top: 0,
            right: 0,
            child: Container(
              width: 25,
              height: 25,
              decoration: BoxDecoration(
                  color: config.customGreen, shape: BoxShape.circle),
              child: Icon(Icons.person, color: config.customWhite, size: 20),
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _getAllParties() async {
    final userId = await ApiService.getUserIdFromToken();
    if (userId == null) return;
    final result = await ApiService.getAllParties(userId);
    if (result != null && result['data'] != null) {
      final List parties = result['data'];
      for (var p in parties) {
        final id = p['id'].toString();
        final lat = p['latitude'] is double ? p['latitude'] : 0.0;
        final lon = p['longitude'] is double ? p['longitude'] : 0.0;
        final title = p['title'].toString();
        final imageUrl = p['imageUrl'].toString();
        final userRole = p['userRole'].toString();
        final partyType = p['type'] ?? 0;
        _addPartyMarker(id, lat, lon, title, imageUrl, userRole, partyType);
      }
      setState(() {});
    }
  }

  Future<void> _getAllPlaces() async {
    final result = await ApiService.getAllPlaces();
    if (result != null && result['data'] != null) {
      final List places = result['data'];
      for (var place in places) {
        final id = place['id'].toString();
        final lat = place['latitude'] is double ? place['latitude'] : 0.0;
        final lon = place['longitude'] is double ? place['longitude'] : 0.0;
        final title = place['title'].toString();
        final imageUrl = place['imageUrl'].toString();
        final placeType = place['type'] ?? 0;
        _addPlaceMarker(id, lat, lon, title, imageUrl, placeType);
      }
      setState(() {});
    }
  }

  void _addPartyMarker(String partyId, double lat, double lon, String title,
      String imageUrl, String userRole, int type) {
    _partyMarkers[partyId] = Marker(
      point: LatLng(lat, lon),
      width: 60,
      height: 60,
      child: GestureDetector(
        onTap: () => _openPartyDetails(partyId),
        child: CircleAvatar(
          backgroundColor: Colors.red,
          child: Icon(getPartyTypeIcon(type), color: Colors.white),
        ),
      ),
    );
  }

  void _addPlaceMarker(String placeId, double lat, double lon, String title,
      String imageUrl, int type) {
    _placeMarkers[placeId] = Marker(
      point: LatLng(lat, lon),
      width: 60,
      height: 60,
      child: GestureDetector(
        onTap: () => _openPlaceDetails(placeId),
        child: CircleAvatar(
          backgroundColor: Colors.blue,
          child: Icon(getPlaceTypeIcon(type), color: Colors.white),
        ),
      ),
    );
  }

  void _openPartyDetails(String partyId) async {
    final userId = await ApiService.getUserIdFromToken();
    if (userId == null) return;
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => PartyDetailsPage(
          partyId: partyId,
          userId: userId,
        ),
      ),
    );
  }

  void _openPlaceDetails(String placeId) async {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => PlaceDetailsPage(placeId: placeId),
      ),
    );
  }

  void _recenterMap() async {
    if (_isLocationLoaded) {
      _mapController.move(
          LatLng(_currentLocation.latitude!, _currentLocation.longitude!),
          15.0);
      await _analytics.logEvent(name: 'map_recentering', parameters: {
        'latitude': _currentLocation.latitude!,
        'longitude': _currentLocation.longitude!
      });
    }
  }

  String _getMapUrl(BuildContext context) {
    final isDarkMode = Provider.of<ConfigProvider>(context).isDarkMode;
    return isDarkMode
        ? 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png'
        : 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png';
  }

  void _openProfile(String userId) async {
    await _analytics.logEvent(
        name: 'open_other_user_profile', parameters: {'user_id': userId});
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => ViewUserPage(userId: userId)),
    );
  }

  void _openPrivateChat(BuildContext context) async {
    await _analytics.logEvent(name: 'open_private_chat');
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => GestureDetector(
        onTap: () => Navigator.pop(context),
        behavior: HitTestBehavior.opaque,
        child: Padding(
          padding: const EdgeInsets.only(right: 50),
          child: GestureDetector(
            onTap: () {},
            child: Container(
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(30.0),
                border: Border.symmetric(
                  horizontal: BorderSide(
                    color: Provider.of<ConfigProvider>(context, listen: false)
                        .secondaryColor,
                    width: 5,
                  ),
                ),
              ),
              child: DraggableScrollableSheet(
                initialChildSize: 0.9,
                minChildSize: 0.9,
                maxChildSize: 0.9,
                expand: false,
                builder: (context, scrollController) {
                  return ClipRRect(
                    borderRadius: const BorderRadius.vertical(
                        top: Radius.circular(30), bottom: Radius.circular(30)),
                    child: Scaffold(
                      body: PrivateChatNavigationPage(
                          scrollController: scrollController),
                    ),
                  );
                },
              ),
            ),
          ),
        ),
      ),
    );
  }

  void _openPublicChat(BuildContext context) async {
    await _analytics.logEvent(name: 'open_public_chat');
    final configProvider = Provider.of<ConfigProvider>(context, listen: false);
    log("Abrindo chat para assinante: ${configProvider.isSubscriber}");
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => GestureDetector(
        onTap: () => Navigator.pop(context),
        behavior: HitTestBehavior.opaque,
        child: Padding(
          padding: const EdgeInsets.only(left: 50),
          child: GestureDetector(
            onTap: () {},
            child: Container(
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(30.0),
                border: Border.symmetric(
                    horizontal: BorderSide(
                        color: configProvider.secondaryColor, width: 5)),
              ),
              child: DraggableScrollableSheet(
                initialChildSize: 0.9,
                minChildSize: 0.9,
                maxChildSize: 0.9,
                expand: false,
                builder: (context, scrollController) {
                  return ClipRRect(
                    borderRadius: const BorderRadius.vertical(
                        top: Radius.circular(30), bottom: Radius.circular(30)),
                    child: Scaffold(
                      body: PublicChatPage(scrollController: scrollController),
                    ),
                  );
                },
              ),
            ),
          ),
        ),
      ),
    );
  }

  void _showConfigProfile(BuildContext context) async {
    await _analytics.logEvent(name: 'open_config_profile');
    final configProvider = Provider.of<ConfigProvider>(context, listen: false);
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => GestureDetector(
        onTap: () => Navigator.pop(context),
        behavior: HitTestBehavior.opaque,
        child: Padding(
          padding: const EdgeInsets.only(left: 50),
          child: GestureDetector(
            onTap: () {},
            child: Container(
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(30.0),
                border: Border.symmetric(
                    horizontal: BorderSide(
                        color: configProvider.secondaryColor, width: 5)),
              ),
              child: DraggableScrollableSheet(
                initialChildSize: 0.9,
                minChildSize: 0.9,
                maxChildSize: 0.9,
                expand: false,
                builder: (context, scrollController) {
                  return ClipRRect(
                    borderRadius: const BorderRadius.vertical(
                        top: Radius.circular(30), bottom: Radius.circular(30)),
                    child: Scaffold(
                      body: ConfigProfilePreferencesPage(),
                    ),
                  );
                },
              ),
            ),
          ),
        ),
      ),
    );
  }

  void _showCustomMenu(BuildContext context, Offset offset) { //mostra o menu
    final configProvider = Provider.of<ConfigProvider>(context, listen: false);
    showMenu(
      context: context,
      color: configProvider.primaryColor,
      position: RelativeRect.fromLTRB(
          offset.dx, offset.dy, offset.dx + 50, offset.dy + 50),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(30),
        side: BorderSide(color: configProvider.secondaryColor, width: 3),
      ),
      items: [
        PopupMenuItem(
          value: 'config',
          child: Row(
            children: [
              Icon(Icons.person, color: configProvider.iconColor),
              const SizedBox(width: 10),
              Text("Meu Perfil",
                  style:
                      TextStyle(fontSize: 16, color: configProvider.textColor)),
            ],
          ),
        ),
        PopupMenuItem(
          value: 'profile_settings',
          child: Row(
            children: [
              Icon(Icons.settings, color: configProvider.iconColor),
              const SizedBox(width: 10),
              Text("Configurações de Perfil",
                  style:
                      TextStyle(fontSize: 16, color: configProvider.textColor)),
            ],
          ),
        ),
        PopupMenuItem(
          value: 'create_party',
          child: Row(
            children: [
              Icon(Icons.add, color: configProvider.iconColor),
              const SizedBox(width: 10),
              Text("Criar festa",
                  style:
                      TextStyle(fontSize: 16, color: configProvider.textColor)),
            ],
          ),
        ),
        PopupMenuItem(
          value: 'create_place',
          child: Row(
            children: [
              Icon(Icons.add, color: configProvider.iconColor),
              const SizedBox(width: 10),
              Text("Criar local",
                  style:
                      TextStyle(fontSize: 16, color: configProvider.textColor)),
            ],
          ),
        ),
        PopupMenuItem(
          enabled: true,
          child: SwitchListTile(
            title: Text("Localização Precisa",
                style:
                    TextStyle(fontSize: 16, color: configProvider.textColor)),
            secondary: Icon(Icons.location_on, color: configProvider.iconColor),
            value: configProvider.usePreciseLocation,
            onChanged: (_) async {
              Navigator.pop(context);
              configProvider.toggleUsePreciseLocation();
              await _analytics.logEvent(
                  name: 'toggle_precise_location');
              _locationService.dispose();
              _locationService = LocationService(
                  usePrecise: configProvider.usePreciseLocation);
              await _initializeLocation();
            },
          ),
        ),
        PopupMenuItem(
          enabled: true,
          child: SwitchListTile(
            title: Text("Modo Noturno",
                style:
                    TextStyle(fontSize: 16, color: configProvider.textColor)),
            secondary:
                Icon(Icons.brightness_6, color: configProvider.iconColor),
            value: configProvider.isDarkMode,
            onChanged: (_) async {
              Navigator.pop(context);
              configProvider.toggleTheme();
              await _analytics.logEvent(
                  name: 'toggle_dark_mode',
                  parameters: {'value': configProvider.isDarkMode});
            },
          ),
        ),
        PopupMenuItem(
          enabled: true,
          child: SwitchListTile(
            title: Text("Modo Vanilla",
                style:
                    TextStyle(fontSize: 16, color: configProvider.textColor)),
            secondary: Icon(
                configProvider.hideImages
                    ? Icons.image_not_supported
                    : Icons.image,
                color: configProvider.iconColor),
            value: configProvider.hideImages,
            onChanged: (_) async {
              Navigator.pop(context);
              configProvider.toggleHideImages();
              await _analytics.logEvent(
                  name: 'toggle_hide_images',
                  parameters: {'value': configProvider.hideImages});
            },
          ),
        ),
        PopupMenuItem(
          value: 'logout',
          child: Row(
            children: [
              Icon(Icons.exit_to_app, color: configProvider.iconColor),
              const SizedBox(width: 10),
              Text("Sair",
                  style:
                      TextStyle(fontSize: 16, color: configProvider.textColor)),
            ],
          ),
        ),
      ],
      elevation: 8.0,
    ).then((value) async {
      if (value == 'config') {
        await _analytics.logEvent(name: 'open_profile_edit');
        Navigator.push(context,
            MaterialPageRoute(builder: (context) => const EditUserPage()));
      } else if (value == 'profile_settings') {
        // await _analytics.logEvent(name: 'open_profile_settings');
        // Navigator.push(context,
        //     MaterialPageRoute(builder: (context) => const ConfigProfilePage()));
        _showConfigProfile(context);
      } else if (value == 'create_party') {
        await _analytics.logEvent(name: 'open_create_party');
        Navigator.push(
            context,
            MaterialPageRoute(
                builder: (context) => const CreateEditPartyPage()));
      } else if (value == 'create_place') {
        await _analytics.logEvent(name: 'open_create_place');
        Navigator.push(
            context,
            MaterialPageRoute(
                builder: (context) => const CreateEditPlacePage()));
      } else if (value == 'logout') {
        await _logout(context);
      }
    });
  }

  Future<void> _logout(BuildContext context) async {
    await _analytics.logEvent(name: 'logout');
    Navigator.pushReplacement(
        context, MaterialPageRoute(builder: (context) => const InitialPage()));
  }

  Widget _buildFloatingButton(IconData icon, VoidCallback onPressed) {
    final configProvider = Provider.of<ConfigProvider>(context, listen: false);
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 4),
      child: RawMaterialButton(
        onPressed: onPressed,
        shape: const CircleBorder(),
        constraints: const BoxConstraints(minWidth: 40, minHeight: 40),
        padding: const EdgeInsets.all(8),
        fillColor: Colors.transparent,
        splashColor: Colors.transparent,
        elevation: 0,
        child: Icon(icon, color: configProvider.iconColor, size: 24),
      ),
    );
  }

  @override
  void dispose() {
    _locationService.dispose();
    _timer.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);
    final markersToDisplay = <Marker>[];
    if (_userLocationMarker != null) {
      markersToDisplay.add(_userLocationMarker!);
    }
    markersToDisplay.addAll(_userMarkers.values);
    markersToDisplay.addAll(_partyMarkers.values);
    markersToDisplay.addAll(_placeMarkers.values);
    return Scaffold(
      backgroundColor: configProvider.primaryColor,
      appBar: AppBar(
        backgroundColor: configProvider.primaryColor,
        iconTheme: IconThemeData(color: configProvider.iconColor),
        title: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            configProvider.isDarkMode
                ? Image.asset('assets/images/logo-black.png', height: 30)
                : Image.asset('assets/images/logo-white.png', height: 30),
          ],
        ),
        automaticallyImplyLeading: false,
        leading: IconButton(
          icon:
              Icon(Icons.filter_list_rounded, color: configProvider.iconColor),
          onPressed: () async {
            await _analytics.logEvent(name: 'menu_button_pressed');
          },
        ),
        actions: [
          GestureDetector(
            onTapDown: (TapDownDetails details) {
              _showCustomMenu(context, details.globalPosition);
            },
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              child: Icon(Icons.settings, color: configProvider.iconColor),
            ),
          ),
        ],
      ),
      body: _isLocationLoaded
          ? Stack(
              children: [
                FlutterMap(
                  mapController: _mapController,
                  options: MapOptions(
                    onMapReady: () {
                      Future.delayed(const Duration(milliseconds: 500), () {
                        if (widget.initialLatitude != null &&
                            widget.initialLongitude != null) {
                          _mapController.move(
                            LatLng(widget.initialLatitude!,
                                widget.initialLongitude!),
                            15.0,
                          );
                        }
                      });
                    },
                    initialCenter: LatLng(_currentLocation.latitude!,
                        _currentLocation.longitude!),
                    initialZoom: 15.0,
                    interactionOptions: const InteractionOptions(
                        flags:
                            InteractiveFlag.pinchZoom | InteractiveFlag.drag),
                  ),
                  children: [
                    TileLayer(urlTemplate: _getMapUrl(context)),
                    MarkerLayer(markers: markersToDisplay),
                  ],
                ),
              ],
            )
          : Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Row(mainAxisAlignment: MainAxisAlignment.center, children: [
                    Icon(Icons.location_on, color: configProvider.iconColor),
                    const SizedBox(width: 8),
                    Text('Carregando Conteúdo',
                        style: TextStyle(color: configProvider.textColor)),
                  ]),
                  AnimatedOpacity(
                    duration: const Duration(seconds: 2),
                    opacity: _opacity,
                    child: Image.asset(
                      configProvider.isDarkMode
                          ? 'assets/images/small-logo-black.png'
                          : 'assets/images/small-logo-white.png',
                      width: 30,
                    ),
                  )
                ],
              ),
            ),
      floatingActionButton: Align(
        alignment: Alignment.bottomRight,
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            _buildFloatingButton(Icons.flight, () async {
              await _analytics.logEvent(name: 'flight_button_pressed');
            }),
            _buildFloatingButton(Icons.remove_red_eye, () async {
              await _analytics.logEvent(name: 'eye_button_pressed');
            }),
            _buildFloatingButton(Icons.crop_free, () async {
              await _analytics.logEvent(name: 'crop_button_pressed');
            }),
            _buildFloatingButton(Icons.my_location, () {
              _recenterMap();
            }),
          ],
        ),
      ),
      bottomNavigationBar: BottomNavigationBar(
        backgroundColor: configProvider.primaryColor,
        selectedItemColor: configProvider.iconColor,
        unselectedItemColor: configProvider.iconColor,
        showSelectedLabels: false,
        showUnselectedLabels: false,
        onTap: (index) async {
          if (index == 0) {
            configProvider.setNotificationMessage(false);
            _openPrivateChat(context);
          } else if (index == 1) {
            _openPublicChat(context);
          }
        },
        items: [
          BottomNavigationBarItem(
            icon: Stack(
              clipBehavior: Clip.none,
              children: [
                const Icon(Icons.chat),
                if (configProvider.notificationMessage)
                  Positioned(
                    right: -4,
                    top: -6,
                    child: Container(
                        padding: const EdgeInsets.all(2),
                        decoration: BoxDecoration(
                          color: Colors.red,
                          shape: BoxShape.circle,
                        ),
                        constraints: const BoxConstraints(
                          minWidth: 16,
                          minHeight: 16,
                        )),
                  ),
              ],
            ),
            label: '',
          ),
          const BottomNavigationBarItem(icon: Icon(Icons.group), label: ''),
        ],
      ),
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\public_chat_page.dart ===
import 'dart:convert';
import 'dart:developer';
import 'package:firebase_analytics/firebase_analytics.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/pages/account/buy_subscription_page.dart';
import 'package:snarf/pages/account/view_user_page.dart';
import 'package:snarf/pages/home_page.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/providers/intercepted_image_provider.dart';
import 'package:snarf/services/api_service.dart';
import 'package:snarf/services/location_service.dart';
import 'package:snarf/services/signalr_manager.dart';
import 'package:snarf/utils/date_utils.dart';
import 'package:snarf/utils/distance_utils.dart';
import 'package:snarf/utils/show_snackbar.dart';
import 'package:snarf/enums/signalr_event_type.dart';

class PublicChatPage extends StatefulWidget {
  final ScrollController scrollController;

  const PublicChatPage({super.key, required this.scrollController});

  @override
  _PublicChatPageState createState() => _PublicChatPageState();
}

class _PublicChatPageState extends State<PublicChatPage> {
  final TextEditingController _messageController = TextEditingController();
  final _locationService = LocationService();
  final List<Map<String, dynamic>> _messages = [];
  final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;
  String? _userId;
  bool _isLoading = true;
  double? _myLatitude;
  double? _myLongitude;
  bool _sortByDate = true;

  @override
  void initState() {
    super.initState();

    _analytics.logScreenView(
      screenName: 'PublicChatPage',
      screenClass: 'PublicChatPage',
    );

    _setupSignalRConnection();
  }

  Future<void> _loadUserId() async {
    final userId = await ApiService.getUserIdFromToken();
    setState(() {
      _userId = userId;
    });
  }

  Future<void> _initLocation() async {
    final ok = await _locationService.initialize();
    if (ok) {
      final loc = await _locationService.getCurrentLocation();
      setState(() {
        _myLatitude = loc.latitude;
        _myLongitude = loc.longitude;
      });
      _locationService.onLocationChanged.listen((loc) {
        setState(() {
          _myLatitude = loc.latitude;
          _myLongitude = loc.longitude;
        });
      });

      await _analytics.logEvent(
        name: 'public_chat_location_obtained',
        parameters: {
          'latitude': _myLatitude!,
          'longitude': _myLongitude!,
        },
      );
    }
  }

  Future<void> _setupSignalRConnection() async {
    await _loadUserId();
    await _initLocation();

    SignalRManager().listenToEvent("ReceiveMessage", _onReceiveMessage);
    await SignalRManager()
        .sendSignalRMessage(SignalREventType.PublicChatGetPreviousMessages, {});

    setState(() => _isLoading = false);

    await _analytics.logEvent(
      name: 'public_chat_signalr_initialized',
    );
  }

  void _onReceiveMessage(List<Object?>? args) async {
    if (args == null || args.isEmpty) return;
    try {
      final Map<String, dynamic> message = jsonDecode(args[0] as String);
      final SignalREventType type = SignalREventType.values.firstWhere(
        (e) => e.toString().split('.').last == message['Type'],
      );

      final dynamic data = message['Data'];

      await _analytics.logEvent(
        name: 'public_chat_signalr_message_received',
        parameters: {
          'type': message['Type'],
        },
      );

      switch (type) {
        case SignalREventType.PublicChatReceiveMessage:
          _handleReceiveMessage(data);
          break;
        case SignalREventType.PublicChatReceiveMessageDeleted:
          _handleMessageDeleted(data);
          break;
        default:
          await _analytics.logEvent(
            name: 'public_chat_unrecognized_event',
            parameters: {
              'event_type': message['Type'],
            },
          );
      }
    } catch (e) {
      await _analytics.logEvent(
        name: 'public_chat_process_error',
        parameters: {
          'error': e.toString(),
        },
      );
    }
  }

  void _handleReceiveMessage(Map<String, dynamic> data) {
    setState(() {
      _messages.add({
        'id': data['Id'],
        'createdAt': DateTime.parse(data['CreatedAt']).toLocal(),
        'userName': data['UserName'],
        'message': data['Message'],
        'userImage': data['UserImage'],
        'userId': data['UserId'],
        'isMine': data['UserId'] == _userId,
        'latitude': data['Latitude'],
        'longitude': data['Longitude'],
        'distance': DistanceUtils.calculateDistance(
          _myLatitude!,
          _myLongitude!,
          data['Latitude'],
          data['Longitude'],
        ),
      });
    });
    _scrollToBottom();
  }

  void _handleMessageDeleted(Map<String, dynamic> data) {
    setState(() {
      final index = _messages.indexWhere((m) => m['id'] == data['MessageId']);
      if (index != -1) {
        _messages[index]['message'] = data['Message'];
      }
    });
  }

  void _showSensitiveDataDialog(BuildContext context){
    final configProvider = Provider.of<ConfigProvider>(context, listen: false);

    showDialog(
      context: context,
      builder: (context){
        return AlertDialog(
          backgroundColor: configProvider.primaryColor,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
            side: BorderSide(
              color: configProvider.secondaryColor,
              width: 2,
            )
          ),
          contentPadding: const EdgeInsets.all(16),
          title: Text(
            "⚠️ Dados Sensíveis Detectados",
            textAlign: TextAlign.center,
            style: TextStyle(
              fontWeight: FontWeight.bold,
              fontSize: 18,
              color: configProvider.textColor,
            ),
          ),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                "A mensagem contém dados sensíveis e não pode ser enviada.",
                textAlign: TextAlign.center,
                style: TextStyle(
                  fontSize: 16,
                  color: configProvider.textColor,
                ),
              ),
              const SizedBox(height: 16),
              Row(
                children: [
                  Expanded(
                    child: ElevatedButton.icon(
                      style: ElevatedButton.styleFrom(
                        elevation: 5,
                        backgroundColor: configProvider.secondaryColor,
                        iconColor: configProvider.iconColor,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12),
                        ),
                      ),
                      label: Text(
                        "Entendi",
                        style: TextStyle(
                          color: configProvider.textColor,
                        ),
                      ),
                      onPressed: () {
                        Navigator.pop(context);
                      },
                    ),
                  ),
                ],
              )
            ],
          ),
        );
      });
  }

  Future<bool> _canSendMessage() async {
    final config = Provider.of<ConfigProvider>(context, listen: false);
    DateTime? firstMessageDate = config.firstMessageToday;
    DateTime now = DateTime.now().toUtc();

    if (firstMessageDate == null) {
      return true;
    }

    log("Data primeira mensagem: ${firstMessageDate.toUtc()} Data atual: $now");
    Duration difference = now.difference(firstMessageDate.toUtc());
    log("Diferença em minutos: ${difference.inMinutes}");

    return difference.inMinutes <= 30;
  }

  void _sendMessage() async {
    final config = Provider.of<ConfigProvider>(context, listen: false);
    final messageText = _messageController.text.trim();

    if(_hasSensitiveData(messageText)){
      _showSensitiveDataDialog(context);
      return;
    }

    if (await _canSendMessage() || config.isSubscriber) {
      if (messageText.isNotEmpty) {
        await SignalRManager().sendSignalRMessage(
          SignalREventType.PublicChatSendMessage,
          {"Message": messageText},
        );

        await _analytics.logEvent(
          name: 'public_chat_message_sent',
          parameters: {
            'message_length': messageText.length,
          },
        );

        setState(() => _messageController.clear());
        _scrollToBottom();
      }
    } else {
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => BuySubscriptionPage(),
        ),
      );
    }
  }

  void _deleteMessage(String messageId) async {
    try {
      await SignalRManager().sendSignalRMessage(
        SignalREventType.PublicChatDeleteMessage,
        {"MessageId": messageId},
      );

      await _analytics.logEvent(
        name: 'public_chat_message_deleted',
        parameters: {
          'message_id': messageId,
        },
      );
    } catch (e) {
      showErrorSnackbar(context, "Erro ao excluir a mensagem: $e");

      await _analytics.logEvent(
        name: 'public_chat_delete_message_error',
        parameters: {
          'error': e.toString(),
          'message_id': messageId,
        },
      );
    }
  }

  void _scrollToBottom() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (widget.scrollController.hasClients) {
        widget.scrollController.animateTo(
          widget.scrollController.position.maxScrollExtent,
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeOut,
        );
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);
    final sortedMessages = List<Map<String, dynamic>>.from(_messages);

    if (_sortByDate) {
      sortedMessages.sort((a, b) {
        final dateA = a['createdAt'] as DateTime;
        final dateB = b['createdAt'] as DateTime;
        return dateA.compareTo(dateB);
      });
    } else {
      sortedMessages.sort((a, b) {
        final distA = a['distance'] as double? ?? double.infinity;
        final distB = b['distance'] as double? ?? double.infinity;
        return distB.compareTo(distA);
      });
    }

    return Scaffold(
      backgroundColor: configProvider.primaryColor,
      appBar: AppBar(
        backgroundColor: configProvider.primaryColor,
        iconTheme: IconThemeData(color: configProvider.iconColor),
        title: Text(
          'Feed',
          style: TextStyle(color: configProvider.textColor),
        ),
        automaticallyImplyLeading: false,
        actions: [
          PopupMenuButton<String>(
            color: configProvider.primaryColor,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(12),
              side: BorderSide(
                color: configProvider.secondaryColor,
                width: 2,
              ),
            ),
            icon: Icon(Icons.sort, color: configProvider.iconColor),
            onSelected: (value) async {
              setState(() {
                _sortByDate = (value == 'date');
              });

              await _analytics.logEvent(
                name: 'public_chat_sort_changed',
                parameters: {
                  'sort_by': _sortByDate ? 'date' : 'distance',
                },
              );
            },
            itemBuilder: (context) => [
              PopupMenuItem(
                value: 'date',
                child: Text(
                  'Ordenar por data',
                  style: TextStyle(color: configProvider.textColor),
                ),
              ),
              PopupMenuItem(
                value: 'distance',
                child: Text(
                  'Ordenar por distância',
                  style: TextStyle(color: configProvider.textColor),
                ),
              ),
            ],
          ),
        ],
      ),
      body: _isLoading
          ? Center(
              child: CircularProgressIndicator(
                color: configProvider.iconColor,
              ),
            )
          : Column(
              children: [
                Expanded(
                  child: ListView.builder(
                    controller: widget.scrollController,
                    itemCount: sortedMessages.length,
                    itemBuilder: (context, index) {
                      final msg = sortedMessages[index];
                      final isMine = msg['isMine'] as bool;
                      final createdAt = msg['createdAt'] as DateTime;
                      final distance = msg['distance'] ?? 0.0;

                      return Column(
                        crossAxisAlignment: isMine
                            ? CrossAxisAlignment.end
                            : CrossAxisAlignment.start,
                        children: [
                          Padding(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 12,
                              vertical: 4,
                            ),
                            child: Row(
                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                              children: [
                                Text(
                                  DateJSONUtils.formatRelativeTime(
                                    createdAt.toString(),
                                  ),
                                  style: TextStyle(
                                    fontSize: 10,
                                    fontStyle: FontStyle.italic,
                                    color: configProvider.textColor,
                                  ),
                                ),
                                Text(
                                  !isMine
                                      ? '${distance?.toStringAsFixed(2)} km'
                                      : '',
                                  style: TextStyle(
                                    fontSize: 10,
                                    fontStyle: FontStyle.italic,
                                    color: configProvider.textColor,
                                  ),
                                ),
                              ],
                            ),
                          ),
                          Align(
                            alignment: isMine
                                ? Alignment.centerRight
                                : Alignment.centerLeft,
                            child: _buildMessageWidget(
                              context,
                              message: msg,
                              isMine: isMine,
                              messageColor: configProvider.secondaryColor,
                            ),
                          ),
                        ],
                      );
                    },
                  ),
                ),
                _buildMessageInput(context),
              ],
            ),
    );
  }

  Widget _buildMessageWidget(
    BuildContext context, {
    required Map<String, dynamic> message,
    required bool isMine,
    required Color messageColor,
  }) {
    final configProvider = Provider.of<ConfigProvider>(context, listen: false);

    final msgText = message['message'] as String? ?? '';
    final msgId = message['id'] as String?;
    final userId = message['userId'] as String?;
    final userLatitude = message['latitude'] as double?;
    final userLongitude = message['longitude'] as double?;
    final senderImage = message['userImage'] as String? ?? '';

    if (isMine) {
      return Row(
        mainAxisSize: MainAxisSize.max,
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          Flexible(
            child: Container(
              margin: const EdgeInsets.symmetric(vertical: 4, horizontal: 8),
              padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 12),
              decoration: BoxDecoration(
                color: messageColor,
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(12),
                  topRight: Radius.circular(12),
                  bottomLeft: Radius.circular(12),
                  bottomRight: Radius.zero,
                ),
              ),
              child: Text(
                msgText,
                style: TextStyle(
                  fontSize: 14,
                  color: configProvider.textColor,
                ),
              ),
            ),
          ),
          if (msgText != "Mensagem excluída")
            IconButton(
              icon: Icon(
                Icons.delete,
                size: 18,
                color: configProvider.iconColor,
              ),
              onPressed: () {
                if (msgId != null) {
                  _deleteMessage(msgId);
                }
              },
            ),
        ],
      );
    }

    return Row(
      mainAxisSize: MainAxisSize.max,
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Expanded(
          child: Row(
            mainAxisSize: MainAxisSize.max,
            children: [
              GestureDetector(
                onTap: () {
                  if (userId == null) return;
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (context) => ViewUserPage(userId: userId),
                    ),
                  );
                },
                child: Container(
                  width: 50,
                  height: 50,
                  decoration: BoxDecoration(
                    borderRadius: const BorderRadius.only(
                      topLeft: Radius.circular(30),
                      topRight: Radius.circular(5),
                      bottomLeft: Radius.circular(30),
                      bottomRight: Radius.circular(30),
                    ),
                    image: DecorationImage(
                      image: InterceptedImageProvider(
                        originalProvider: NetworkImage(senderImage),
                        hideImages: configProvider.hideImages,
                      ),
                      fit: BoxFit.cover,
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 8),
              Flexible(
                child: Container(
                  margin:
                      const EdgeInsets.symmetric(vertical: 4, horizontal: 8),
                  padding:
                      const EdgeInsets.symmetric(vertical: 8, horizontal: 12),
                  decoration: BoxDecoration(
                    color: messageColor,
                    borderRadius: const BorderRadius.only(
                      topLeft: Radius.circular(12),
                      topRight: Radius.circular(12),
                      bottomLeft: Radius.zero,
                      bottomRight: Radius.circular(12),
                    ),
                  ),
                  child: Text(
                    msgText,
                    style: TextStyle(
                      fontSize: 14,
                      color: configProvider.textColor,
                    ),
                    softWrap: true,
                    overflow: TextOverflow.ellipsis,
                    maxLines: 3,
                  ),
                ),
              ),
            ],
          ),
        ),
        Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (userLatitude != null && userLongitude != null)
              IconButton(
                icon: Icon(Icons.my_location, color: configProvider.iconColor),
                onPressed: () {
                  _analytics.logEvent(
                    name: 'public_chat_open_map',
                    parameters: {
                      'latitude': userLatitude,
                      'longitude': userLongitude,
                    },
                  );

                  Navigator.of(context).pushAndRemoveUntil(
                    MaterialPageRoute(
                      builder: (context) => HomePage(
                        initialLatitude: userLatitude,
                        initialLongitude: userLongitude,
                      ),
                    ),
                    (Route<dynamic> route) => false,
                  );
                },
              ),
            ChatMessageOptions(
              senderId: userId!,
              messageId: msgId!,
              mainContext: context,
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildMessageInput(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);

    return Container(
      color: configProvider.primaryColor,
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 25),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: _messageController,
              style: TextStyle(color: configProvider.textColor),
              decoration: InputDecoration(
                hintText: "Digite uma atualização",
                hintStyle:
                    TextStyle(color: configProvider.textColor.withOpacity(0.6)),
                fillColor: configProvider.secondaryColor.withOpacity(0.1),
                filled: true,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(30),
                  borderSide: BorderSide(
                    color: configProvider.secondaryColor,
                  ),
                ),
                enabledBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(30),
                  borderSide: BorderSide(
                    color: configProvider.secondaryColor,
                  ),
                ),
              ),
            ),
          ),
          IconButton(
            icon: Icon(Icons.send, color: configProvider.iconColor),
            onPressed: _sendMessage,
            iconSize: 30,
          ),
        ],
      ),
    );
  }

  bool _hasSensitiveData(String message) {

  final regexCpf = RegExp(r'\b\d{3}\.?\d{3}\.?\d{3}-?\d{2}\b|\b\d{11}\b');

  final regexCnpj = RegExp(r'\b\d{2}\.?\d{3}\.?\d{3}/?\d{4}-?\d{2}\b|\b\d{14}\b');

  final regexTelefone = RegExp(r'\b(\(?\d{2}\)?\s?)?9?\d{4}-?\d{4}\b|\b\d{11}\b|\b\d{10}\b');

  final regexEmail = RegExp(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b');

  return regexCpf.hasMatch(message) || 
         regexCnpj.hasMatch(message) || 
         regexTelefone.hasMatch(message) ||
         regexEmail.hasMatch(message);
  }

  @override
  void dispose() {
    _messageController.dispose();
    super.dispose();
  }
}

class ChatMessageOptions extends StatelessWidget {
  final String senderId;
  final String messageId;
  final BuildContext mainContext;

  const ChatMessageOptions({
    required this.senderId,
    required this.messageId,
    required this.mainContext,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context, listen: false);

    return IconButton(
      icon: Icon(Icons.more_horiz, color: configProvider.iconColor),
      onPressed: () => _showBlockReportDialog(context),
    );
  }

  void _showBlockReportDialog(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context, listen: false);

    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          backgroundColor: configProvider.primaryColor,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
            side: BorderSide(
              color: configProvider.secondaryColor,
              width: 2,
            ),
          ),
          contentPadding: const EdgeInsets.all(16),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Row(
                children: [
                  Expanded(
                    child: ElevatedButton.icon(
                      style: ElevatedButton.styleFrom(
                        elevation: 5,
                        backgroundColor: configProvider.secondaryColor,
                        iconColor: configProvider.iconColor,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12),
                        ),
                      ),
                      icon: const Icon(Icons.block),
                      label: Text(
                        "Bloquear Usuário",
                        style: TextStyle(
                          color: configProvider.textColor,
                        ),
                      ),
                      onPressed: () {
                        Navigator.pop(context);
                        _blockUser(mainContext);
                      },
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 12),
              Row(
                children: [
                  Expanded(
                    child: ElevatedButton.icon(
                      style: ElevatedButton.styleFrom(
                        elevation: 5,
                        backgroundColor: configProvider.secondaryColor,
                        iconColor: configProvider.iconColor,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12),
                        ),
                      ),
                      icon: const Icon(Icons.flag),
                      label: Text(
                        "Denunciar Publicação",
                        style: TextStyle(
                          color: configProvider.textColor,
                        ),
                      ),
                      onPressed: () {
                        Navigator.pop(context);
                        _reportMessage(mainContext, messageId);
                      },
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 12),
              TextButton(
                child: Text(
                  "Cancelar",
                  style: TextStyle(
                    color: configProvider.textColor,
                  ),
                ),
                onPressed: () => Navigator.pop(context),
              ),
            ],
          ),
        );
      },
    );
  }

  Future<void> _blockUser(BuildContext context) async {
    await FirebaseAnalytics.instance.logEvent(
      name: 'public_chat_block_user_attempt',
      parameters: {
        'blocked_user_id': senderId,
      },
    );

    final confirm = await showDialog<bool>(
      context: context,
      builder: (BuildContext context) {
        final configProvider = Provider.of<ConfigProvider>(context);
        return AlertDialog(
          backgroundColor: configProvider.primaryColor,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
            side: BorderSide(
              color: configProvider.secondaryColor,
              width: 2,
            ),
          ),
          title: Text(
            'Confirmar Bloqueio',
            style: TextStyle(color: configProvider.textColor),
          ),
          content: Text(
            'Tem certeza de que deseja bloquear este usuário?',
            style: TextStyle(color: configProvider.textColor),
          ),
          actions: <Widget>[
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: Text(
                'Cancelar',
                style: TextStyle(color: configProvider.textColor),
              ),
            ),
            TextButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: Text(
                'Bloquear',
                style: TextStyle(color: configProvider.textColor),
              ),
            ),
          ],
        );
      },
    );

    if (confirm == true) {
      final response = await ApiService.blockUser(senderId);
      if (response == null) {
        showSuccessSnackbar(
          context,
          'Usuário bloqueado com sucesso.',
          color: Colors.green,
        );

        await FirebaseAnalytics.instance.logEvent(
          name: 'public_chat_block_user_success',
          parameters: {
            'blocked_user_id': senderId,
          },
        );
      } else {
        showErrorSnackbar(context, 'Erro ao bloquear usuário: $response');

        await FirebaseAnalytics.instance.logEvent(
          name: 'public_chat_block_user_error',
          parameters: {
            'blocked_user_id': senderId,
            'error': response,
          },
        );
      }
    }
  }

  Future<void> _reportMessage(BuildContext context, String messageId) async {
    await FirebaseAnalytics.instance.logEvent(
      name: 'public_chat_report_message_attempt',
      parameters: {
        'message_id': messageId,
      },
    );

    final confirm = await showDialog<bool>(
      context: context,
      builder: (BuildContext context) {
        final configProvider = Provider.of<ConfigProvider>(context);
        return AlertDialog(
          backgroundColor: configProvider.primaryColor,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
            side: BorderSide(
              color: configProvider.secondaryColor,
              width: 2,
            ),
          ),
          title: Text(
            'Confirmar denúncia',
            style: TextStyle(color: configProvider.textColor),
          ),
          content: Text(
            'Tem certeza de que deseja denunciar esta mensagem?',
            style: TextStyle(color: configProvider.textColor),
          ),
          actions: <Widget>[
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: Text(
                'Cancelar',
                style: TextStyle(color: configProvider.textColor),
              ),
            ),
            TextButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: Text(
                'Denunciar',
                style: TextStyle(color: configProvider.textColor),
              ),
            ),
          ],
        );
      },
    );

    if (confirm == true) {
      final response = await ApiService.reportMessage(messageId);
      if (response == null) {
        showSuccessSnackbar(
          context,
          'Mensagem denunciada com sucesso.',
          color: Colors.green,
        );

        await FirebaseAnalytics.instance.logEvent(
          name: 'public_chat_report_message_success',
          parameters: {
            'message_id': messageId,
          },
        );
      } else {
        showErrorSnackbar(context, 'Erro ao denunciar mensagem: $response');

        await FirebaseAnalytics.instance.logEvent(
          name: 'public_chat_report_message_error',
          parameters: {
            'message_id': messageId,
            'error': response,
          },
        );
      }
    }
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\account\buy_subscription_page.dart ===
import 'dart:async';
import 'dart:developer';
import 'package:firebase_analytics/firebase_analytics.dart';
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:flutter/material.dart';
import 'package:in_app_purchase/in_app_purchase.dart';
import 'package:provider/provider.dart';
import 'package:snarf/components/consumable_purchase_component.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/services/api_service.dart';
import 'package:snarf/utils/api_constants.dart';
import 'package:snarf/utils/subscription_base_plan_details.dart';
import 'package:font_awesome_flutter/font_awesome_flutter.dart';

class BuySubscriptionPage extends StatefulWidget {
  const BuySubscriptionPage({Key? key}) : super(key: key);

  @override
  State<BuySubscriptionPage> createState() => _BuySubscriptionPageState();
}

class _BuySubscriptionPageState extends State<BuySubscriptionPage> {
  final InAppPurchase _inAppPurchase = InAppPurchase.instance;
  late StreamSubscription<List<PurchaseDetails>> _subscription;
  final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;
  bool _isStoreAvailable = false;
  bool _isLoading = true;
  List<ProductDetails> _products = [];
  List<SubscriptionBasePlanDetails> _subscriptionBasePlans = [];
  int _extraVideoCallMinutes = 0;

  final List<Map<String, dynamic>> benefits = [
    {"icon": FontAwesomeIcons.ban, "text": "Desbloquear usuários individuais"},
    {
      "icon": FontAwesomeIcons.solidMessage,
      "text": "Ver quem excluiu uma conversa"
    },
    {"icon": FontAwesomeIcons.googlePlay, "text": "Sem anúncios"},
    {"icon": FontAwesomeIcons.filter, "text": "Perfis de usuários ilimitados"},
    {"icon": FontAwesomeIcons.bullhorn, "text": "Publique uma atualização"},
    {"icon": FontAwesomeIcons.images, "text": "Várias fotos de perfil"},
    {
      "icon": FontAwesomeIcons.thumbtack,
      "text": "Fixar conversas e fixar para mais tarde"
    },
    {"icon": FontAwesomeIcons.eye, "text": "Recibos de leitura"},
    {"icon": FontAwesomeIcons.userGroup, "text": "Criar grupals"},
    {"icon": FontAwesomeIcons.image, "text": "Ocultar fotos do chat"},
    {"icon": FontAwesomeIcons.plane, "text": "Modo viagem"},
    {"icon": FontAwesomeIcons.eyeSlash, "text": "Modo discreto"},
    {"icon": FontAwesomeIcons.mapMarkerAlt, "text": "Adicionar locais"},
    {"icon": FontAwesomeIcons.mask, "text": "Check-ins anônimos"},
    {"icon": FontAwesomeIcons.video, "text": "Chamada de vídeo"},
  ];

  @override
  void initState() {
    super.initState();
    _initialize();
  }

  @override
  void dispose() {
    _subscription.cancel();
    super.dispose();
  }

  Future<void> _initialize() async {
    _analytics.logEvent(name: 'initialize_store');
    final purchaseUpdated = _inAppPurchase.purchaseStream;
    _subscription = purchaseUpdated.listen(_onPurchaseUpdate,
        onDone: () => _subscription.cancel(), onError: (error) {});
    final isAvailable = await _inAppPurchase.isAvailable();
    setState(() {
      _isStoreAvailable = isAvailable;
    });
    if (!isAvailable) {
      _analytics.logEvent(name: 'store_unavailable');
      setState(() {
        _isLoading = false;
      });
      return;
    }
    final idsParaConsultar = <String>{
      ApiConstants.subscriptionId,
      ApiConstants.productId,
    };
    final response = await _inAppPurchase.queryProductDetails(idsParaConsultar);
    if (response.error != null) {
      FirebaseCrashlytics.instance.recordError(response.error, null);
    }
    if (response.notFoundIDs.isNotEmpty) {
      _analytics.logEvent(name: 'product_not_found', parameters: {
        'ids': response.notFoundIDs.join(', '),
      });
    }
    final subscriptionProducts = response.productDetails
        .where((p) => p.id == ApiConstants.subscriptionId)
        .toList();
    final subscriptionBasePlans = subscriptionProducts
        .map((p) => SubscriptionBasePlanDetails(p))
        .toList();
    setState(() {
      _products = response.productDetails;
      _subscriptionBasePlans = subscriptionBasePlans;
    });
    await _retrieveUserInfo();
    setState(() {
      _isLoading = false;
    });
  }

  Future<void> _retrieveUserInfo() async {
    final userId = await ApiService.getUserIdFromToken();
    if (userId != null) {
      final userInfo = await ApiService.getUserInfoById(userId);
      if (userInfo != null && userInfo.containsKey('extraVideoCallMinutes')) {
        setState(() {
          _extraVideoCallMinutes = userInfo['extraVideoCallMinutes'] ?? 0;
        });
      }
    }
  }

  void _onPurchaseUpdate(List<PurchaseDetails> purchaseDetailsList) {
    for (final purchase in purchaseDetailsList) {
      _analytics.logEvent(name: 'purchase_updated', parameters: {
        'product_id': purchase.productID,
        'status': purchase.status.toString(),
      });
      if (purchase.status == PurchaseStatus.purchased ||
          purchase.status == PurchaseStatus.restored) {
        log('Compra/assinatura aprovada: ${purchase.productID}');
        if (purchase.productID == ApiConstants.productId) {
          _handleExtraMinutesPurchase(purchase);
        }
      }
      if (purchase.pendingCompletePurchase) {
        _inAppPurchase.completePurchase(purchase);
      }
    }
  }

  Future<void> _handleExtraMinutesPurchase(PurchaseDetails purchase) async {
    try {
      final purchasedMinutes = 5;
      final result = await ApiService.addExtraMinutes(
        minutes: purchasedMinutes,
        subscriptionId: purchase.productID,
        tokenFromPurchase: purchase.verificationData.serverVerificationData,
      );
      if (result == null) {
        _analytics.logEvent(name: 'extra_minutes_added', parameters: {
          'product_id': purchase.productID,
          'minutes': purchasedMinutes,
        });
        setState(() {
          _extraVideoCallMinutes += purchasedMinutes;
        });
      }
    } catch (e, stackTrace) {
      FirebaseCrashlytics.instance.recordError(e, stackTrace);
    }
  }

  void _buySubscription(SubscriptionBasePlanDetails plan) {
    _analytics.logEvent(name: 'purchase_attempt', parameters: {
      'product_id': plan.productDetails.id,
    });
    final purchaseParam = PurchaseParam(productDetails: plan.productDetails);
    _inAppPurchase.buyNonConsumable(purchaseParam: purchaseParam);
  }

  void _buyConsumable(ProductDetails productDetails) {
    _analytics.logEvent(name: 'purchase_attempt', parameters: {
      'product_id': productDetails.id,
    });
    final purchaseParam = PurchaseParam(productDetails: productDetails);
    _inAppPurchase.buyConsumable(purchaseParam: purchaseParam);
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context, listen: false);

    if (!_isStoreAvailable) {
      return Scaffold(
        appBar: AppBar(title: const Text('Assinaturas e Compras')),
        body: const Center(
          child: Text(
              'A loja não está disponível. Verifique conexão ou configuração.'),
        ),
      );
    }
    if (_isLoading) {
      return Scaffold(
        appBar: AppBar(title: const Text('Assinaturas e Compras')),
        body: const Center(child: CircularProgressIndicator()),
      );
    }
    final consumableProducts =
        _products.where((p) => p.id == ApiConstants.productId).toList();
    return Scaffold(
      appBar: AppBar(
        title: const Text('Snarf Plus e Video Chamada'),
      ),
      body: ListView(
        children: [
          const SizedBox(height: 16),
          const Padding(
            padding: EdgeInsets.symmetric(horizontal: 16),
            child: Text(
              'Assinaturas',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
          ),
          if (_subscriptionBasePlans.isNotEmpty)
            ..._subscriptionBasePlans.map((plan) {
              return Card(
                color: configProvider.secondaryColor,
                margin: const EdgeInsets.all(8),
                child: ListTile(
                  title: Text(
                    'Duração: ${plan.getBasePlanLengthTranslated()}\nTeste grátis: ${plan.isFreeTrialAvailable == true ? 'Sim' : 'Não'}',
                    style: TextStyle(color: configProvider.textColor),
                  ),
                  trailing: Text(
                    plan.formattedPrice,
                    style: TextStyle(color: configProvider.textColor),
                  ),
                  onTap: () => _buySubscription(plan),
                ),
              );
            })
          else
            const Center(
              child: Padding(
                padding: EdgeInsets.all(16),
                child: Text('Nenhuma assinatura encontrada.',
                    style: TextStyle(fontSize: 16)),
              ),
            ),
          Padding(
            padding: EdgeInsets.symmetric(horizontal: 16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  "Aqui está tudo o que você receberá...",
                  style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                ),
                SizedBox(height: 16),
                Column(
                  children: benefits.map((item) {
                    return Padding(
                      padding: const EdgeInsets.symmetric(vertical: 6),
                      child: Row(
                        children: [
                          Icon(item["icon"],
                              size: 20, color: Colors.blueAccent),
                          SizedBox(width: 10),
                          Text(item["text"], style: TextStyle(fontSize: 16)),
                        ],
                      ),
                    );
                  }).toList(),
                ),
              ],
            ),
          ),
          const Divider(height: 32),
          const Padding(
            padding: EdgeInsets.symmetric(horizontal: 16),
            child: Text(
              'Produtos',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
          ),
          ConsumablePurchaseComponent(
            consumableProducts: consumableProducts,
            onBuyConsumable: _buyConsumable,
            purchasedMinutes: _extraVideoCallMinutes,
          ),
        ],
      ),
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\account\config_profile_page.dart ===
import 'package:firebase_analytics/firebase_analytics.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/modals/change_email_modal.dart';
import 'package:snarf/modals/change_password_modal.dart';
import 'package:snarf/pages/account/buy_subscription_page.dart';
import 'package:snarf/pages/account/status_subscription_page.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:dropdown_button2/dropdown_button2.dart';

String selectedOption = 'Opção 1';
List<String> options = ['Opção 1', 'Opção 2', 'Opção 3'];

class ConfigProfilePage extends StatefulWidget {
  const ConfigProfilePage({super.key});

  @override
  State<ConfigProfilePage> createState() => _ConfigProfilePageState();
}

class _ConfigProfilePageState extends State<ConfigProfilePage> {
  final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Configurações de Perfil'),
        backgroundColor: configProvider.primaryColor,
        iconTheme: IconThemeData(color: configProvider.iconColor),
        titleTextStyle: TextStyle(
          color: configProvider.textColor,
          fontSize: 20,
          fontWeight: FontWeight.bold,
        ),
      ),
      backgroundColor: configProvider.primaryColor,
      body: ListView(
        children: [
          _buildSectionTitle("Conta"),
          _buildListTile(
            "Endereço de email",
            Icons.email,
            () {
              showDialog(
                context: context,
                builder: (_) => const ChangeEmailModal(),
              );
            },
          ),
          _buildListTile(
            "Senha",
            Icons.lock,
            () {
              showDialog(
                context: context,
                builder: (_) => const ChangePasswordModal(),
              );
            },
          ),
          _buildListTile("Snarf Plus", Icons.workspace_premium, () {
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) => const StatusSubscriptionPage(),
              ),
            );
          }),
          _buildSectionTitle("Configurações"),
          _buildSwitchTile(
            "Disponível para vídeo chamadas",
            Icons.video_call,
            configProvider.hideVideoCall,
            (bool value) async {
              setState(() {
                configProvider.toggleVideoCall();
              });
              await _analytics.logEvent(
                name: 'toggle_video_call',
                parameters: {'value': configProvider.hideVideoCall},
              );
            },
          ),
          _buildDivider(),
          _buildSectionTitle("Estatísticas"),
          _buildOptionSelector(
            label: "Idade",
            isActive: configProvider.getStatistic(0),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.toggleStatistic(0);
              });
              await _analytics.logEvent(
                name: 'toggle_statistic',
                parameters: {'value': configProvider.getStatistic(0)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildOptionSelector(
            label: "Altura",
            isActive: configProvider.getStatistic(1),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.toggleStatistic(1);
              });
              await _analytics.logEvent(
                name: 'toggle_statistic',
                parameters: {'value': configProvider.getStatistic(1)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildOptionSelector(
            label: "Peso",
            isActive: configProvider.getStatistic(2),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.toggleStatistic(2);
              });
              await _analytics.logEvent(
                name: 'toggle_statistic',
                parameters: {'value': configProvider.getStatistic(2)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildOptionSelector(
            label: "Dotado",
            isActive: configProvider.getStatistic(3),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.toggleStatistic(3);
              });
              await _analytics.logEvent(
                name: 'toggle_statistic',
                parameters: {'value': configProvider.getStatistic(3)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildOptionSelector(
            label: "Tipo de Corpo",
            isActive: configProvider.getStatistic(4),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.toggleStatistic(4);
              });
              await _analytics.logEvent(
                name: 'toggle_statistic',
                parameters: {'value': configProvider.getStatistic(4)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            })
          ),
          _buildSectionTitle("Sexualidade"),
          _buildOptionSelector(
            label: "Espectro",
            isActive: configProvider.getSexuality(0),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.toggleSexuality(0);
              });
              await _analytics.logEvent(
                name: 'toggle_sexuality',
                parameters: {'value': configProvider.getSexuality(0)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildOptionSelector(
            label: "Atitude",
            isActive: configProvider.getSexuality(1),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.toggleSexuality(1);
              });
              await _analytics.logEvent(
                name: 'toggle_sexuality',
                parameters: {'value': configProvider.getSexuality(1)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildOptionSelector(
            label: "Expressão",
            isActive: configProvider.getSexuality(2),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.toggleSexuality(2);
              });
              await _analytics.logEvent(
                name: 'toggle_sexuality',
                parameters: {'value': configProvider.getSexuality(2)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildSectionTitle("Cena"),
          _buildOptionSelector(
            label: "Localização",
            isActive: configProvider.getScene(0),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.toggleScene(0);
              });
              await _analytics.logEvent(
                name: 'toggle_scene',
                parameters: {'value': configProvider.getScene(0)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildOptionSelector(
            label: "Em público",
            isActive: configProvider.getScene(1),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.toggleScene(1);
              });
              await _analytics.logEvent(
                name: 'toggle_scene',
                parameters: {'value': configProvider.getScene(1)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildOptionSelector(
            label: "Procurando",
            isActive: configProvider.getScene(2),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.toggleScene(2);
              });
              await _analytics.logEvent(
                name: 'toggle_scene',
                parameters: {'value': configProvider.getScene(2)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildOptionSelector(
            label: "Fetiches",
            isActive: configProvider.getScene(3),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.toggleScene(3);
              });
              await _analytics.logEvent(
                name: 'toggle_scene',
                parameters: {'value': configProvider.getScene(3)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildOptionSelector(
            label: "Que Gosta",
            isActive: configProvider.getScene(4),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.toggleScene(4);
              });
              await _analytics.logEvent(
                name: 'toggle_scene',
                parameters: {'value': configProvider.getScene(4)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildOptionSelector(
            label: "Interação",
            isActive: configProvider.getScene(5),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.toggleScene(5);
              });
              await _analytics.logEvent(
                name: 'toggle_scene',
                parameters: {'value': configProvider.getScene(5)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildSectionTitle("Práticas e Preferências de Saúde"),
          _buildOptionSelector(
            label: "Práticas",
            isActive: configProvider.getPreferences(0),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.togglePreferences(0);
              });
              await _analytics.logEvent(
                name: 'toggle_preferences',
                parameters: {'value': configProvider.getPreferences(0)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildOptionSelector(
            label: "Status do HIV",
            isActive: configProvider.getPreferences(1),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.togglePreferences(1);
              });
              await _analytics.logEvent(
                name: 'toggle_preferences',
                parameters: {'value': configProvider.getPreferences(1)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildOptionSelector(
            label: "Testado para HIV",
            isActive: configProvider.getPreferences(2),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.togglePreferences(2);
              });
              await _analytics.logEvent(
                name: 'toggle_preferences',
                parameters: {'value': configProvider.getPreferences(2)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildOptionSelector(
            label: "Testado para ISTs",
            isActive: configProvider.getPreferences(3),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.togglePreferences(3);
              });
              await _analytics.logEvent(
                name: 'toggle_preferences',
                parameters: {'value': configProvider.getPreferences(3)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildOptionSelector(
            label: "Salvaguardas",
            isActive: configProvider.getPreferences(4),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.togglePreferences(4);
              });
              await _analytics.logEvent(
                name: 'toggle_preferences',
                parameters: {'value': configProvider.getPreferences(4)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildOptionSelector(
            label: "Meus Níveis de Conforto",
            isActive: configProvider.getPreferences(5),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.togglePreferences(5);
              });
              await _analytics.logEvent(
                name: 'toggle_preferences',
                parameters: {'value': configProvider.getPreferences(5)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
          _buildOptionSelector(
            label: "Eu levo...",
            isActive: configProvider.getPreferences(6),
            options: options,
            selectedOption: selectedOption,
            onToggle: (bool value) async {
              setState(() {
                configProvider.togglePreferences(6);
              });
              await _analytics.logEvent(
                name: 'toggle_preferences',
                parameters: {'value': configProvider.getPreferences(6)},
              );
            },
            onOptionChanged: (val) => setState(() {
              if(val != null) selectedOption = val;
            }) 
          ),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(String title) {
    final configProvider = Provider.of<ConfigProvider>(context);

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
      color: configProvider.secondaryColor,
      child: Text(
        title,
        style: const TextStyle(
          fontSize: 16,
          fontWeight: FontWeight.bold,
          color: Colors.white,
        ),
      ),
    );
  }

  Widget _buildListTile(String title, IconData icon, VoidCallback onTap) {
    final configProvider = Provider.of<ConfigProvider>(context);

    return Column(
      children: [
        ListTile(
          leading: Icon(icon, color: configProvider.iconColor),
          title: Text(
            title,
            style: TextStyle(fontSize: 16, color: configProvider.iconColor),
          ),
          trailing: Icon(Icons.chevron_right, color: configProvider.iconColor),
          onTap: onTap,
        ),
        _buildDivider(),
      ],
    );
  }

  Widget _buildOptionSelector({
  required String label,
  required List<String> options,
  required String selectedOption,
  required ValueChanged<String?> onOptionChanged,
  required bool isActive,
  required ValueChanged<bool> onToggle,
  Color? textColor,
  Color? dropdownColor,
}) {
  final configProvider = Provider.of<ConfigProvider>(context);
  final effectiveTextColor = textColor ?? configProvider.iconColor;

  return Padding(
    padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8),
    child: Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(label, style: TextStyle(color: effectiveTextColor, fontSize: 16)),
        Row(
          children: [
            SizedBox(
              width: 160,
              child: DropdownButton2<String>(
                isExpanded: true,
                value: selectedOption,
                onChanged: onOptionChanged,
                items: options.map((String value) {
                  return DropdownMenuItem<String>(
                    value: value,
                    child: Text(value, style: const TextStyle(color: Colors.white)),
                  );
                }).toList(),
                buttonStyleData: const ButtonStyleData(
                  height: 36,
                  padding: EdgeInsets.symmetric(horizontal: 12),
                ),
                dropdownStyleData: DropdownStyleData(
                  maxHeight: 200,
                  offset: const Offset(0, 0),
                  decoration: BoxDecoration(
                    color: Colors.black87,
                    borderRadius: BorderRadius.circular(8),
                  ),
                  isOverButton: true,
                ),
                iconStyleData: const IconStyleData(
                  icon: Icon(Icons.arrow_drop_down, color: Colors.blue),
                ),
                style: const TextStyle(color: Colors.blue),
                underline: const SizedBox.shrink(),
              ),
            ),
            const SizedBox(width: 8),
            Switch(
              value: isActive,
              onChanged: onToggle,
            ),
          ],
        ),
      ],
    ),
  );
}




  Widget _buildSwitchTile(
    String title,
    IconData icon,
    bool value,
    ValueChanged<bool> onChanged,
  ) {
    final configProvider = Provider.of<ConfigProvider>(context);

    return SwitchListTile(
      title: Text(
        title,
        style: TextStyle(fontSize: 16, color: configProvider.iconColor),
      ),
      secondary: Icon(icon, color: configProvider.iconColor),
      value: value,
      onChanged: onChanged,
    );
  }

  Widget _buildDivider() {
    final configProvider = Provider.of<ConfigProvider>(context);
    return Divider(
      height: 1,
      thickness: 1,
      color: configProvider.secondaryColor,
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\account\config_profile_preferences_page.dart ===
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/providers/config_provider.dart';

class ConfigProfilePreferencesPage extends StatefulWidget {
  const ConfigProfilePreferencesPage({super.key});

  @override
  State<ConfigProfilePreferencesPage> createState() => _ConfigProfilePreferencesPage();
}

class _ConfigProfilePreferencesPage extends State<ConfigProfilePreferencesPage> {
  final ScrollController _scrollController = ScrollController();
  double _scrollOffset = 0.0;

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(() {
      setState(() {
        _scrollOffset = _scrollController.offset;
      });
    });
  }

  double get _opacity {
    const double startFade = 0;
    const double endFade = 300;
    if (_scrollOffset <= startFade) return 1.0;
    if (_scrollOffset >= endFade) return 0.0;
    return 1.0 - ((_scrollOffset - startFade) / (endFade - startFade));
  }

  @override
  Widget build(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;

    return Scaffold(
      backgroundColor: const Color(0xFF0A0F1C),
      body: Stack(
        children: [
          Positioned.fill(
            child: Opacity(
              opacity: _opacity,
              child: Image.asset(
                'assets/photo1.png',
                fit: BoxFit.contain,
              ),
            ),
          ),

          // Conteúdo com scroll
          NotificationListener<ScrollNotification>(
            onNotification: (notification) {
              if (notification is ScrollUpdateNotification) {
                setState(() {
                  _scrollOffset = _scrollController.offset;
                });
              }
              return false;
            },
            child: SingleChildScrollView(
              controller: _scrollController,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(height: screenHeight * 0.81),

                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const Row(
                          children: [
                            Icon(Icons.straighten, color: Colors.white, size: 16),
                            SizedBox(width: 8),
                            Flexible(
                              child: Text(
                                '18, 132cm, 40kg, hétero-curioso, passivo submisso',
                                style: TextStyle(color: Colors.white),
                                overflow: TextOverflow.ellipsis,
                                maxLines: 2,
                                ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 12),
                        Row(
                          children: [
                            Icon(Icons.person_pin_circle_outlined, color: Colors.white, size: 16),
                            SizedBox(width: 8),
                            Flexible(
                              child: Text(
                                'Tenho um buraco de glória',
                                style: TextStyle(color: Colors.white),
                                overflow: TextOverflow.ellipsis, 
                                maxLines: 1,  
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 16),
                        _infoSection('Localização', ['Com local']),
                        const SizedBox(height: 12),
                        _infoSection('Interação', ['Anônimo', 'Gozar e ir', 'Edging']),
                        const SizedBox(height: 12),
                        _infoSection('Status do HIV', ['Negativo']),
                        const SizedBox(height: 12),
                        _infoSection('Testado para HIV', ['May 5, 2025']),
                        const SizedBox(height: 100),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),

          
          Positioned(
            top: kToolbarHeight + 56,
            right: 16,
            child: Opacity(
              opacity: _opacity,
              child: Column(
                children: List.generate(4, (index) {
                  return ProfileAvatarWidget(
                    imagePath: 'assets/photo${index + 1}.png',
                    onRemove: () {
                      
                    },
                    onUpdate: () {
                      
                    },
                  );
                }),
              ),
            ),
          ),

          // TopBar fixa
          Positioned(
            top: 0,
            left: 0,
            right: 0,
            child: Container(
              height: kToolbarHeight + 24,
              padding: const EdgeInsets.only(top: 24, left: 8, right: 8),
              color: const Color(0xFF0A0F1C),
              child: Row(
                children: [
                  const Icon(Icons.arrow_back, color: Colors.white),
                  const SizedBox(width: 8),
                  const Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text('Cruiser Verificado', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
                        Flexible(
                          child: Text(
                            '18, 132cm, 40kg, hétero-curioso, passivo submisso',
                             style: TextStyle(color: Colors.white70, fontSize: 12),
                             overflow: TextOverflow.ellipsis,
                             maxLines: 1),
                        ),
                      ],
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.edit, color: Colors.white),
                    onPressed: () {},
                  ),
                  IconButton(
                    icon: const Icon(Icons.settings, color: Colors.white),
                    onPressed: () {},
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _infoSection(String title, List<String> values) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(title, style: const TextStyle(color: Colors.white70)),
        const SizedBox(height: 4),
        Wrap(
          spacing: 8,
          children: values
              .map((v) => Container(
                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(20),
                      border: Border.all(color: Colors.white24),
                    ),
                    child: Text(v, style: const TextStyle(color: Colors.white)),
                  ))
              .toList(),
        )
      ],
    );
  }
}

class ProfileAvatarWidget extends StatelessWidget {
  final String imagePath;
  final VoidCallback onRemove;
  final VoidCallback onUpdate;

  const ProfileAvatarWidget({
    super.key,
    required this.imagePath,
    required this.onRemove,
    required this.onUpdate,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 80,
      height: 80,
      margin: const EdgeInsets.symmetric(vertical: 10),
      child: Stack(
        clipBehavior: Clip.none,
        children: [
          Container(
            width: 80,
            height: 80,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: const Color(0xFF111827),
              image: DecorationImage(
                image: AssetImage(imagePath),
                fit: BoxFit.cover,
              ),
            ),
          ),
          Positioned(
            bottom: -4,
            left: -4,
            child: Container(
              padding: const EdgeInsets.all(2),
              decoration: const BoxDecoration(
                shape: BoxShape.circle,
                color: Color(0xFF8AE360),
              ),
              child: const Icon(Icons.check, size: 15, color: Colors.black),
            ),
          ),
          Positioned(
            bottom: -4,
            right: -4,
            child: GestureDetector(
              onTap: onRemove,
              child: Container(
                padding: const EdgeInsets.all(2),
                decoration: const BoxDecoration(
                  shape: BoxShape.circle,
                  color: Color(0xFF0A0F1C),
                ),
                child: const Icon(Icons.remove, size: 15, color: Colors.white),
              ),
            ),
          ),
          Positioned(
            top: -4,
            right: -4,
            child: GestureDetector(
              onTap: onUpdate,
              child: Container(
                padding: const EdgeInsets.all(2),
                decoration: const BoxDecoration(
                  shape: BoxShape.circle,
                  color: Color(0xFF0A0F1C),
                ),
                child: const Icon(Icons.refresh, size: 15, color: Colors.white),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\account\edit_user_page.dart ===
import 'dart:convert';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart' show rootBundle;
import 'package:flutter_image_compress/flutter_image_compress.dart';
import 'package:image_picker/image_picker.dart';
import 'package:provider/provider.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/providers/intercepted_image_provider.dart';
import 'package:snarf/services/api_service.dart';
import 'package:snarf/utils/show_snackbar.dart';
import 'package:firebase_analytics/firebase_analytics.dart';

class EditUserPage extends StatefulWidget {
  const EditUserPage({super.key});

  @override
  _EditUserPageState createState() => _EditUserPageState();
}

class _EditUserPageState extends State<EditUserPage> {
  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _emailController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();
  final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;
  String? _userId;
  String? _userImageUrl;
  int favoritedByCount = 0;
  int blockedByCount = 0;
  bool _isLoading = true;
  File? _pickedFile;
  final String _defaultImagePath = 'assets/images/user_anonymous.png';
  List<dynamic> _blockedUsers = [];

  @override
  void initState() {
    super.initState();
    _analytics.logScreenView(
        screenName: 'EditUserPage', screenClass: 'EditUserPage');
    _loadUserInfo();
  }

  Future<void> _pickImage() async {
    final picker = ImagePicker();
    final pickedFile = await picker.pickImage(source: ImageSource.gallery);
    if (pickedFile != null) {
      setState(() {
        _pickedFile = File(pickedFile.path);
        _userImageUrl = null;
      });
      await _analytics.logEvent(name: 'edit_user_pick_image');
    }
  }

  Future<void> _loadUserInfo() async {
    final userId = await ApiService.getUserIdFromToken();
    final userInfo = await ApiService.getUserInfoById(userId!);
    if (userInfo != null) {
      setState(() {
        _nameController.text = userInfo['name'];
        _emailController.text = userInfo['email'];
        _userId = userInfo['id'];
        _userImageUrl = userInfo['imageUrl'];
        _blockedUsers = userInfo['blockedUsers'] ?? [];
        blockedByCount = userInfo['blockedBy'] ?? 0;
        favoritedByCount = userInfo['favoritedBy'] ?? 0;
        _isLoading = false;
      });
      await _analytics.logEvent(name: 'edit_user_info_loaded');
    } else {
      showErrorSnackbar(context, 'Erro ao carregar informações do usuário');
      await _analytics.logEvent(name: 'edit_user_info_error');
    }
  }

  Future<String?> _getBase64Image() async {
    if (_pickedFile != null) {
      final compressedImage = await FlutterImageCompress.compressWithFile(
          _pickedFile!.absolute.path,
          quality: 50);
      if (compressedImage == null) return null;
      return base64Encode(compressedImage);
    } else {
      final byteData = await rootBundle.load(_defaultImagePath);
      final imageBytes = byteData.buffer.asUint8List();
      final compressedBytes =
          await FlutterImageCompress.compressWithList(imageBytes, quality: 50);
      return base64Encode(compressedBytes);
    }
  }

  Future<void> _saveChanges() async {
    if (_userId == null) return;
    final base64Image = await _getBase64Image();
    if (base64Image == null) {
      showErrorSnackbar(context, 'Não foi possível gerar a imagem em Base64');
      await _analytics.logEvent(
          name: 'edit_user_save_error', parameters: {'message': 'image_null'});
      return;
    }
    final result = await ApiService.editUser(
      _userId!,
      _nameController.text,
      _emailController.text,
      _passwordController.text.isEmpty ? null : _passwordController.text,
      base64Image,
    );
    if (result == null) {
      showSuccessSnackbar(context, 'Usuário atualizado com sucesso',
          color: Colors.green);
      await _analytics.logEvent(name: 'edit_user_save_success');
      Navigator.of(context).pop();
    } else {
      showErrorSnackbar(context, result);
      await _analytics.logEvent(
          name: 'edit_user_save_error', parameters: {'message': result});
    }
  }

  void _deleteImage() async {
    setState(() {
      _pickedFile = null;
      _userImageUrl = null;
    });
    await _analytics.logEvent(name: 'edit_user_delete_image');
  }

  Future<void> _deleteAccount() async {
    if (_userId == null) return;
    await _analytics.logEvent(name: 'edit_user_delete_account_attempt');
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Confirmar Exclusão'),
          content: const Text(
              'Tem certeza de que deseja excluir sua conta? Esta ação não pode ser desfeita.'),
          actions: [
            TextButton(
                onPressed: () => Navigator.of(context).pop(false),
                child: const Text('Cancelar')),
            TextButton(
                onPressed: () => Navigator.of(context).pop(true),
                child: const Text('Excluir')),
          ],
        );
      },
    );
    if (confirm == true) {
      await _analytics.logEvent(name: 'edit_user_delete_account_confirmed');
      final result = await ApiService.deleteUser(_userId!);
      if (result == null) {
        showSuccessSnackbar(context, 'Usuário deletado com sucesso');
        await _analytics.logEvent(name: 'edit_user_delete_account_success');
        Navigator.pop(context);
      } else {
        showErrorSnackbar(context, result);
        await _analytics.logEvent(
            name: 'edit_user_delete_account_error',
            parameters: {'message': result});
      }
    }
  }

  Future<void> _unblockUser(String blockedUserId) async {
    await _analytics.logEvent(name: 'edit_user_unblock_user_attempt');
    final confirm = await showDialog<bool>(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Confirmar Desbloqueio'),
          content:
              const Text('Tem certeza de que deseja desbloquear este usuário?'),
          actions: <Widget>[
            TextButton(
                onPressed: () => Navigator.of(context).pop(false),
                child: const Text('Cancelar')),
            TextButton(
                onPressed: () => Navigator.of(context).pop(true),
                child: const Text('Desbloquear')),
          ],
        );
      },
    );
    if (confirm == true) {
      await _analytics.logEvent(name: 'edit_user_unblock_user_confirmed');
      final result = await ApiService.unblockUser(blockedUserId);
      if (result == null) {
        showSuccessSnackbar(context, 'Usuário desbloqueado com sucesso',
            color: Colors.green);
        await _analytics.logEvent(name: 'edit_user_unblock_user_success');
        _loadUserInfo();
      } else {
        showErrorSnackbar(context, result);
        await _analytics.logEvent(
            name: 'edit_user_unblock_user_error',
            parameters: {'message': result});
      }
    }
  }

  Widget _buildUserImage() {
    return Container(
      width: 120,
      height: 120,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: Border.all(color: Colors.grey.shade300, width: 2),
        image: (_pickedFile != null)
            ? DecorationImage(image: FileImage(_pickedFile!), fit: BoxFit.cover)
            : (_userImageUrl != null)
                ? DecorationImage(
                    image: InterceptedImageProvider(
                        originalProvider: NetworkImage(_userImageUrl!),
                        hideImages: false),
                    fit: BoxFit.cover,
                  )
                : const DecorationImage(
                    image: AssetImage('assets/images/user_anonymous.png'),
                    fit: BoxFit.cover),
      ),
    );
  }

  Widget _buildUserList(String title, List<dynamic> users) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(title,
            style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
        const SizedBox(height: 10),
        ListView.builder(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          itemCount: users.length,
          itemBuilder: (context, index) {
            final user = users[index];
            return ListTile(
              leading: CircleAvatar(
                backgroundImage: (user['imageUrl'] != null)
                    ? InterceptedImageProvider(
                        originalProvider: NetworkImage(user['imageUrl']),
                        hideImages: false)
                    : const AssetImage('assets/images/user_anonymous.png')
                        as ImageProvider,
              ),
              title: Text(user['name'] ?? 'Usuário'),
              trailing: IconButton(
                icon: const Icon(Icons.lock_open, color: Colors.green),
                onPressed: () => _unblockUser(user['id']),
              ),
            );
          },
        ),
        const SizedBox(height: 20),
      ],
    );
  }

  Widget _buildCounters() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: [
        Column(
          children: [
            const Text('Favoritado por'),
            Text('$favoritedByCount',
                style: const TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: Colors.green)),
          ],
        ),
        Column(
          children: [
            const Text('Bloqueado por'),
            Text('$blockedByCount',
                style: const TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: Colors.red)),
          ],
        ),
      ],
    );
  }

  Widget _buildActionButtons() {
    final configProvider = Provider.of<ConfigProvider>(context);
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: [
        ElevatedButton.icon(
          onPressed: _pickImage,
          style: ElevatedButton.styleFrom(
              backgroundColor: configProvider.secondaryColor),
          icon: Icon(Icons.photo_camera, color: configProvider.iconColor),
          label:
              Text('Upload', style: TextStyle(color: configProvider.textColor)),
        ),
        ElevatedButton.icon(
          onPressed: _saveChanges,
          style: ElevatedButton.styleFrom(
              backgroundColor: configProvider.secondaryColor),
          icon: Icon(Icons.save, color: configProvider.iconColor),
          label:
              Text('Salvar', style: TextStyle(color: configProvider.textColor)),
        ),
        ElevatedButton.icon(
          onPressed: _deleteAccount,
          style: ElevatedButton.styleFrom(
              backgroundColor: configProvider.secondaryColor),
          icon: Icon(Icons.delete_forever, color: configProvider.iconColor),
          label: Text('Excluir',
              style: TextStyle(color: configProvider.textColor)),
        ),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);
    return Scaffold(
      appBar: AppBar(
          title: const Text('Editar Usuário'),
          backgroundColor: configProvider.primaryColor),
      backgroundColor: configProvider.primaryColor,
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : Padding(
              padding: const EdgeInsets.all(16.0),
              child: SingleChildScrollView(
                child: Column(
                  children: [
                    _buildUserImage(),
                    const SizedBox(height: 10),
                    if (_pickedFile != null || _userImageUrl != null)
                      TextButton.icon(
                        onPressed: _deleteImage,
                        icon:
                            Icon(Icons.delete, color: configProvider.iconColor),
                        style: ElevatedButton.styleFrom(
                            backgroundColor: configProvider.secondaryColor),
                        label: Text('Remover Foto',
                            style: TextStyle(color: configProvider.textColor)),
                      ),
                    const SizedBox(height: 20),
                    _buildCounters(),
                    const SizedBox(height: 20),
                    TextField(
                      controller: _emailController,
                      decoration: InputDecoration(
                        labelText: 'E-mail',
                        border: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(8)),
                      ),
                      enabled: false,
                    ),
                    const SizedBox(height: 15),
                    TextField(
                      controller: _nameController,
                      decoration: InputDecoration(
                        labelText: 'Nome',
                        border: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(8)),
                      ),
                    ),
                    const SizedBox(height: 15),
                    TextField(
                      controller: _passwordController,
                      decoration: InputDecoration(
                        labelText: 'Senha (opcional)',
                        border: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(8)),
                      ),
                      obscureText: true,
                    ),
                    const SizedBox(height: 20),
                    _buildActionButtons(),
                    const SizedBox(height: 30),
                    _buildUserList('Usuários Bloqueados', _blockedUsers),
                  ],
                ),
              ),
            ),
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\account\initial_page.dart ===
import 'dart:convert';
import 'dart:io';
import 'package:carousel_slider/carousel_slider.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_image_compress/flutter_image_compress.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:path_provider/path_provider.dart';
import 'package:provider/provider.dart';
import 'package:snarf/components/custom_modal.dart';
import 'package:snarf/components/loading_elevated_button.dart';
import 'package:snarf/components/loading_outlined_button.dart';
import 'package:snarf/modals/forgot_password_modal.dart';
import 'package:snarf/modals/login_modal.dart';
import 'package:snarf/pages/home_page.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/services/api_service.dart';
import 'package:snarf/services/signalr_manager.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:uuid/uuid.dart';
import 'package:firebase_analytics/firebase_analytics.dart';

class InitialPage extends StatefulWidget {
  const InitialPage({super.key});

  @override
  State<InitialPage> createState() => _InitialPageState();
}

class _InitialPageState extends State<InitialPage> {
  static const _secureStorage = FlutterSecureStorage();
  bool _isLoading = false;

  final String _defaultImagePath = 'assets/images/user_anonymous.png';
  final _imagePaths = <String>[
    'assets/images/snarf-bg001.jpg',
    'assets/images/snarf-bg002.jpg',
    'assets/images/snarf-bg003.jpg'
  ];

  final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;

  @override
  void initState() {
    super.initState();

    _analytics.logScreenView(
      screenName: 'InitialPage',
      screenClass: 'InitialPage',
    );

    _performLogout();
    _shuffleImages();
  }

  void _performLogout() async {
    await _analytics.logEvent(name: 'perform_logout');

    await ApiService.logout();
    await SignalRManager().stopConnection();
    Provider.of<ConfigProvider>(context, listen: false).setDarkTheme();
  }

  void _shuffleImages() {
    _analytics.logEvent(name: 'shuffle_background_images');
    _imagePaths.shuffle();
  }

  Future<int?> _showAgeConfirmationDialog(BuildContext context) async {
    await _analytics.logEvent(name: 'show_age_confirmation_dialog');
    return showDialog(
      context: context,
      builder: (context) => const AgeConfirmationDialog(),
    );
  }

  Future<void> _createAnonymousAccount(BuildContext context) async {
    await _analytics.logEvent(name: 'attempt_anonymous_registration');

    final birthYear = await _showAgeConfirmationDialog(context);
    if (birthYear == null) return;

    final currentYear = DateTime.now().year;
    final isAdult = (currentYear - birthYear) >= 18;

    await _analytics.logEvent(
      name: 'age_confirmation_result',
      parameters: {'birth_year': birthYear, 'is_adult': isAdult.toString()},
    );

    if (!isAdult) {
      return;
    }

    String uniqueId = const Uuid().v4();
    String email = '$uniqueId@anonimo.com';
    String name = 'anon_$uniqueId';

    setState(() {
      _isLoading = true;
    });

    try {
      final pickedFile = await getAssetFile(_defaultImagePath);
      String base64Image = '';
      final compressedImage = await FlutterImageCompress.compressWithFile(
        pickedFile.absolute.path,
        quality: 50,
      );

      if (compressedImage != null) {
        base64Image = base64Encode(compressedImage);
      }

      final errorMessage =
          await ApiService.register(email, name, 'Senha@123', base64Image);
      if (errorMessage == null) {
        final loginResponse = await ApiService.login(email, 'Senha@123');
        await _secureStorage.write(key: 'email', value: email);
        await _secureStorage.write(key: 'password', value: 'Senha@123');
        if (loginResponse == null) {
          await _analytics.logEvent(name: 'anonymous_registration_success');
          if (mounted) {
            Navigator.pushReplacement(
              context,
              MaterialPageRoute(builder: (context) => const HomePage()),
            );
          }
        } else {
          await _analytics.logEvent(
            name: 'anonymous_registration_login_error',
            parameters: {'error': loginResponse},
          );
          _showErrorDialog(context, 'Erro ao criar conta anônima');
        }
      } else {
        await _analytics.logEvent(
          name: 'anonymous_registration_error',
          parameters: {'error': errorMessage},
        );
        _showErrorDialog(context, 'Erro ao registrar conta: $errorMessage');
      }
    } catch (e) {
      await _analytics.logEvent(
        name: 'anonymous_registration_exception',
        parameters: {'exception': e.toString()},
      );
      _showErrorDialog(context, 'Erro: $e');
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  Future<File> getAssetFile(String assetPath) async {
    final byteData = await rootBundle.load(assetPath);
    final tempDir = await getTemporaryDirectory();
    final tempFilePath = '${tempDir.path}/user_anonymous.png';
    final file = File(tempFilePath);
    await file.writeAsBytes(byteData.buffer.asUint8List());
    return file;
  }

  void _showLoginModal(BuildContext context) async {
    await _analytics.logEvent(name: 'show_login_modal');

    showDialog(
      context: context,
      barrierColor: Colors.black.withOpacity(0.5),
      builder: (context) => LoginModal(onLoginSuccess: () {
        Navigator.pushReplacement(
          context,
          MaterialPageRoute(builder: (context) => const HomePage()),
        );
      }),
    );
  }

  void _showErrorDialog(BuildContext context, String message) {
    showDialog(
      context: context,
      builder: (context) => CustomModal(
        title: 'Erro',
        content: Text(
          message,
          style: const TextStyle(
            fontSize: 16.0,
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text(
              'Fechar',
              style: TextStyle(
                color: Color(0xFF0b0951),
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Stack(
        children: [
          BackgroundCarousel(imagePaths: _imagePaths),
          Center(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Image.asset(
                    'assets/images/logo-black.png',
                    height: 50,
                  ),
                  const SizedBox(height: 48),
                  FractionallySizedBox(
                    widthFactor: 0.50,
                    child: LoadingElevatedButton(
                      text: 'Espiar Anonimamente',
                      isLoading: _isLoading,
                      onPressed: () => _createAnonymousAccount(context),
                    ),
                  ),
                  const SizedBox(height: 10),
                  const Text(
                    'Ou',
                    style: TextStyle(
                      fontSize: 20,
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 10),
                  FractionallySizedBox(
                    widthFactor: 0.30,
                    child: LoadingElevatedButton(
                      text: 'Login',
                      isLoading: false,
                      onPressed: () => _showLoginModal(context),
                    ),
                  ),
                ],
              ),
            ),
          ),
          const Positioned(
            bottom: 30,
            left: 15,
            right: 15,
            child: TermsFooter(),
          ),
        ],
      ),
    );
  }
}

class BackgroundCarousel extends StatelessWidget {
  final List<String> imagePaths;

  const BackgroundCarousel({super.key, required this.imagePaths});

  @override
  Widget build(BuildContext context) {
    return IgnorePointer(
      child: CarouselSlider(
        options: CarouselOptions(
          height: double.infinity,
          autoPlay: true,
          autoPlayInterval: const Duration(minutes: 5),
          viewportFraction: 1.0,
          enlargeCenterPage: false,
        ),
        items: imagePaths.map((path) {
          return Image.asset(
            path,
            fit: BoxFit.cover,
            width: double.infinity,
          );
        }).toList(),
      ),
    );
  }
}

class TermsFooter extends StatelessWidget {
  const TermsFooter({super.key});

  void _openUrl(String url) async {
    final Uri uri = Uri.parse(url);
    if (await canLaunchUrl(uri)) {
      await launchUrl(uri, mode: LaunchMode.externalApplication);
    } else {
      debugPrint('Não foi possível abrir a URL: $url');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        const Text(
          'Você deve ser maior de 18 anos para usar este aplicativo.',
          style: TextStyle(
            color: Colors.white,
            fontSize: 14,
          ),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 8),
        Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            GestureDetector(
              onTap: () =>
                  _openUrl('https://snarf.inovitech.inf.br/service.html'),
              child: const Text(
                'Termos de Serviço',
                style: TextStyle(
                  color: Colors.blue,
                  decoration: TextDecoration.underline,
                ),
              ),
            ),
            const Text(
              ' e ',
              style: TextStyle(
                color: Colors.white,
              ),
            ),
            GestureDetector(
              onTap: () =>
                  _openUrl('https://snarf.inovitech.inf.br/privacy.html'),
              child: const Text(
                'Política de Privacidade',
                style: TextStyle(
                  color: Colors.blue,
                  decoration: TextDecoration.underline,
                ),
              ),
            ),
          ],
        ),
      ],
    );
  }
}

class AgeConfirmationDialog extends StatefulWidget {
  const AgeConfirmationDialog({super.key});

  @override
  State<AgeConfirmationDialog> createState() => _AgeConfirmationDialogState();
}

class _AgeConfirmationDialogState extends State<AgeConfirmationDialog> {
  late int selectedYear;
  final int currentYear = DateTime.now().year;
  final int minYear = DateTime.now().year - 100;
  final int birthYear = DateTime.now().year - 18;

  @override
  void initState() {
    super.initState();
    selectedYear = birthYear;
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);

    return CustomModal(
      title: 'Confirmar Idade',
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            'Snarf é um app exclusivo para maiores de idade.\n'
            'Precisamos verificar a sua idade.',
            textAlign: TextAlign.center,
            style: TextStyle(
              color: configProvider.textColor,
              fontSize: 14.0,
            ),
          ),
          const SizedBox(height: 20.0),
          Text(
            'Quando Você Nasceu?',
            style: TextStyle(
              color: configProvider.textColor,
              fontSize: 16.0,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 20.0),
          Container(
            decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(30.0),
                color: configProvider.secondaryColor),
            child: SizedBox(
              height: 100.0,
              child: ListWheelScrollView.useDelegate(
                controller: FixedExtentScrollController(
                  initialItem: currentYear - selectedYear,
                ),
                itemExtent: 25.0,
                perspective: 0.003,
                physics: const FixedExtentScrollPhysics(),
                onSelectedItemChanged: (index) {
                  setState(() {
                    selectedYear = currentYear - index;
                  });
                },
                childDelegate: ListWheelChildBuilderDelegate(
                  builder: (context, index) {
                    final year = currentYear - index;
                    final isSelected = year == selectedYear;
                    return Container(
                      alignment: Alignment.center,
                      decoration: BoxDecoration(
                        border: isSelected
                            ? Border(
                                top: BorderSide(
                                  color:
                                      configProvider.textColor.withOpacity(0.4),
                                  width: 1.0,
                                ),
                                bottom: BorderSide(
                                  color:
                                      configProvider.textColor.withOpacity(0.4),
                                  width: 1.0,
                                ),
                              )
                            : null,
                      ),
                      child: Text(
                        year.toString(),
                        style: TextStyle(
                          fontSize: 18.0,
                          fontWeight:
                              isSelected ? FontWeight.bold : FontWeight.normal,
                          color: isSelected
                              ? configProvider.textColor
                              : configProvider.textColor.withOpacity(0.7),
                        ),
                      ),
                    );
                  },
                  childCount: currentYear - minYear + 1,
                ),
              ),
            ),
          ),
        ],
      ),
      actions: [
        LoadingOutlinedButton(
            onPressed: () => Navigator.of(context).pop(),
            isLoading: false,
            text: 'Voltar'),
        LoadingElevatedButton(
            text: 'Avançar',
            isLoading: false,
            onPressed: () {
              if (currentYear - selectedYear >= 18) {
                Navigator.of(context).pop(selectedYear);
              } else {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: const Text(
                      'Você precisa ser maior de idade para continuar.',
                    ),
                    backgroundColor: Colors.red,
                  ),
                );
              }
            })
      ],
    );
  }
}

void showForgotPasswordModal(BuildContext context) {
  showDialog(
    context: context,
    builder: (context) => const ForgotPasswordModal(),
  );
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\account\status_subscription_page.dart ===
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:in_app_purchase/in_app_purchase.dart';
import 'package:snarf/components/consumable_purchase_component.dart';
import 'package:snarf/components/loading_elevated_button.dart';
import 'package:snarf/pages/account/buy_subscription_page.dart';
import 'package:snarf/services/api_service.dart';
import 'package:snarf/utils/api_constants.dart';
import 'dart:io' show Platform;
import 'package:url_launcher/url_launcher.dart';

class StatusSubscriptionPage extends StatefulWidget {
  const StatusSubscriptionPage({super.key});

  @override
  State<StatusSubscriptionPage> createState() => _StatusSubscriptionPageState();
}

class _StatusSubscriptionPageState extends State<StatusSubscriptionPage> {
  final InAppPurchase _inAppPurchase = InAppPurchase.instance;
  bool _isLoading = true;
  bool _hasActiveSubscription = false;
  int _extraVideoCallMinutes = 0;
  List<ProductDetails> _consumableProducts = [];
  StreamSubscription<List<PurchaseDetails>>? _purchaseSubscription;

  @override
  void initState() {
    super.initState();
    _listenToPurchaseStream();
    _initPage();
  }

  Future<void> _initPage() async {
    await _retrieveUserInfo();
    await _queryConsumableProduct();
    await _restorePurchases();
    setState(() {
      _isLoading = false;
    });
  }

  Future<void> _retrieveUserInfo() async {
    final userId = await ApiService.getUserIdFromToken();
    if (userId != null) {
      final userInfo = await ApiService.getUserInfoById(userId);
      if (userInfo != null && userInfo.containsKey('extraVideoCallMinutes')) {
        setState(() {
          _extraVideoCallMinutes = userInfo['extraVideoCallMinutes'] ?? 0;
        });
      }
    }
  }

  Future<void> _queryConsumableProduct() async {
    final available = await _inAppPurchase.isAvailable();
    if (!available) return;
    final response =
        await _inAppPurchase.queryProductDetails({ApiConstants.productId});
    if (response.productDetails.isNotEmpty) {
      setState(() {
        _consumableProducts = response.productDetails;
      });
    }
  }

  void _listenToPurchaseStream() {
    _purchaseSubscription =
        _inAppPurchase.purchaseStream.listen((purchaseDetailsList) {
      setState(() {
        _hasActiveSubscription = purchaseDetailsList.any(
          (purchase) =>
              purchase.productID == ApiConstants.subscriptionId &&
              (purchase.status == PurchaseStatus.purchased ||
                  purchase.status == PurchaseStatus.restored),
        );
      });
    }, onDone: () => _purchaseSubscription?.cancel(), onError: (_) {});
  }

  Future<void> _restorePurchases() async {
    final available = await _inAppPurchase.isAvailable();
    if (!available) {
      return;
    }
    await _inAppPurchase.restorePurchases();
  }

  Future<void> _manageSubscription() async {
    String url = '';
    if (Platform.isAndroid) {
      const packageName = 'com.snarf.snarf';
      url =
          'https://play.google.com/store/account/subscriptions?sku=${ApiConstants.subscriptionId}&package=$packageName';
    } else if (Platform.isIOS) {
      url = 'itms-apps://apps.apple.com/account/subscriptions';
    }
    if (await canLaunchUrl(Uri.parse(url))) {
      await launchUrl(Uri.parse(url), mode: LaunchMode.externalApplication);
    }
  }

  void _buyConsumable(ProductDetails productDetails) {
    final purchaseParam = PurchaseParam(productDetails: productDetails);
    _inAppPurchase.buyConsumable(purchaseParam: purchaseParam);
  }

  @override
  void dispose() {
    _purchaseSubscription?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return Scaffold(
        appBar: AppBar(
          title: const Text('Status da Assinatura'),
        ),
        body: const Center(child: CircularProgressIndicator()),
      );
    }
    return Scaffold(
      appBar: AppBar(
        title: const Text('Status da Assinatura'),
      ),
      body: _hasActiveSubscription
          ? ListView(
              padding: const EdgeInsets.all(16),
              children: [
                const Text(
                  'Você possui uma assinatura ativa do Snarf Plus!',
                  style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 16),
                LoadingElevatedButton(
                  onPressed: _manageSubscription,
                  isLoading: false,
                  text: 'Gerenciar Assinatura',
                ),
                const SizedBox(height: 24),
                ConsumablePurchaseComponent(
                  consumableProducts: _consumableProducts,
                  onBuyConsumable: _buyConsumable,
                  purchasedMinutes: _extraVideoCallMinutes,
                ),
              ],
            )
          : Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Text(
                    'Você não possui assinatura ativa.',
                    style: TextStyle(fontSize: 16),
                  ),
                  LoadingElevatedButton(
                      text: 'Adquirir Assinatura',
                      isLoading: false,
                      onPressed: () {
                        Navigator.push(
                          context,
                          MaterialPageRoute(
                            builder: (_) => const BuySubscriptionPage(),
                          ),
                        );
                      })
                ],
              ),
            ),
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\account\view_user_page.dart ===
import 'dart:async';
import 'dart:convert';
import 'package:firebase_analytics/firebase_analytics.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/pages/account/buy_subscription_page.dart';
import 'package:snarf/pages/privateChat/private_chat_page.dart';
import 'package:snarf/providers/call_manager.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/providers/intercepted_image_provider.dart';
import 'package:snarf/services/api_service.dart';
import 'package:snarf/services/location_service.dart';
import 'package:snarf/services/signalr_manager.dart';
import 'package:snarf/utils/distance_utils.dart';
import 'package:snarf/utils/show_snackbar.dart';
import 'package:snarf/enums/signalr_event_type.dart';

class ViewUserPage extends StatefulWidget {
  final String userId;

  const ViewUserPage({super.key, required this.userId});

  @override
  _ViewUserPageState createState() => _ViewUserPageState();
}

class _ViewUserPageState extends State<ViewUserPage> {
  final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;
  String? _userName;
  String? _userEmail;
  String? _userImageUrl;
  double? _latitude;
  double? _longitude;
  DateTime? _lastActivity;
  bool _isLoading = true;
  double? _myLatitude;
  double? _myLongitude;
  bool _isFavorite = false;
  final _locationService = LocationService();

  bool get _isOnline {
    if (_lastActivity == null) return false;
    final difference = DateTime.now().difference(_lastActivity!);
    return difference.inMinutes < 1;
  }

  @override
  void initState() {
    super.initState();
    _analytics.logScreenView(
        screenName: 'ViewUserPage', screenClass: 'ViewUserPage');
    _loadUserInfo();
  }

  Future<void> _initLocation() async {
    final ok = await _locationService.initialize();
    if (ok) {
      final loc = await _locationService.getCurrentLocation();
      setState(() {
        _myLatitude = loc.latitude;
        _myLongitude = loc.longitude;
      });
      _locationService.onLocationChanged.listen((loc) {
        setState(() {
          _myLatitude = loc.latitude;
          _myLongitude = loc.longitude;
        });
      });
    }
  }

  Future<void> _loadUserInfo() async {
    await _initLocation();
    SignalRManager().listenToEvent("ReceiveMessage", _handleSignalRMessage);
    final userInfo = await ApiService.getUserInfoById(widget.userId);
    if (userInfo != null) {
      setState(() {
        _userName = userInfo['name'];
        _userEmail = userInfo['email'];
        _userImageUrl = userInfo['imageUrl'];
        _lastActivity = DateTime.parse(userInfo['lastActivity']).toLocal();
        _latitude = (userInfo['lastLatitude'] as num).toDouble();
        _longitude = (userInfo['lastLongitude'] as num).toDouble();
        _isLoading = false;
      });
      await _analytics.logEvent(
          name: 'view_user_info_loaded', parameters: {'userId': widget.userId});
    } else {
      showErrorSnackbar(context, 'Erro ao carregar informações do usuário');
      setState(() => _isLoading = false);
      await _analytics.logEvent(
          name: 'view_user_info_error', parameters: {'userId': widget.userId});
    }
  }

  void _handleSignalRMessage(List<Object?>? args) async {
    if (args == null || args.isEmpty) return;
    try {
      final Map<String, dynamic> data = jsonDecode(args[0] as String);
      final String? eventType = data['Type'];
      if (eventType == null) return;
      if (eventType ==
          SignalREventType.MapReceiveLocation
              .toString()
              .split('.')
              .last) {
        final mapData = data['Data'] as Map<String, dynamic>;
        final String userId = mapData['userId'];
        if (userId == widget.userId) {
          setState(() {
            _latitude = (mapData['Latitude'] as num).toDouble();
            _longitude = (mapData['Longitude'] as num).toDouble();
            _lastActivity = DateTime.now();
          });
          await _analytics.logEvent(
              name: 'view_user_location_update',
              parameters: {
                'userId': widget.userId,
                'latitude': _latitude!,
                'longitude': _longitude!
              });
        }
      } else if (eventType ==
          SignalREventType.UserDisconnected
              .toString()
              .split('.')
              .last) {
        final mapData = data['Data'] as Map<String, dynamic>;
        final String userId = mapData['userId'];
        if (userId == widget.userId) {
          setState(() {
            _lastActivity = DateTime.now().subtract(const Duration(days: 1));
          });
          await _analytics.logEvent(
              name: 'view_user_disconnected',
              parameters: {'userId': widget.userId});
        }
      } else if (eventType ==
          SignalREventType.PrivateChatReceiveFavorites
              .toString()
              .split('.')
              .last) {
        final List<dynamic> favorites = data['Data'] as List<dynamic>;
        for (var item in favorites) {
          if (item is Map<String, dynamic> && item['Id'] == widget.userId) {
            setState(() {
              _isFavorite = true;
            });
            await _analytics.logEvent(
                name: 'view_user_favorite_detected',
                parameters: {'userId': widget.userId});
            break;
          }
        }
      }
    } catch (e) {
      showErrorSnackbar(context, "Erro ao processar favoritos: $e");
      await _analytics.logEvent(
          name: 'view_user_signalr_error', parameters: {'error': e.toString()});
    }
  }

  Future<void> _toggleFavorite() async {
    try {
      if (_isFavorite) {
        await SignalRManager().sendSignalRMessage(
          SignalREventType.PrivateChatRemoveFavorite,
          {'ChatUserId': widget.userId},
        );
      } else {
        await SignalRManager().sendSignalRMessage(
          SignalREventType.PrivateChatAddFavorite,
          {'ChatUserId': widget.userId},
        );
      }
      setState(() => _isFavorite = !_isFavorite);
      await _analytics.logEvent(
          name: 'view_user_toggle_favorite',
          parameters: {'userId': widget.userId, 'now_favorite': _isFavorite});
    } catch (e) {
      showErrorSnackbar(context, "Erro ao alterar favorito: $e");
      await _analytics.logEvent(
          name: 'view_user_toggle_favorite_error',
          parameters: {'error': e.toString()});
    }
  }

  Future<void> _initiateCall(String targetUserId) async {
    final config = Provider.of<ConfigProvider>(context, listen: false);
    if (config.isSubscriber) {
      try {
        final callManager = Provider.of<CallManager>(context, listen: false);
        callManager.startCall(targetUserId);
        await _analytics.logEvent(
            name: 'view_user_initiate_call',
            parameters: {'targetUserId': targetUserId});
      } catch (e) {
        showErrorSnackbar(context, "Erro ao iniciar chamada: $e");
        await _analytics.logEvent(
            name: 'view_user_initiate_call_error',
            parameters: {'error': e.toString()});
      }
    } else {
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => BuySubscriptionPage(),
        ),
      );
    }
  }

  Widget _buildUserImage() {
    final config = Provider.of<ConfigProvider>(context, listen: false);
    return Container(
      width: 120,
      height: 120,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: Border.all(color: config.secondaryColor, width: 2),
        image: _userImageUrl != null
            ? DecorationImage(
          image: InterceptedImageProvider(
              originalProvider: NetworkImage(_userImageUrl!),
              hideImages: config.hideImages),
          fit: BoxFit.cover,
        )
            : const DecorationImage(
          image: AssetImage('assets/images/user_anonymous.png'),
          fit: BoxFit.cover,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final config = Provider.of<ConfigProvider>(context);
    return Scaffold(
      backgroundColor: config.primaryColor,
      appBar: AppBar(
        backgroundColor: config.primaryColor,
        iconTheme: IconThemeData(color: config.iconColor),
        title: Text('Perfil do Usuário',
            style: TextStyle(color: config.textColor)),
        actions: [
          IconButton(
            icon: Icon(_isFavorite ? Icons.star : Icons.star_border,
                color: config.iconColor),
            onPressed: _toggleFavorite,
          ),
          IconButton(
            icon: Icon(Icons.videocam, color: config.iconColor),
            onPressed: () => _initiateCall(widget.userId),
          )
        ],
      ),
      body: _isLoading
          ? Center(child: CircularProgressIndicator(color: config.iconColor))
          : Padding(
        padding: const EdgeInsets.all(16.0),
        child: SingleChildScrollView(
          child: Center(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                _buildUserImage(),
                const SizedBox(height: 20),
                Text(
                  _userName ?? 'Nome não disponível',
                  style: TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                      color: config.textColor),
                ),
                const SizedBox(height: 10),
                Text(
                  _userEmail ?? 'E-mail não disponível',
                  style: TextStyle(
                      fontSize: 16,
                      color: config.textColor.withOpacity(0.6)),
                ),
                const SizedBox(height: 10),
                if (_latitude != null && _longitude != null) ...[
                  Text(
                    'Distância: ${DistanceUtils
                        .calculateDistance(
                        _myLatitude!, _myLongitude!, _latitude!, _longitude!)
                        .toStringAsFixed(2)} km',
                    style: TextStyle(color: config.textColor),
                  ),
                ] else
                  ...[
                    Text('Distância indisponível',
                        style: TextStyle(color: config.textColor)),
                  ],
                const SizedBox(height: 10),
                Text(
                  _isOnline ? 'Online' : 'Offline',
                  style: TextStyle(
                    color: _isOnline
                        ? config.customGreen
                        : config.customOrange,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 10),
                ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: config.secondaryColor,
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(30)),
                  ),
                  onPressed: _userName != null && _userImageUrl != null
                      ? () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) =>
                            PrivateChatPage(
                              userId: widget.userId,
                              userName: _userName!,
                              userImage: _userImageUrl!,
                            ),
                      ),
                    );
                  }
                      : null,
                  child: Text('Iniciar Chat Privado',
                      style: TextStyle(color: config.textColor)),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\parties\create_edit_party_page.dart ===
import 'dart:convert';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:geolocator/geolocator.dart';
import 'package:image_picker/image_picker.dart';
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/services/api_service.dart';
import 'package:snarf/services/location_service.dart';
import 'package:snarf/utils/show_snackbar.dart';

class CreateEditPartyPage extends StatefulWidget {
  final String? partyId;

  const CreateEditPartyPage({
    super.key,
    this.partyId,
  });

  @override
  State<CreateEditPartyPage> createState() => _CreateEditPartyPageState();
}

class _CreateEditPartyPageState extends State<CreateEditPartyPage> {
  final _formKey = GlobalKey<FormState>();
  final _locationService = LocationService();
  late TextEditingController _titleController;
  late TextEditingController _descController;
  late TextEditingController _locationController;
  late TextEditingController _instructionsController;
  late DateTime _selectedDate;
  late int _duration;
  late int _type;

  String? _base64Image;
  File? _imageFile;

  final List<Map<String, dynamic>> _partyTypes = [
    {"value": 0, "label": "Orgia"},
    {"value": 1, "label": "Bomba e Despejo"},
    {"value": 2, "label": "Masturbação Coletiva"},
    {"value": 3, "label": "Grupo de Bukkake"},
    {"value": 4, "label": "Grupo Fetiche"},
    {"value": 5, "label": "Evento Especial"},
  ];

  late Position _location;
  double? _latitude;
  double? _longitude;

  bool _isLoading = false;

  @override
  void initState() {
    super.initState();

    _titleController = TextEditingController();
    _descController = TextEditingController();
    _locationController = TextEditingController();
    _instructionsController = TextEditingController();
    _selectedDate = DateTime.now();
    _duration = 60;
    _type = 0;

    if (widget.partyId != null) {
      _fetchPartyData(widget.partyId!);
    }

    _obterLocalizacao();
  }

  Future<void> _fetchPartyData(String partyId) async {
    final userId = await ApiService.getUserIdFromToken();

    setState(() => _isLoading = true);

    final partyData =
        await ApiService.getPartyDetails(partyId: partyId, userId: userId!);
    setState(() => _isLoading = false);

    if (partyData == null) {
      showErrorSnackbar(context, "Erro ao carregar dados da festa.");
      return;
    }

    setState(() {
      _titleController.text = partyData["title"] ?? "";
      _descController.text = partyData["description"] ?? "";
      _locationController.text = partyData["location"] ?? "";
      _instructionsController.text = partyData["instructions"] ?? "";

      final startDateStr = partyData["startDate"];
      if (startDateStr != null) {
        _selectedDate = DateTime.tryParse(startDateStr) ?? DateTime.now();
      }

      _duration = partyData["duration"] ?? 60;
      _type = partyData["type"] ?? 0;
    });
  }

  Future<void> _obterLocalizacao() async {
    final ok = await _locationService.initialize();
    if (ok) {
      final loc = await _locationService.getCurrentLocation();
      setState(() {
        _latitude = loc.latitude;
        _longitude = loc.longitude;
      });
      _locationService.onLocationChanged.listen((loc) {
        setState(() {
          _latitude = loc.latitude;
          _longitude = loc.longitude;
        });
      });
    }
  }

  Future<void> _pickImage() async {
    final picker = ImagePicker();
    final pickedFile = await picker.pickImage(source: ImageSource.gallery);
    if (pickedFile != null) {
      _imageFile = File(pickedFile.path);
      final bytes = await _imageFile!.readAsBytes();
      _base64Image = base64Encode(bytes);
      setState(() {});
    }
  }

  Future<void> _onSave() async {
    if (!_formKey.currentState!.validate()) return;

    final userId = await ApiService.getUserIdFromToken();
    if (userId == null) {
      showErrorSnackbar(context, 'Token inválido');
      return;
    }

    final email = await _getUserEmail(userId);
    if (email == null) {
      showErrorSnackbar(context, 'Email não encontrado');
      return;
    }

    if (widget.partyId == null) {
      final result = await ApiService.createParty(
        email: email,
        title: _titleController.text,
        description: _descController.text,
        startDate: _selectedDate,
        duration: _duration,
        type: _type,
        location: _locationController.text,
        instructions: _instructionsController.text,
        latitude: _latitude ?? 0.0,
        longitude: _longitude ?? 0.0,
        coverImageBase64: _base64Image ?? '',
      );
      if (result != null) {
        Navigator.pop(context, true);
      } else {
        showErrorSnackbar(context, 'Erro ao criar festa');
      }
      return;
    }

    final result = await ApiService.updateParty(
      partyId: widget.partyId!,
      title: _titleController.text,
      description: _descController.text,
      location: _locationController.text,
      instructions: _instructionsController.text,
      startDate: _selectedDate,
      duration: _duration,
    );
    if (result != null) {
      Navigator.pop(context, true);
    } else {
      showErrorSnackbar(context, 'Erro ao atualizar festa');
    }
  }

  Future<String?> _getUserEmail(String userId) async {
    final userData = await ApiService.getUserInfoById(userId);
    if (userData == null) return null;
    return userData['email'];
  }

  Future<void> _selectDateTime() async {
    final selected = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime.now(),
      lastDate: DateTime(2100),
    );
    if (selected != null) {
      final pickedTime = await showTimePicker(
        context: context,
        initialTime:
            TimeOfDay(hour: _selectedDate.hour, minute: _selectedDate.minute),
      );
      if (pickedTime != null) {
        setState(() {
          _selectedDate = DateTime(
            selected.year,
            selected.month,
            selected.day,
            pickedTime.hour,
            pickedTime.minute,
          );
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);

    return Scaffold(
      backgroundColor: configProvider.primaryColor,
      appBar: AppBar(
        backgroundColor: configProvider.primaryColor,
        title: Text(
          widget.partyId == null ? 'Criar Festa' : 'Editar Festa',
          style: TextStyle(color: configProvider.textColor),
        ),
        iconTheme: IconThemeData(color: configProvider.iconColor),
      ),
      body: Stack(
        children: [
          if (_isLoading)
            Center(
              child: CircularProgressIndicator(
                color: configProvider.iconColor,
              ),
            )
          else
            Padding(
              padding: const EdgeInsets.all(16),
              child: SingleChildScrollView(
                child: Form(
                  key: _formKey,
                  child: Column(
                    children: [
                      GestureDetector(
                        onTap: _pickImage,
                        child: Column(
                          children: [
                            _imageFile == null
                                ? Container(
                                    height: 120,
                                    width: 120,
                                    decoration: BoxDecoration(
                                      color: configProvider.secondaryColor
                                          .withOpacity(0.2),
                                      shape: BoxShape.circle,
                                    ),
                                    child: Icon(
                                      Icons.camera_alt,
                                      size: 40,
                                      color: configProvider.iconColor,
                                    ),
                                  )
                                : CircleAvatar(
                                    radius: 60,
                                    backgroundImage: FileImage(_imageFile!),
                                  ),
                            const SizedBox(height: 8),
                            Text(
                              _imageFile == null
                                  ? 'Adicionar Imagem'
                                  : 'Alterar Imagem',
                              style: TextStyle(color: configProvider.textColor),
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(height: 20),

                      TextFormField(
                        controller: _titleController,
                        decoration: InputDecoration(
                          labelText: 'Título',
                          hintText: 'Ex: Bomba e Despejo no Sítio do Juca',
                          prefixIcon: Icon(
                            Icons.title,
                            color: configProvider.iconColor,
                          ),
                          labelStyle:
                              TextStyle(color: configProvider.textColor),
                          hintStyle: TextStyle(
                              color: configProvider.textColor.withOpacity(0.5)),
                          filled: true,
                          fillColor:
                              configProvider.secondaryColor.withOpacity(0.1),
                        ),
                        style: TextStyle(color: configProvider.textColor),
                        textInputAction: TextInputAction.next,
                        validator: (val) => val == null || val.isEmpty
                            ? 'Informe o título'
                            : null,
                      ),
                      const SizedBox(height: 10),

                      TextFormField(
                        controller: _descController,
                        decoration: InputDecoration(
                          labelText: 'Descrição',
                          hintText: 'Descreva o evento',
                          prefixIcon: Icon(
                            Icons.description,
                            color: configProvider.iconColor,
                          ),
                          labelStyle:
                              TextStyle(color: configProvider.textColor),
                          hintStyle: TextStyle(
                              color: configProvider.textColor.withOpacity(0.5)),
                          filled: true,
                          fillColor:
                              configProvider.secondaryColor.withOpacity(0.1),
                        ),
                        maxLines: 3,
                        style: TextStyle(color: configProvider.textColor),
                        textInputAction: TextInputAction.next,
                        validator: (val) => val == null || val.isEmpty
                            ? 'Informe a descrição'
                            : null,
                      ),
                      const SizedBox(height: 10),

                      GestureDetector(
                        onTap: _selectDateTime,
                        child: Container(
                          padding: const EdgeInsets.symmetric(
                              vertical: 16, horizontal: 12),
                          decoration: BoxDecoration(
                            color:
                                configProvider.secondaryColor.withOpacity(0.1),
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: Row(
                            children: [
                              Icon(Icons.calendar_today,
                                  color: configProvider.iconColor),
                              const SizedBox(width: 10),
                              Text(
                                'Data e Hora: ${DateFormat('dd/MM/yyyy HH:mm').format(_selectedDate)}',
                                style:
                                    TextStyle(color: configProvider.textColor),
                              ),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 10),

                      TextFormField(
                        controller: _locationController,
                        decoration: InputDecoration(
                          labelText: 'Local',
                          hintText: 'Ex: Endereço ou nome do lugar',
                          prefixIcon: Icon(
                            Icons.location_on,
                            color: configProvider.iconColor,
                          ),
                          labelStyle:
                              TextStyle(color: configProvider.textColor),
                          hintStyle: TextStyle(
                              color: configProvider.textColor.withOpacity(0.5)),
                          filled: true,
                          fillColor:
                              configProvider.secondaryColor.withOpacity(0.1),
                        ),
                        style: TextStyle(color: configProvider.textColor),
                        textInputAction: TextInputAction.next,
                        validator: (val) => val == null || val.isEmpty
                            ? 'Informe o local'
                            : null,
                      ),
                      const SizedBox(height: 10),

                      TextFormField(
                        controller: _instructionsController,
                        decoration: InputDecoration(
                          labelText: 'Instruções',
                          hintText: 'Ex: Levar toalha, bebida, etc.',
                          prefixIcon: Icon(
                            Icons.list,
                            color: configProvider.iconColor,
                          ),
                          labelStyle:
                              TextStyle(color: configProvider.textColor),
                          hintStyle: TextStyle(
                              color: configProvider.textColor.withOpacity(0.5)),
                          filled: true,
                          fillColor:
                              configProvider.secondaryColor.withOpacity(0.1),
                        ),
                        maxLines: 3,
                        style: TextStyle(color: configProvider.textColor),
                        textInputAction: TextInputAction.next,
                        validator: (val) => val == null || val.isEmpty
                            ? 'Informe as instruções'
                            : null,
                      ),
                      const SizedBox(height: 10),

                      TextFormField(
                        initialValue: _duration.toString(),
                        keyboardType: TextInputType.number,
                        decoration: InputDecoration(
                          labelText: 'Duração (min)',
                          hintText: 'Ex: 120',
                          prefixIcon: Icon(
                            Icons.access_time,
                            color: configProvider.iconColor,
                          ),
                          labelStyle:
                              TextStyle(color: configProvider.textColor),
                          hintStyle: TextStyle(
                              color: configProvider.textColor.withOpacity(0.5)),
                          filled: true,
                          fillColor:
                              configProvider.secondaryColor.withOpacity(0.1),
                        ),
                        style: TextStyle(color: configProvider.textColor),
                        textInputAction: TextInputAction.next,
                        onChanged: (val) {
                          if (val.isNotEmpty) {
                            _duration = int.tryParse(val) ?? 60;
                          }
                        },
                      ),
                      const SizedBox(height: 10),

                      DropdownButtonFormField<int>(
                        value: _type,
                        items: _partyTypes
                            .map(
                              (pt) => DropdownMenuItem<int>(
                                value: pt["value"],
                                child: Text(
                                  pt["label"],
                                  style: TextStyle(
                                      color: configProvider.textColor),
                                ),
                              ),
                            )
                            .toList(),
                        onChanged: (val) {
                          if (val != null) {
                            setState(() {
                              _type = val;
                            });
                          }
                        },
                        decoration: InputDecoration(
                          labelText: 'Tipo de Festa',
                          labelStyle:
                              TextStyle(color: configProvider.textColor),
                          filled: true,
                          fillColor:
                              configProvider.secondaryColor.withOpacity(0.1),
                        ),
                        style: TextStyle(color: configProvider.textColor),
                      ),
                      const SizedBox(height: 20),

                      ElevatedButton(
                        onPressed: _onSave,
                        child: Text(
                          widget.partyId == null
                              ? 'Criar Festa'
                              : 'Salvar Alterações',
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\parties\party_chat_page.dart ===
import 'dart:convert';
import 'dart:developer';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:provider/provider.dart';
import 'package:snarf/pages/account/view_user_page.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/services/signalr_manager.dart';
import 'package:snarf/utils/date_utils.dart';
import 'package:snarf/enums/signalr_event_type.dart';

class PartyChatPage extends StatefulWidget {
  final String partyId;
  final String userId;

  const PartyChatPage({
    Key? key,
    required this.partyId,
    required this.userId,
  }) : super(key: key);

  @override
  _PartyChatPageState createState() => _PartyChatPageState();
}

class _PartyChatPageState extends State<PartyChatPage> {
  final TextEditingController _messageController = TextEditingController();
  final List<Map<String, dynamic>> _messages = [];
  bool _isLoading = true;
  bool _isSendingImage = false;
  final ScrollController _scrollController = ScrollController();
  final ImagePicker _picker = ImagePicker();

  @override
  void initState() {
    super.initState();
    _setupSignalRConnection();
  }

  Future<void> _setupSignalRConnection() async {
    SignalRManager().listenToEvent(
      "ReceiveMessage",
      _onReceivePartyChatMessage,
    );

    await SignalRManager().sendSignalRMessage(
      SignalREventType.PartyChatGetPreviousMessages,
      {"PartyId": widget.partyId},
    );

    setState(() {
      _isLoading = false;
    });
  }

  void _onReceivePartyChatMessage(List<Object?>? args) {
    if (args == null || args.isEmpty) return;

    try {
      final Map<String, dynamic> message = jsonDecode(args[0] as String);
      final String eventType = message["Type"];

      if (eventType == "PartyChatReceiveMessage") {
        final data = message["Data"];
        setState(() {
          _messages.add({
            'id': data['Id'],
            'createdAt': DateTime.parse(data['CreatedAt']).toLocal(),
            'userId': data['UserId'],
            'userName': data['UserName'],
            'userImage': data['UserImage'],
            'message': data['Message'],
            'isImage': data['Message'].toString().startsWith('https://'),
          });
        });
        _scrollToBottom();
      } else if (eventType == "PartyChatReceiveMessageDeleted") {
        final data = message["Data"];
        final messageId = data['MessageId'];
        setState(() {
          final index = _messages.indexWhere((m) => m['id'] == messageId);
          if (index != -1) {
            _messages[index]['message'] = "Mensagem excluída";
          }
        });
      }
    } catch (e) {
      log("Erro ao processar mensagem do bate-papo da festa: $e");
    }
  }

  void _scrollToBottom() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_scrollController.hasClients) {
        _scrollController.animateTo(
          _scrollController.position.maxScrollExtent,
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeOut,
        );
      }
    });
  }

  Future<void> _sendMessage() async {
    final messageText = _messageController.text.trim();
    if (messageText.isEmpty) return;

    await SignalRManager().sendSignalRMessage(
      SignalREventType.PartyChatSendMessage,
      {
        "PartyId": widget.partyId,
        "Message": messageText,
      },
    );

    setState(() {
      _messageController.clear();
    });
    _scrollToBottom();
  }

  Future<void> _sendImage() async {
    final pickedFile = await _picker.pickImage(
      source: ImageSource.gallery,
      maxWidth: 800,
      maxHeight: 800,
    );

    if (pickedFile != null) {
      try {
        setState(() => _isSendingImage = true);

        final bytes = await pickedFile.readAsBytes();
        final base64Image = base64Encode(bytes);

        await SignalRManager().sendSignalRMessage(
          SignalREventType.PartyChatSendImage,
          {
            "PartyId": widget.partyId,
            "Image": base64Image,
            "FileName": pickedFile.name,
          },
        );
      } catch (e) {
        log("Erro ao enviar imagem: $e");
      } finally {
        setState(() => _isSendingImage = false);
      }
    }
  }

  Future<void> _deleteMessage(String messageId) async {
    await SignalRManager().sendSignalRMessage(
      SignalREventType.PartyChatDeleteMessage,
      {
        "PartyId": widget.partyId,
        "MessageId": messageId,
      },
    );
  }

  Widget _buildMessageWidget(Map<String, dynamic> msg) {
    final bool isMine = (msg['userId'] == widget.userId);
    final configProvider = Provider.of<ConfigProvider>(context, listen: false);

    final String messageText = msg['message'] ?? '';
    final bool isImage = msg['isImage'] == true;

    // Pega a data de criação e converte para "Há x tempo"
    final DateTime createdAt = msg['createdAt'] ?? DateTime.now();
    final String relativeTime =
        DateJSONUtils.formatRelativeTime(createdAt.toString());

    if (isMine) {
      // Mensagem do usuário atual
      return Column(
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          // "Há x tempo" em cima do bubble
          Padding(
            padding: const EdgeInsets.only(right: 12, top: 8, bottom: 2),
            child: Text(
              relativeTime,
              style: TextStyle(
                fontSize: 10,
                fontStyle: FontStyle.italic,
                color: configProvider.textColor,
              ),
            ),
          ),
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              Flexible(
                child: Container(
                  margin: const EdgeInsets.symmetric(
                    vertical: 18,
                    horizontal: 8,
                  ),
                  padding:
                      const EdgeInsets.symmetric(vertical: 8, horizontal: 12),
                  decoration: BoxDecoration(
                    color: configProvider.secondaryColor,
                    borderRadius: const BorderRadius.only(
                      topLeft: Radius.circular(12),
                      topRight: Radius.circular(12),
                      bottomLeft: Radius.circular(12),
                    ),
                  ),
                  child: isImage
                      ? Image.network(
                          messageText,
                          errorBuilder: (_, __, ___) {
                            return Text(
                              'Erro ao carregar imagem',
                              style: TextStyle(color: configProvider.textColor),
                            );
                          },
                        )
                      : Text(
                          messageText,
                          style: TextStyle(color: configProvider.textColor),
                        ),
                ),
              ),
              if (messageText != "Mensagem excluída")
                IconButton(
                  icon: Icon(
                    Icons.delete,
                    size: 18,
                    color: configProvider.iconColor,
                  ),
                  onPressed: () => _deleteMessage(msg['id']),
                ),
            ],
          ),
        ],
      );
    } else {
      // Mensagem de outro usuário
      return Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Coloca a data/hora acima do avatar
          Padding(
            padding: const EdgeInsets.only(left: 8, right: 8),
            child: Column(
              children: [
                Text(
                  relativeTime,
                  style: TextStyle(
                    fontSize: 10,
                    fontStyle: FontStyle.italic,
                    color: configProvider.textColor,
                  ),
                ),
                const SizedBox(height: 4),
                GestureDetector(
                  onTap: () {
                    if (msg['userId'] == null) return;
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => ViewUserPage(
                          userId: msg['userId'],
                        ),
                      ),
                    );
                  },
                  child: Container(
                    width: 50,
                    height: 50,
                    margin: const EdgeInsets.only(top: 2),
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(30),
                      image: (msg['userImage'] != null &&
                              msg['userImage'].toString().isNotEmpty)
                          ? DecorationImage(
                              image: NetworkImage(msg['userImage']),
                              fit: BoxFit.cover,
                            )
                          : null,
                    ),
                    child: (msg['userImage'] == null ||
                            msg['userImage'].toString().isEmpty)
                        ? Center(
                            child: Icon(
                              Icons.person,
                              color: configProvider.iconColor,
                            ),
                          )
                        : null,
                  ),
                ),
              ],
            ),
          ),
          Flexible(
            child: Container(
              margin: const EdgeInsets.symmetric(vertical: 18, horizontal: 0),
              padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 12),
              decoration: BoxDecoration(
                color: configProvider.secondaryColor,
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(12),
                  topRight: Radius.circular(12),
                  bottomRight: Radius.circular(12),
                ),
              ),
              child: isImage
                  ? Image.network(
                      messageText,
                      errorBuilder: (_, __, ___) {
                        return Text(
                          'Erro ao carregar imagem',
                          style: TextStyle(color: configProvider.textColor),
                        );
                      },
                    )
                  : Text(
                      messageText,
                      style: TextStyle(
                        color: configProvider.textColor,
                      ),
                    ),
            ),
          ),
        ],
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);

    return Scaffold(
      appBar: AppBar(
        backgroundColor: configProvider.primaryColor,
        iconTheme: IconThemeData(color: configProvider.iconColor),
        title: Text(
          'Bate-papo da Festa',
          style: TextStyle(color: configProvider.textColor),
        ),
      ),
      backgroundColor: configProvider.primaryColor,
      body: _isLoading
          ? Center(
              child: CircularProgressIndicator(
                color: configProvider.iconColor,
              ),
            )
          : Column(
              children: [
                Expanded(
                  child: ListView.builder(
                    controller: _scrollController,
                    itemCount: _messages.length,
                    itemBuilder: (context, index) {
                      final msg = _messages[index];
                      return _buildMessageWidget(msg);
                    },
                  ),
                ),
                Padding(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 8, vertical: 12),
                  child: Row(
                    children: [
                      _isSendingImage
                          ? SizedBox(
                              width: 30,
                              height: 30,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: configProvider.iconColor,
                              ),
                            )
                          : IconButton(
                              icon: Icon(
                                Icons.photo,
                                color: configProvider.iconColor,
                              ),
                              onPressed: _sendImage,
                            ),
                      Expanded(
                        child: TextField(
                          controller: _messageController,
                          style: TextStyle(color: configProvider.textColor),
                          decoration: InputDecoration(
                            hintText: "Digite sua mensagem",
                            hintStyle: TextStyle(
                              color: configProvider.textColor.withOpacity(0.6),
                            ),
                            filled: true,
                            fillColor:
                                configProvider.secondaryColor.withOpacity(0.1),
                            border: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(30),
                              borderSide: BorderSide(
                                color: configProvider.secondaryColor,
                              ),
                            ),
                            enabledBorder: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(30),
                              borderSide: BorderSide(
                                color: configProvider.secondaryColor,
                              ),
                            ),
                          ),
                        ),
                      ),
                      IconButton(
                        icon: Icon(Icons.send, color: configProvider.iconColor),
                        onPressed: _sendMessage,
                      ),
                    ],
                  ),
                ),
              ],
            ),
    );
  }

  @override
  void dispose() {
    _messageController.dispose();
    _scrollController.dispose();
    super.dispose();
  }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\parties\party_details_page.dart ===
import 'dart:convert';
import 'dart:developer';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/pages/account/view_user_page.dart';
import 'package:snarf/pages/parties/create_edit_party_page.dart';
import 'package:snarf/pages/parties/party_chat_page.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/services/api_service.dart';
import 'package:snarf/services/signalr_manager.dart';
import 'package:snarf/utils/show_snackbar.dart';
import 'package:snarf/enums/signalr_event_type.dart';

class PartyDetailsPage extends StatefulWidget {
  final String partyId;
  final String userId;

  const PartyDetailsPage({
    Key? key,
    required this.partyId,
    required this.userId,
  }) : super(key: key);

  @override
  State<PartyDetailsPage> createState() => _PartyDetailsPageState();
}

class _PartyDetailsPageState extends State<PartyDetailsPage> {
  Map<String, dynamic>? _partyData;
  bool _isLoading = true;

  bool _loadingRequest = false;
  bool _loadingConfirmation = false;
  bool _loadingDecline = false;

  List<Map<String, dynamic>> _recentChats = [];
  bool _isLoadingRecentChats = false;

  @override
  void initState() {
    super.initState();
    _loadPartyDetails();
  }

  Future<void> _loadPartyDetails() async {
    final data = await ApiService.getPartyDetails(
      partyId: widget.partyId,
      userId: widget.userId,
    );
    if (!mounted) return;
    if (data == null) {
      showErrorSnackbar(context, 'Não foi possível carregar detalhes da festa');
      Navigator.pop(context);
      return;
    }

    setState(() {
      _partyData = data;
      _isLoading = false;
    });
  }

  Future<void> _editParty() async {
    final result = await Navigator.push(
      context,
      MaterialPageRoute(
        builder: (_) => CreateEditPartyPage(partyId: widget.partyId),
      ),
    );
    if (result == true) {
      await _loadPartyDetails();
    }
  }

  Future<void> _deleteParty() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Excluir Festa'),
        content: const Text('Tem certeza que deseja excluir esta festa?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx, false),
            child: const Text('Cancelar'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(ctx, true),
            child: const Text('Excluir'),
          ),
        ],
      ),
    );

    if (confirm != true) return;

    final result = await ApiService.deleteParty(widget.partyId, widget.userId);
    if (!mounted) return;
    if (result == true) {
      showSuccessSnackbar(context, 'Festa excluída com sucesso!');
      Navigator.pop(context);
    } else {
      showErrorSnackbar(context, 'Erro ao excluir festa');
    }
  }

  Future<void> _requestParticipation() async {
    if (_loadingRequest) return;
    setState(() => _loadingRequest = true);

    final result = await ApiService.requestPartyParticipation(
      partyId: widget.partyId,
      userId: widget.userId,
    );

    if (!mounted) return;
    setState(() => _loadingRequest = false);

    if (result == true) {
      await _loadPartyDetails();
      showSuccessSnackbar(context, 'Solicitação enviada');
    } else {
      showErrorSnackbar(context, 'Erro ao solicitar participação');
    }
  }

  Future<void> _confirmParticipation(String targetUserId) async {
    if (_loadingConfirmation) return;
    setState(() => _loadingConfirmation = true);

    final result = await ApiService.confirmUser(widget.partyId, targetUserId);

    if (!mounted) return;
    setState(() => _loadingConfirmation = false);

    if (result == true) {
      await _loadPartyDetails();
      showSuccessSnackbar(context, 'Convite confirmado');
    } else {
      showErrorSnackbar(context, 'Erro ao confirmar');
    }
  }

  Future<void> _declineParticipation(String targetUserId) async {
    if (_loadingDecline) return;
    setState(() => _loadingDecline = true);

    final result = await ApiService.declineUser(widget.partyId, targetUserId);

    if (!mounted) return;
    setState(() => _loadingDecline = false);

    if (result == true) {
      await _loadPartyDetails();
      showSuccessSnackbar(context, 'Convite recusado');
    } else {
      showErrorSnackbar(context, 'Erro ao recusar');
    }
  }

  Future<void> _openInviteUsersDialog() async {
    await _loadRecentChats();

    if (!mounted) return;

    final List<String> selectedUserIds = [];

    await showDialog(
      context: context,
      builder: (ctx) {
        return StatefulBuilder(
          builder: (dialogContext, setStateDialog) {
            final configProvider =
            Provider.of<ConfigProvider>(context, listen: false);

            if (_isLoadingRecentChats) {
              return AlertDialog(
                title: const Text('Convidar usuários'),
                content: const SizedBox(
                  height: 80,
                  child: Center(
                    child: CircularProgressIndicator(),
                  ),
                ),
              );
            }

            if (_recentChats.isEmpty) {
              return AlertDialog(
                title: const Text('Convidar usuários'),
                content: const Text('Nenhum chat recente encontrado.'),
                actions: [
                  TextButton(
                    onPressed: () => Navigator.pop(dialogContext),
                    child: const Text('Fechar'),
                  ),
                ],
              );
            }

            return AlertDialog(
              backgroundColor: configProvider.primaryColor,
              title: Text(
                'Convidar usuários',
                style: TextStyle(color: configProvider.textColor),
              ),
              content: SizedBox(
                width: double.maxFinite,
                height: 300,
                child: ListView.builder(
                  itemCount: _recentChats.length,
                  itemBuilder: (context, index) {
                    final chat = _recentChats[index];
                    final userId = chat['UserId']?.toString() ?? '';
                    final userName = chat['UserName'] ?? '';

                    final isSelected = selectedUserIds.contains(userId);

                    return Card(
                      color: configProvider.secondaryColor,
                      child: CheckboxListTile(
                        title: Text(
                          userName,
                          style: TextStyle(color: configProvider.textColor),
                        ),
                        value: isSelected,
                        onChanged: (checked) {
                          setStateDialog(() {
                            if (checked == true) {
                              selectedUserIds.add(userId);
                            } else {
                              selectedUserIds.remove(userId);
                            }
                          });
                        },
                      ),
                    );
                  },
                ),
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(dialogContext),
                  child: Text(
                    'Cancelar',
                    style: TextStyle(color: configProvider.textColor),
                  ),
                ),
                ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: configProvider.secondaryColor,
                  ),
                  onPressed: selectedUserIds.isEmpty
                      ? null
                      : () async {
                    for (final id in selectedUserIds) {
                      final success =
                      await ApiService.requestPartyParticipation(
                        partyId: widget.partyId,
                        userId: id,
                      );
                      if (success) {
                        showSuccessSnackbar(
                          context,
                          'Convite enviado para $id',
                        );
                      } else {
                        showErrorSnackbar(
                          context,
                          'Erro ao convidar $id',
                        );
                      }
                    }

                    if (!mounted) return;
                    Navigator.pop(dialogContext);
                    _loadPartyDetails();
                  },
                  child: const Text('Convidar'),
                ),
              ],
            );
          },
        );
      },
    );
  }

  Future<void> _loadRecentChats() async {
    setState(() => _isLoadingRecentChats = true);

    SignalRManager().listenToEvent('ReceiveMessage', _handleSignalRMessage);

    await SignalRManager().sendSignalRMessage(
      SignalREventType.PrivateChatGetRecentChats,
      {},
    );

    await Future.delayed(const Duration(milliseconds: 400));

    setState(() => _isLoadingRecentChats = false);
  }

  void _handleSignalRMessage(List<Object?>? args) {
    if (args == null || args.isEmpty) return;

    try {
      final Map<String, dynamic> message = jsonDecode(args[0] as String);
      final SignalREventType type = SignalREventType.values.firstWhere(
            (e) => e.toString().split('.').last == message['Type'],
      );

      final dynamic data = message['Data'];

      switch (type) {
        case SignalREventType.PrivateChatReceiveRecentChats:
          _handleRecentChats(data);
          break;
        case SignalREventType.PrivateChatReceiveFavorites:
        case SignalREventType.PrivateChatReceiveMessage:
        case SignalREventType.MapReceiveLocation:
        case SignalREventType.UserDisconnected:
          break;
        default:
          log("Evento não reconhecido: ${message['Type']}");
      }
    } catch (e) {
      log("Erro ao processar mensagem SignalR: $e");
    }
  }

  void _handleRecentChats(dynamic data) {
    try {
      final parsedData = data as List<dynamic>;
      setState(() {
        _recentChats = parsedData.map((item) {
          final mapItem = item is Map<String, dynamic>
              ? item
              : Map<String, dynamic>.from(item);

          return {
            'UserId': mapItem['UserId'],
            'UserName': mapItem['UserName'],
            'UserImage': mapItem['UserImage'],
            'LastMessage': mapItem['LastMessage'],
            'LastMessageDate': mapItem['LastMessageDate'],
            'UnreadCount': mapItem['UnreadCount'],
          };
        }).toList();
      });
    } catch (e) {
      showErrorSnackbar(context, "Erro ao processar chats recentes: $e");
    }
  }

  String _mapType(int type) {
    switch (type) {
      case 0:
        return "Orgia";
      case 1:
        return "Bomba e Despejo";
      case 2:
        return "Masturbação Coletiva";
      case 3:
        return "Grupo de Bukkake";
      case 4:
        return "Grupo Fetiche";
      case 5:
        return "Evento Especial";
      default:
        return "Desconhecido";
    }
  }

  Widget _buildInfoRow({
    required IconData icon,
    required String label,
    required ConfigProvider config,
  }) {
    return Row(
      children: [
        Icon(icon, color: config.iconColor),
        const SizedBox(width: 8),
        Expanded(
          child: Text(
            label,
            style: TextStyle(fontSize: 16, color: config.textColor),
          ),
        ),
      ],
    );
  }

  Widget _buildUserList({
    required String title,
    required List<dynamic>? users,
    required bool isPending,
  }) {
    final config = Provider.of<ConfigProvider>(context, listen: false);

    if (users == null || users.isEmpty) return const SizedBox.shrink();

    return Card(
      color: config.secondaryColor,
      margin: const EdgeInsets.symmetric(vertical: 8),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              title,
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: config.textColor,
                fontSize: 16,
              ),
            ),
            const Divider(),
            ...users.map((u) {
              final userName = u['name'] ?? 'Sem nome';
              final userId = u['id']?.toString() ?? '';
              final userImage = u['imageUrl'];

              return ListTile(
                onTap: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (context) => ViewUserPage(
                        userId: userId,
                      ),
                    ),
                  );
                },
                leading: CircleAvatar(
                  backgroundImage: (userImage != null && userImage.isNotEmpty)
                      ? NetworkImage(userImage)
                      : null,
                  child: (userImage == null || userImage.isEmpty)
                      ? Icon(
                    Icons.person,
                    color: config.iconColor,
                  )
                      : null,
                ),
                title: Text(
                  userName,
                  style: TextStyle(color: config.textColor),
                ),
                trailing: isPending && _partyData!['ownerId'] == widget.userId
                    ? Wrap(
                  spacing: 0,
                  children: [
                    IconButton(
                      icon: Icon(Icons.check, color: config.customGreen),
                      onPressed: () => _confirmParticipation(userId),
                    ),
                    IconButton(
                      icon: Icon(Icons.close, color: config.customRed),
                      onPressed: () => _declineParticipation(userId),
                    ),
                  ],
                )
                    : null,
              );
            }).toList(),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);

    final userRole = _partyData?['userRole'] ?? '';

    final canViewSensitive = userRole == 'Hospedando' ||
        userRole == 'Confirmado' ||
        userRole == 'Convidado';

    return Scaffold(
      backgroundColor: configProvider.primaryColor,
      appBar: AppBar(
        title: const Text('Detalhes da Festa'),
        backgroundColor: configProvider.primaryColor,
        iconTheme: IconThemeData(color: configProvider.iconColor),
        actions: [
          if (!_isLoading &&
              _partyData != null &&
              _partyData!['ownerId'] == widget.userId)
            PopupMenuButton<String>(
              color: configProvider.primaryColor,
              icon: Icon(Icons.more_vert, color: configProvider.iconColor),
              onSelected: (value) {
                if (value == 'edit') {
                  _editParty();
                } else if (value == 'invite') {
                  _openInviteUsersDialog();
                } else if (value == 'delete') {
                  _deleteParty();
                }
              },
              itemBuilder: (context) => [
                PopupMenuItem(
                  value: 'edit',
                  child: Text(
                    'Editar Festa',
                    style: TextStyle(color: configProvider.textColor),
                  ),
                ),
                PopupMenuItem(
                  value: 'invite',
                  child: Text(
                    'Convidar Usuários',
                    style: TextStyle(color: configProvider.textColor),
                  ),
                ),
                PopupMenuItem(
                  value: 'delete',
                  child: Text(
                    'Excluir Festa',
                    style: TextStyle(color: configProvider.textColor),
                  ),
                ),
              ],
            )
        ],
      ),
      body: _isLoading
          ? Center(
        child: CircularProgressIndicator(color: configProvider.iconColor),
      )
          : _partyData == null
          ? Center(
        child: Text(
          'Festa não encontrada',
          style: TextStyle(color: configProvider.textColor),
        ),
      )
          : SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            if (_partyData!['coverImageUrl'] != null &&
                _partyData!['coverImageUrl'].toString().isNotEmpty &&
                !configProvider.hideImages)
              ClipRRect(
                borderRadius: BorderRadius.circular(12),
                child: Image.network(_partyData!['coverImageUrl']),
              ),
            const SizedBox(height: 16),

            Card(
              color: configProvider.secondaryColor,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      _partyData!['title'] ?? '',
                      style: TextStyle(
                        fontSize: 20,
                        fontWeight: FontWeight.bold,
                        color: configProvider.textColor,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      _partyData!['description'] ?? '',
                      style: TextStyle(
                        fontSize: 16,
                        color: configProvider.textColor,
                      ),
                    ),
                    const SizedBox(height: 8),

                    if (canViewSensitive) ...[
                      const Divider(height: 24),
                      _buildInfoRow(
                        icon: Icons.category,
                        label: 'Tipo: ${_mapType(_partyData!['type'])}',
                        config: configProvider,
                      ),
                      const SizedBox(height: 8),
                      _buildInfoRow(
                        icon: Icons.location_pin,
                        label: 'Local: ${_partyData!['location']}',
                        config: configProvider,
                      ),
                      const SizedBox(height: 8),
                      _buildInfoRow(
                        icon: Icons.info_outline,
                        label:
                        'Instruções: ${_partyData!['instructions']}',
                        config: configProvider,
                      ),
                    ],

                    const SizedBox(height: 8),
                    _buildInfoRow(
                      icon: Icons.group,
                      label:
                      'Convidados: ${_partyData!['invitedCount']}',
                      config: configProvider,
                    ),
                    const SizedBox(height: 8),
                    _buildInfoRow(
                      icon: Icons.check_circle_outline,
                      label:
                      'Confirmados: ${_partyData!['confirmedCount']}',
                      config: configProvider,
                    ),
                  ],
                ),
              ),
            ),

            const SizedBox(height: 16),

            if (canViewSensitive)
              ElevatedButton(
                style: ElevatedButton.styleFrom(
                  backgroundColor: configProvider.secondaryColor,
                ),
                onPressed: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (_) => PartyChatPage(
                        partyId: widget.partyId,
                        userId: widget.userId,
                      ),
                    ),
                  );
                },
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(Icons.chat, color: configProvider.iconColor),
                    const SizedBox(width: 8),
                    Text(
                      'Abrir Chat',
                      style: TextStyle(color: configProvider.iconColor),
                    ),
                  ],
                ),
              ),

            const SizedBox(height: 16),

            if (!canViewSensitive &&
                _partyData!['ownerId'] != widget.userId &&
                _partyData!['userRole'] == 'Disponível para Participar')
              ElevatedButton(
                style: ElevatedButton.styleFrom(
                  backgroundColor: configProvider.secondaryColor,
                ),
                onPressed: _requestParticipation,
                child: _loadingRequest
                    ? const CircularProgressIndicator()
                    : const Text('Solicitar Participação'),
              ),

            if (canViewSensitive)
              FutureBuilder(
                future: ApiService.getAllParticipants(
                  widget.partyId,
                  widget.userId,
                ),
                builder: (context, snapshot) {
                  if (snapshot.connectionState ==
                      ConnectionState.waiting) {
                    return const CircularProgressIndicator();
                  }
                  if (snapshot.data == null) {
                    return Text(
                      "Erro ao carregar participantes",
                      style: TextStyle(color: configProvider.textColor),
                    );
                  }
                  final data = snapshot.data!;
                  final confirmeds =
                  data['confirmeds'] as List<dynamic>?;
                  final inviteds = data['inviteds'] as List<dynamic>?;

                  return Column(
                    children: [
                      _buildUserList(
                        title: "Confirmados",
                        users: confirmeds,
                        isPending: false,
                      ),
                      if (_partyData!['ownerId'] == widget.userId)
                        _buildUserList(
                          title: "Convidados (Pendentes)",
                          users: inviteds,
                          isPending: true,
                        ),
                    ],
                  );
                },
              ),
          ],
        ),
      ),
    );
  }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\places\create_edit_place_page.dart ===
import 'dart:convert';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:geolocator/geolocator.dart';
import 'package:image_picker/image_picker.dart';
import 'package:provider/provider.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/services/api_service.dart';
import 'package:snarf/services/location_service.dart';
import 'package:snarf/utils/show_snackbar.dart';

class CreateEditPlacePage extends StatefulWidget {
  final String? placeId;

  const CreateEditPlacePage({Key? key, this.placeId}) : super(key: key);

  @override
  State<CreateEditPlacePage> createState() => _CreateEditPlacePageState();
}

class _CreateEditPlacePageState extends State<CreateEditPlacePage> {
  final _formKey = GlobalKey<FormState>();
  final _locationService = LocationService();
  late TextEditingController _titleController;
  late TextEditingController _descController;

  double? _latitude;
  double? _longitude;

  File? _imageFile;
  String? _base64Image;
  bool _isLoading = false;

  late Position _location;

  int _selectedType = 0;

  final List<Map<String, dynamic>> _placeTypes = [
    {'value': 0, 'label': 'Academia'},
    {'value': 1, 'label': 'Banheiro'},
    {'value': 2, 'label': 'Bar/Clube'},
    {'value': 3, 'label': 'Café/Restaurante'},
    {'value': 4, 'label': 'Duchas/Sauna'},
    {'value': 5, 'label': 'Evento Recorrente'},
    {'value': 6, 'label': 'Fliperama/Teatro'},
    {'value': 7, 'label': 'Hotel/Resort'},
    {'value': 8, 'label': 'Outro'},
    {'value': 9, 'label': 'Parada de Caminhões'},
    {'value': 10, 'label': 'Parque'},
    {'value': 11, 'label': 'Praia de Nudismo'},
    {'value': 12, 'label': 'Sauna'},
  ];

  @override
  void initState() {
    super.initState();
    _titleController = TextEditingController();
    _descController = TextEditingController();

    if (widget.placeId != null) {
      _loadPlace(widget.placeId!);
    }

    _obterLocalizacao();
  }

  Future<void> _loadPlace(String placeId) async {
    setState(() => _isLoading = true);
    final data = await ApiService.getPlaceDetails(placeId);
    setState(() => _isLoading = false);

    if (data == null) {
      showErrorSnackbar(context, 'Erro ao carregar informações do local');
      Navigator.pop(context);
      return;
    }
    setState(() {
      _titleController.text = data['title'] ?? '';
      _descController.text = data['description'] ?? '';
      _latitude = data['latitude']?.toDouble() ?? 0.0;
      _longitude = data['longitude']?.toDouble() ?? 0.0;
      _selectedType = data['type'] ?? 0;
    });
  }

  Future<void> _obterLocalizacao() async {
    final ok = await _locationService.initialize();
    if (ok) {
      final loc = await _locationService.getCurrentLocation();
      setState(() {
        _latitude = loc.latitude;
        _longitude = loc.longitude;
      });
      _locationService.onLocationChanged.listen((loc) {
        setState(() {
          _latitude = loc.latitude;
          _longitude = loc.longitude;
        });
      });
    }
  }

  Future<void> _pickImage() async {
    final picker = ImagePicker();
    final pickedFile = await picker.pickImage(source: ImageSource.gallery);
    if (pickedFile == null) return;

    _imageFile = File(pickedFile.path);
    final bytes = await _imageFile!.readAsBytes();
    _base64Image = base64Encode(bytes);
    setState(() {});
  }

  Future<void> _onSave() async {
    if (!_formKey.currentState!.validate()) return;
    final userId = await ApiService.getUserIdFromToken();
    if (userId == null) {
      showErrorSnackbar(context, 'Usuário não logado');
      return;
    }

    setState(() => _isLoading = true);

    if (widget.placeId == null) {
      final created = await ApiService.createPlace(
        title: _titleController.text,
        description: _descController.text,
        latitude: _latitude ?? 0.0,
        longitude: _longitude ?? 0.0,
        coverImageBase64: _base64Image ?? '',
        type: _selectedType,
      );
      setState(() => _isLoading = false);
      if (created) {
        Navigator.pop(context, true);
      } else {
        showErrorSnackbar(context, 'Erro ao criar local');
      }
      return;
    }

    final updated = await ApiService.updatePlace(
      placeId: widget.placeId!,
      title: _titleController.text,
      description: _descController.text,
      latitude: _latitude ?? 0.0,
      longitude: _longitude ?? 0.0,
      coverImageBase64: _base64Image,
      type: _selectedType,
    );
    setState(() => _isLoading = false);
    if (updated) {
      Navigator.pop(context, true);
    } else {
      showErrorSnackbar(context, 'Erro ao atualizar local');
    }
  }

  @override
  Widget build(BuildContext context) {
    final config = Provider.of<ConfigProvider>(context);
    return Scaffold(
      backgroundColor: config.primaryColor,
      appBar: AppBar(
        backgroundColor: config.primaryColor,
        iconTheme: IconThemeData(color: config.iconColor),
        title: Text(
          widget.placeId == null ? 'Criar Local' : 'Editar Local',
          style: TextStyle(color: config.textColor),
        ),
      ),
      body: Stack(
        children: [
          if (_isLoading)
            Center(child: CircularProgressIndicator(color: config.iconColor))
          else
            SingleChildScrollView(
              padding: const EdgeInsets.all(16),
              child: Form(
                key: _formKey,
                child: Column(
                  children: [
                    GestureDetector(
                      onTap: _pickImage,
                      child: Column(
                        children: [
                          _imageFile == null
                              ? Container(
                                  width: 120,
                                  height: 120,
                                  decoration: BoxDecoration(
                                    color:
                                        config.secondaryColor.withOpacity(0.2),
                                    shape: BoxShape.circle,
                                  ),
                                  child: Icon(Icons.camera_alt,
                                      size: 40, color: config.iconColor),
                                )
                              : CircleAvatar(
                                  radius: 60,
                                  backgroundImage: FileImage(_imageFile!),
                                ),
                          const SizedBox(height: 8),
                          Text(
                            _imageFile == null
                                ? 'Adicionar Imagem'
                                : 'Alterar Imagem',
                            style: TextStyle(color: config.textColor),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(height: 20),
                    TextFormField(
                      controller: _titleController,
                      decoration: InputDecoration(
                        labelText: 'Título',
                        hintText: 'Ex: Banheiro do Shopping X',
                        prefixIcon: Icon(Icons.title, color: config.iconColor),
                        labelStyle: TextStyle(color: config.textColor),
                        hintStyle: TextStyle(
                          color: config.textColor.withOpacity(0.5),
                        ),
                        filled: true,
                        fillColor: config.secondaryColor.withOpacity(0.1),
                      ),
                      style: TextStyle(color: config.textColor),
                      textInputAction: TextInputAction.next,
                      validator: (val) => val == null || val.isEmpty
                          ? 'Informe o título'
                          : null,
                    ),
                    const SizedBox(height: 16),
                    TextFormField(
                      controller: _descController,
                      decoration: InputDecoration(
                        labelText: 'Descrição',
                        hintText: 'Descreva este lugar',
                        prefixIcon:
                            Icon(Icons.description, color: config.iconColor),
                        labelStyle: TextStyle(color: config.textColor),
                        hintStyle:
                            TextStyle(color: config.textColor.withOpacity(0.5)),
                        filled: true,
                        fillColor: config.secondaryColor.withOpacity(0.1),
                      ),
                      maxLines: 3,
                      style: TextStyle(color: config.textColor),
                      textInputAction: TextInputAction.next,
                      validator: (val) => val == null || val.isEmpty
                          ? 'Informe a descrição'
                          : null,
                    ),
                    const SizedBox(height: 16),
                    Container(
                      width: double.infinity,
                      padding: const EdgeInsets.symmetric(
                          vertical: 8, horizontal: 12),
                      decoration: BoxDecoration(
                        color: config.secondaryColor.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            "Selecione o tipo de local:",
                            style: TextStyle(
                              color: config.textColor,
                              fontWeight: FontWeight.bold,
                              fontSize: 16,
                            ),
                          ),
                          const SizedBox(height: 8),
                          ..._placeTypes.map((pt) {
                            return RadioListTile<int>(
                              title: Text(
                                pt['label'] as String,
                                style: TextStyle(color: config.textColor),
                              ),
                              activeColor: config.iconColor,
                              value: pt['value'] as int,
                              groupValue: _selectedType,
                              onChanged: (val) {
                                setState(() {
                                  _selectedType = val ?? 0;
                                });
                              },
                            );
                          }),
                        ],
                      ),
                    ),
                    const SizedBox(height: 16),
                    ElevatedButton(
                      onPressed: _onSave,
                      child: Text(
                        widget.placeId == null
                            ? 'Criar Local'
                            : 'Salvar Alterações',
                      ),
                    ),
                  ],
                ),
              ),
            ),
        ],
      ),
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\places\place_chat_page.dart ===
import 'dart:convert';
import 'dart:developer';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/pages/account/view_user_page.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/services/api_service.dart';
import 'package:snarf/services/signalr_manager.dart';
import 'package:snarf/utils/date_utils.dart';
import 'package:snarf/enums/signalr_event_type.dart';

class PlaceChatPage extends StatefulWidget {
  final String placeId;

  const PlaceChatPage({super.key, required this.placeId});

  @override
  State<PlaceChatPage> createState() => _PlaceChatPageState();
}

class _PlaceChatPageState extends State<PlaceChatPage> {
  final TextEditingController _messageController = TextEditingController();
  final List<Map<String, dynamic>> _messages = [];
  final ScrollController _scrollController = ScrollController();
  bool _isLoading = true;
  String? _userId;

  @override
  void initState() {
    super.initState();
    _initChat();
  }

  Future<void> _initChat() async {
    _userId = await ApiService.getUserIdFromToken();
    SignalRManager().listenToEvent(
      'ReceiveMessage',
      _onReceivePlaceChatMessage,
    );

    await SignalRManager().sendSignalRMessage(
      SignalREventType.PlaceChatGetPreviousMessages,
      {"PlaceId": widget.placeId},
    );

    setState(() => _isLoading = false);
  }

  void _onReceivePlaceChatMessage(List<Object?>? args) {
    if (args == null || args.isEmpty) return;
    try {
      final Map<String, dynamic> msg = jsonDecode(args[0] as String);
      final String eventType = msg["Type"];
      if (eventType == "PlaceChatReceiveMessage") {
        final data = msg["Data"];
        setState(() {
          _messages.add({
            'id': data['Id'],
            'createdAt': DateTime.parse(data['CreatedAt']).toLocal(),
            'userId': data['UserId'],
            'userName': data['UserName'],
            'userImage': data['UserImage'],
            'message': data['Message'],
            'isImage': data['Message'].toString().startsWith('https://'),
          });
        });
        _scrollToBottom();
      } else if (eventType == "PlaceChatReceiveMessageDeleted") {
        final data = msg["Data"];
        final messageId = data['MessageId'];
        final index = _messages.indexWhere((m) => m['id'] == messageId);
        if (index != -1) {
          setState(() {
            _messages[index]['message'] = 'Mensagem excluída';
          });
        }
      }
    } catch (e) {
      log("Erro ao processar mensagem: $e");
    }
  }

  void _scrollToBottom() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_scrollController.hasClients) {
        _scrollController.animateTo(
          _scrollController.position.maxScrollExtent,
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeOut,
        );
      }
    });
  }

  Future<void> _sendMessage() async {
    final text = _messageController.text.trim();
    if (text.isEmpty) return;
    await SignalRManager().sendSignalRMessage(
      SignalREventType.PlaceChatSendMessage,
      {"PlaceId": widget.placeId, "Message": text},
    );
    _messageController.clear();
    _scrollToBottom();
  }

  Future<void> _deleteMessage(String messageId) async {
    await SignalRManager().sendSignalRMessage(
      SignalREventType.PlaceChatDeleteMessage,
      {"PlaceId": widget.placeId, "MessageId": messageId},
    );
  }

  Widget _buildMessageItem(Map<String, dynamic> msg) {
    final config = Provider.of<ConfigProvider>(context, listen: false);
    final bool isMine = (msg['userId'] == _userId);
    final String text = msg['message'] ?? '';
    final bool isDeleted = (text == 'Mensagem excluída');

    // Pega a data de criação e converte para "Há x tempo" via DateJSONUtils
    final DateTime createdAt = msg['createdAt'] ?? DateTime.now();
    final String relativeTime =
        DateJSONUtils.formatRelativeTime(createdAt.toString());

    if (isMine) {
      // Mensagem do usuário atual
      return Column(
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          // Texto "Há x tempo" acima do bubble
          Padding(
            padding: const EdgeInsets.only(right: 12, top: 8, bottom: 2),
            child: Text(
              relativeTime,
              style: TextStyle(
                fontSize: 10,
                fontStyle: FontStyle.italic,
                color: config.textColor,
              ),
            ),
          ),
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              Flexible(
                child: Container(
                  margin:
                      const EdgeInsets.symmetric(vertical: 18, horizontal: 8),
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: config.secondaryColor,
                    borderRadius: const BorderRadius.only(
                      topLeft: Radius.circular(12),
                      topRight: Radius.circular(12),
                      bottomLeft: Radius.circular(12),
                    ),
                  ),
                  child: Text(
                    text,
                    style: TextStyle(color: config.textColor),
                  ),
                ),
              ),
              if (!isDeleted)
                IconButton(
                  icon: Icon(
                    Icons.delete,
                    size: 18,
                    color: config.iconColor,
                  ),
                  onPressed: () => _deleteMessage(msg['id']),
                ),
            ],
          ),
        ],
      );
    } else {
      // Mensagem de outro usuário
      return Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Coloca a data/hora acima da foto do usuário
          Padding(
            padding: const EdgeInsets.only(left: 8, right: 8),
            child: Column(
              children: [
                Text(
                  relativeTime,
                  style: TextStyle(
                    fontSize: 10,
                    fontStyle: FontStyle.italic,
                    color: config.textColor,
                  ),
                ),
                const SizedBox(height: 4),
                GestureDetector(
                  onTap: () {
                    final userId = msg['userId'];
                    if (userId == null) return;
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => ViewUserPage(userId: userId),
                      ),
                    );
                  },
                  child: Container(
                    width: 40,
                    height: 40,
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(20),
                      image: (msg['userImage'] != null &&
                              msg['userImage'].toString().isNotEmpty)
                          ? DecorationImage(
                              image: NetworkImage(msg['userImage']),
                              fit: BoxFit.cover,
                            )
                          : null,
                    ),
                    child: (msg['userImage'] == null ||
                            msg['userImage'].toString().isEmpty)
                        ? Icon(Icons.person, color: config.iconColor)
                        : null,
                  ),
                ),
              ],
            ),
          ),
          Flexible(
            child: Container(
              margin: const EdgeInsets.symmetric(vertical: 18),
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: config.secondaryColor,
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(12),
                  topRight: Radius.circular(12),
                  bottomRight: Radius.circular(12),
                ),
              ),
              child: Text(
                text,
                style: TextStyle(color: config.textColor),
              ),
            ),
          ),
        ],
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final config = Provider.of<ConfigProvider>(context);
    return Scaffold(
      appBar: AppBar(
        backgroundColor: config.primaryColor,
        iconTheme: IconThemeData(color: config.iconColor),
        title: Text(
          'Chat do Lugar',
          style: TextStyle(color: config.textColor),
        ),
      ),
      backgroundColor: config.primaryColor,
      body: _isLoading
          ? Center(child: CircularProgressIndicator(color: config.iconColor))
          : Column(
              children: [
                Expanded(
                  child: ListView.builder(
                    controller: _scrollController,
                    itemCount: _messages.length,
                    itemBuilder: (ctx, i) => _buildMessageItem(_messages[i]),
                  ),
                ),
                Padding(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 8, vertical: 10),
                  child: Row(
                    children: [
                      Expanded(
                        child: TextField(
                          controller: _messageController,
                          style: TextStyle(color: config.textColor),
                          decoration: InputDecoration(
                            hintText: "Digite sua mensagem",
                            hintStyle: TextStyle(
                              color: config.textColor.withOpacity(0.6),
                            ),
                            filled: true,
                            fillColor: config.secondaryColor.withOpacity(0.1),
                            border: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(30),
                              borderSide:
                                  BorderSide(color: config.secondaryColor),
                            ),
                            enabledBorder: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(30),
                              borderSide:
                                  BorderSide(color: config.secondaryColor),
                            ),
                          ),
                        ),
                      ),
                      IconButton(
                        icon: Icon(Icons.send, color: config.iconColor),
                        onPressed: _sendMessage,
                      ),
                    ],
                  ),
                ),
              ],
            ),
    );
  }

  @override
  void dispose() {
    _messageController.dispose();
    _scrollController.dispose();
    super.dispose();
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\places\place_details_page.dart ===
import 'dart:convert';
import 'dart:developer';

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/pages/places/place_chat_page.dart';
import 'package:snarf/pages/account/view_user_page.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/services/api_service.dart';
import 'package:snarf/utils/show_snackbar.dart';

class PlaceDetailsPage extends StatefulWidget {
  final String placeId;

  const PlaceDetailsPage({super.key, required this.placeId});

  @override
  State<PlaceDetailsPage> createState() => _PlaceDetailsPageState();
}

class _PlaceDetailsPageState extends State<PlaceDetailsPage> {
  Map<String, dynamic>? _placeData;
  bool _isLoading = true;

  Map<String, dynamic>? _visitorsData;
  bool _isLoadingVisitors = true;

  @override
  void initState() {
    super.initState();
    _loadPlaceDetails();
  }

  Future<void> _loadPlaceDetails() async {
    final data = await ApiService.getPlaceDetails(widget.placeId);
    if (!mounted) return;

    if (data == null) {
      showErrorSnackbar(context, 'Não foi possível carregar detalhes do lugar');
      Navigator.pop(context);
      return;
    }

    setState(() {
      _placeData = data;
      _isLoading = false;
    });

    _loadVisitorsAndStats();
  }

  Future<void> _loadVisitorsAndStats() async {
    setState(() => _isLoadingVisitors = true);

    final result = await ApiService.getPlaceVisitorsAndStats(widget.placeId);
    if (!mounted) return;

    setState(() {
      _visitorsData = result!['object'];
      _isLoadingVisitors = false;
    });
  }

  Future<void> _signalRemovePlace() async {
    final bool confirmar = await showDialog<bool>(
          context: context,
          builder: (ctx) => AlertDialog(
            title: const Text('Sinalizar para Remoção'),
            content: const Text(
                'Tem certeza que deseja sinalizar este lugar para remoção?'),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(ctx).pop(false),
                child: const Text('Cancelar'),
              ),
              TextButton(
                onPressed: () => Navigator.of(ctx).pop(true),
                child: const Text('Confirmar'),
              ),
            ],
          ),
        ) ??
        false;

    if (!confirmar) return;

    final success = await ApiService.signalToRemovePlace(widget.placeId);
    if (!mounted) return;

    if (success) {
      showSuccessSnackbar(
          context, 'Lugar sinalizado para remoção com sucesso!');
    } else {
      showErrorSnackbar(context, 'Falha ao sinalizar para remoção.');
    }
  }

  String _mapPlaceType(int type) {
    switch (type) {
      case 0:
        return 'Academia';
      case 1:
        return 'Banheiro';
      case 2:
        return 'Bar/Clube';
      case 3:
        return 'Café/Restaurante';
      case 4:
        return 'Duchas/Sauna';
      case 5:
        return 'Evento Recorrente';
      case 6:
        return 'Fliperama/Teatro';
      case 7:
        return 'Hotel/Resort';
      case 8:
        return 'Outro';
      case 9:
        return 'Parada de Caminhões';
      case 10:
        return 'Parque';
      case 11:
        return 'Praia de Nudismo';
      case 12:
        return 'Sauna';
      default:
        return 'Desconhecido';
    }
  }

  Widget _buildInfoRow({
    required IconData icon,
    required String label,
    required ConfigProvider config,
  }) {
    return Row(
      children: [
        Icon(icon, color: config.iconColor),
        const SizedBox(width: 8),
        Expanded(
          child: Text(
            label,
            style: TextStyle(fontSize: 16, color: config.textColor),
          ),
        ),
      ],
    );
  }

  Widget _buildVisitorsList({
    required List<dynamic> visitors,
    required ConfigProvider config,
  }) {
    if (visitors.isEmpty) {
      return const SizedBox.shrink();
    }

    return Card(
      color: config.secondaryColor,
      margin: const EdgeInsets.only(top: 16),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              "Usuários no Local",
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: config.textColor,
                fontSize: 16,
              ),
            ),
            const Divider(),
            ...visitors.map((u) {
              final userId = u['id']?.toString() ?? '';
              final userName = u['name'] ?? 'Sem nome';
              final userImage = u['imageUrl'] ?? '';

              return ListTile(
                onTap: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (_) => ViewUserPage(userId: userId),
                    ),
                  );
                },
                leading: CircleAvatar(
                  backgroundImage:
                      (userImage.isNotEmpty) ? NetworkImage(userImage) : null,
                  child: (userImage.isEmpty)
                      ? Icon(Icons.person, color: config.iconColor)
                      : null,
                ),
                title: Text(
                  userName,
                  style: TextStyle(color: config.textColor),
                ),
              );
            }).toList(),
          ],
        ),
      ),
    );
  }

  Widget _buildPlaceStats(ConfigProvider config) {
    if (_visitorsData == null) return const SizedBox.shrink();

    final avg = _visitorsData!['averageStayMinutes'] ?? 0.0;
    final last7 = _visitorsData!['visitsLast7Days'] ?? 0;

    return Card(
      color: config.secondaryColor,
      margin: const EdgeInsets.only(top: 16),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              "Estatísticas do Local",
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: config.textColor,
                fontSize: 16,
              ),
            ),
            const Divider(),
            _buildInfoRow(
              icon: Icons.timer,
              label: 'Média de Permanência: ${avg.toStringAsFixed(1)} min',
              config: config,
            ),
            const SizedBox(height: 8),
            _buildInfoRow(
              icon: Icons.bar_chart,
              label: 'Visitas (últimos 7 dias): $last7',
              config: config,
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final config = Provider.of<ConfigProvider>(context);

    return Scaffold(
      backgroundColor: config.primaryColor,
      appBar: AppBar(
        backgroundColor: config.primaryColor,
        iconTheme: IconThemeData(color: config.iconColor),
        title: Text(
          'Detalhes do Lugar',
          style: TextStyle(color: config.textColor),
        ),
      ),
      body: _isLoading
          ? Center(
              child: CircularProgressIndicator(color: config.iconColor),
            )
          : _placeData == null
              ? Center(
                  child: Text(
                    'Lugar não encontrado',
                    style: TextStyle(color: config.textColor),
                  ),
                )
              : SingleChildScrollView(
                  padding: const EdgeInsets.all(16),
                  child: Column(
                    children: [
                      if (_placeData!['coverImageUrl'] != null &&
                          _placeData!['coverImageUrl'].toString().isNotEmpty &&
                          !config.hideImages)
                        ClipRRect(
                          borderRadius: BorderRadius.circular(12),
                          child: Image.network(_placeData!['coverImageUrl']),
                        ),
                      const SizedBox(height: 16),
                      Card(
                        color: config.secondaryColor,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: Padding(
                          padding: const EdgeInsets.all(16),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                _placeData!['title'] ?? '',
                                style: TextStyle(
                                  fontSize: 20,
                                  fontWeight: FontWeight.bold,
                                  color: config.textColor,
                                ),
                              ),
                              const SizedBox(height: 8),
                              Text(
                                _placeData!['description'] ?? '',
                                style: TextStyle(
                                  fontSize: 16,
                                  color: config.textColor,
                                ),
                              ),
                              const SizedBox(height: 8),
                              const Divider(),
                              const SizedBox(height: 8),
                              if (_placeData!.containsKey('type'))
                                _buildInfoRow(
                                  icon: Icons.info_outline,
                                  label:
                                      'Tipo: ${_mapPlaceType(_placeData!['type'])}',
                                  config: config,
                                ),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 16),
                      ElevatedButton(
                        style: ElevatedButton.styleFrom(
                          backgroundColor: config.secondaryColor,
                        ),
                        onPressed: () {
                          Navigator.push(
                            context,
                            MaterialPageRoute(
                              builder: (_) =>
                                  PlaceChatPage(placeId: widget.placeId),
                            ),
                          );
                        },
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Icon(Icons.chat, color: config.iconColor),
                            const SizedBox(width: 8),
                            Text(
                              'Abrir Chat',
                              style: TextStyle(color: config.iconColor),
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(height: 16),
                      ElevatedButton.icon(
                        style: ElevatedButton.styleFrom(
                          backgroundColor: config.secondaryColor,
                        ),
                        onPressed: _signalRemovePlace,
                        icon:
                            Icon(Icons.delete_outline, color: config.iconColor),
                        label: Text(
                          'Sinalizar para Remoção',
                          style: TextStyle(color: config.iconColor),
                        ),
                      ),
                      if (_isLoadingVisitors)
                        Padding(
                          padding: const EdgeInsets.all(16),
                          child: CircularProgressIndicator(
                            color: config.iconColor,
                          ),
                        )
                      else ...[
                        if (_visitorsData != null &&
                            _visitorsData!['currentVisitors'] != null)
                          _buildVisitorsList(
                            visitors: List<Map<String, dynamic>>.from(
                              _visitorsData!['currentVisitors'] as List,
                            ),
                            config: config,
                          ),
                        if (_visitorsData != null) _buildPlaceStats(config),
                      ],
                    ],
                  ),
                ),
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\privateChat\parties_page.dart ===
import 'dart:convert';
import 'dart:developer';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/pages/parties/create_edit_party_page.dart';
import 'package:snarf/pages/parties/party_details_page.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/services/api_service.dart';
import 'package:snarf/services/signalr_manager.dart';
import 'package:snarf/utils/show_snackbar.dart';
import 'package:snarf/enums/signalr_event_type.dart';

class PartiesPage extends StatefulWidget {
  const PartiesPage({super.key});

  @override
  State<PartiesPage> createState() => _PartiesPageState();
}

class _PartiesPageState extends State<PartiesPage> {
  bool _isLoading = false;
  List<dynamic> _parties = [];
  String? userId;

  List<Map<String, dynamic>> _recentChats = [];
  bool _isLoadingRecentChats = false;

  @override
  void initState() {
    super.initState();
    _fetchAllParties();
    SignalRManager().listenToEvent('ReceiveMessage', _handleSignalRMessage);
  }

  Future<void> _fetchAllParties() async {
    userId = await ApiService.getUserIdFromToken();
    if (userId == null) {
      showErrorSnackbar(context, 'Usuário não logado');
      return;
    }

    setState(() => _isLoading = true);
    final data = await ApiService.getAllParties(userId!);
    setState(() => _isLoading = false);

    if (data == null) {
      showErrorSnackbar(context, 'Erro ao buscar festas');
      return;
    }

    _parties = data["data"] ?? [];
    setState(() {});
  }

  Future<void> _loadRecentChats() async {
    setState(() => _isLoadingRecentChats = true);
    await SignalRManager().sendSignalRMessage(
      SignalREventType.PrivateChatGetRecentChats,
      {},
    );
    await Future.delayed(const Duration(milliseconds: 500));
    setState(() => _isLoadingRecentChats = false);
  }

  void _handleSignalRMessage(List<Object?>? args) {
    if (args == null || args.isEmpty) return;

    try {
      final Map<String, dynamic> message = jsonDecode(args[0] as String);
      final SignalREventType type = SignalREventType.values.firstWhere(
        (e) => e.toString().split('.').last == message['Type'],
      );
      final dynamic data = message['Data'];

      switch (type) {
        case SignalREventType.PrivateChatReceiveRecentChats:
          _handleRecentChats(data);
          break;
        case SignalREventType.PrivateChatReceiveFavorites:
        case SignalREventType.PrivateChatReceiveMessage:
        case SignalREventType.MapReceiveLocation:
        case SignalREventType.UserDisconnected:
          break;
        default:
          log("Evento não reconhecido: ${message['Type']}");
      }
    } catch (e) {
      log("Erro ao processar mensagem SignalR: $e");
    }
  }

  void _handleRecentChats(dynamic data) {
    try {
      final parsedData = data as List<dynamic>;
      setState(() {
        _recentChats = parsedData.map((item) {
          final mapItem = item is Map<String, dynamic>
              ? item
              : Map<String, dynamic>.from(item);

          return {
            'UserId': mapItem['UserId'],
            'UserName': mapItem['UserName'],
            'UserImage': mapItem['UserImage'],
            'LastMessage': mapItem['LastMessage'],
            'LastMessageDate': mapItem['LastMessageDate'],
            'UnreadCount': mapItem['UnreadCount'],
          };
        }).toList();
      });
    } catch (e) {
      showErrorSnackbar(context, "Erro ao processar chats recentes: $e");
    }
  }

  Future<void> _openInviteUsersDialog(String partyId) async {
    await _loadRecentChats();
    if (!mounted) return;
    if (_recentChats.isEmpty) {
      showErrorSnackbar(context, "Nenhum chat recente encontrado.");
      return;
    }
    final List<String> selectedUserIds = [];
    await showDialog(
      context: context,
      builder: (BuildContext dialogCtx) {
        return StatefulBuilder(
          builder: (context, setStateDialog) {
            if (_isLoadingRecentChats) {
              return AlertDialog(
                title: const Text('Convidar Usuários'),
                content: const SizedBox(
                  height: 80,
                  child: Center(child: CircularProgressIndicator()),
                ),
              );
            }
            return AlertDialog(
              title: const Text('Convidar Usuários'),
              content: SizedBox(
                width: double.maxFinite,
                height: 300,
                child: ListView.builder(
                  itemCount: _recentChats.length,
                  itemBuilder: (context, index) {
                    final chat = _recentChats[index];
                    final uid = chat['UserId'].toString();
                    final name = chat['UserName'] ?? 'Sem nome';
                    final isSelected = selectedUserIds.contains(uid);
                    return CheckboxListTile(
                      title: Text(name),
                      value: isSelected,
                      onChanged: (bool? checked) {
                        setStateDialog(() {
                          if (checked == true) {
                            selectedUserIds.add(uid);
                          } else {
                            selectedUserIds.remove(uid);
                          }
                        });
                      },
                    );
                  },
                ),
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(dialogCtx),
                  child: const Text('Cancelar'),
                ),
                ElevatedButton(
                  onPressed: selectedUserIds.isEmpty
                      ? null
                      : () async {
                          for (final uid in selectedUserIds) {
                            final success =
                                await ApiService.requestPartyParticipation(
                              partyId: partyId,
                              userId: uid,
                            );
                            if (success) {
                              showSuccessSnackbar(
                                  context, "Convite enviado para $uid");
                            } else {
                              showErrorSnackbar(
                                  context, "Erro ao convidar $uid");
                            }
                          }
                          if (!mounted) return;
                          Navigator.pop(dialogCtx);
                        },
                  child: const Text('Convidar'),
                ),
              ],
            );
          },
        );
      },
    );
  }

  Future<void> _deleteParty(String partyId) async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Excluir Festa'),
        content: const Text('Tem certeza que deseja excluir esta festa?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx, false),
            child: const Text('Cancelar'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(ctx, true),
            child: const Text('Excluir'),
          ),
        ],
      ),
    );
    if (confirm != true) return;
    final result = await ApiService.deleteParty(partyId, userId!);
    if (result) {
      showSuccessSnackbar(context, 'Festa excluída com sucesso!');
      _fetchAllParties();
    } else {
      showErrorSnackbar(context, 'Erro ao excluir festa');
    }
  }

  Future<void> _acceptInvite(String partyId) async {
    final success = await ApiService.confirmUser(partyId, userId!);
    if (success) {
      showSuccessSnackbar(context, 'Convite aceito!');
      _fetchAllParties();
    } else {
      showErrorSnackbar(context, 'Erro ao aceitar convite');
    }
  }

  Future<void> _declineInvite(String partyId) async {
    final success = await ApiService.declineUser(partyId, userId!);
    if (success) {
      showSuccessSnackbar(context, 'Convite recusado!');
      _fetchAllParties();
    } else {
      showErrorSnackbar(context, 'Erro ao recusar');
    }
  }

  Future<void> _requestParticipation(String partyId) async {
    final success = await ApiService.requestPartyParticipation(
      partyId: partyId,
      userId: userId!,
    );
    if (success) {
      showSuccessSnackbar(context, 'Solicitação enviada!');
      _fetchAllParties();
    } else {
      showErrorSnackbar(context, 'Erro ao solicitar participação');
    }
  }

  Widget _buildPartyItem(dynamic party) {
    final configProvider = Provider.of<ConfigProvider>(context, listen: false);
    final partyId = party["id"].toString();
    final title = party["title"] ?? '';
    final userRole = party["userRole"] ?? '';
    final imageUrl = party["imageUrl"] as String? ?? '';
    return Card(
      color: configProvider.secondaryColor,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      margin: const EdgeInsets.symmetric(vertical: 6, horizontal: 8),
      child: ListTile(
        leading: (imageUrl.isNotEmpty)
            ? ClipRRect(
                borderRadius: BorderRadius.circular(8),
                child: Image.network(
                  imageUrl,
                  width: 50,
                  height: 50,
                  fit: BoxFit.cover,
                ),
              )
            : Icon(Icons.event, color: configProvider.iconColor),
        title: Text(
          title,
          style: TextStyle(
            color: configProvider.textColor,
            fontWeight: FontWeight.bold,
          ),
        ),
        subtitle: Text(
          userRole,
          style: TextStyle(color: configProvider.textColor),
        ),
        trailing: _buildTrailingActions(party),
        onTap: () {
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (_) => PartyDetailsPage(
                partyId: partyId,
                userId: userId!,
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildTrailingActions(dynamic party) {
    final configProvider = Provider.of<ConfigProvider>(context, listen: false);
    final partyId = party["id"].toString();
    final userRole = party["userRole"] ?? '';
    switch (userRole) {
      case 'Hospedando':
        return PopupMenuButton<String>(
          color: configProvider.primaryColor,
          icon: Icon(Icons.more_vert, color: configProvider.iconColor),
          onSelected: (value) {
            if (value == 'invite') {
              _openInviteUsersDialog(partyId);
            } else if (value == 'delete') {
              _deleteParty(partyId);
            }
          },
          itemBuilder: (ctx) => [
            PopupMenuItem(
              value: 'invite',
              child: Text(
                'Convidar Usuários',
                style: TextStyle(color: configProvider.textColor),
              ),
            ),
            PopupMenuItem(
              value: 'delete',
              child: Text(
                'Excluir Festa',
                style: TextStyle(color: configProvider.textColor),
              ),
            ),
          ],
        );
      case 'Convidado':
        return Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            IconButton(
              icon: Icon(Icons.check, color: configProvider.iconColor),
              tooltip: 'Aceitar',
              onPressed: () => _acceptInvite(partyId),
            ),
            IconButton(
              icon: Icon(Icons.close, color: configProvider.iconColor),
              tooltip: 'Recusar',
              onPressed: () => _declineInvite(partyId),
            ),
          ],
        );
      case 'Solicitante':
        return IconButton(
          icon: Icon(Icons.close, color: configProvider.iconColor),
          tooltip: 'Cancelar solicitação',
          onPressed: () => _declineInvite(partyId),
        );
      case 'Confirmado':
        return IconButton(
          icon: Icon(Icons.exit_to_app, color: configProvider.iconColor),
          tooltip: 'Sair da festa',
          onPressed: () => _declineInvite(partyId),
        );
      case 'Disponível para Participar':
      default:
        return TextButton(
          onPressed: () => _requestParticipation(partyId),
          child: Text(
            'Participar',
            style: TextStyle(color: configProvider.iconColor),
          ),
        );
    }
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);
    return Container(
      color: configProvider.primaryColor,
      child: Stack(
        children: [
          if (_isLoading)
            Center(
              child: CircularProgressIndicator(
                color: configProvider.iconColor,
              ),
            )
          else if (_parties.isEmpty)
            Center(
              child: Text(
                "Nenhuma festa encontrada",
                style: TextStyle(color: configProvider.textColor, fontSize: 16),
              ),
            )
          else
            ListView.builder(
              itemCount: _parties.length,
              itemBuilder: (ctx, index) {
                final party = _parties[index];
                return _buildPartyItem(party);
              },
            ),
          Positioned(
            bottom: 16,
            right: 16,
            child: FloatingActionButton(
              backgroundColor: configProvider.secondaryColor,
              onPressed: () async {
                final result = await Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder: (_) => const CreateEditPartyPage(),
                  ),
                );
                if (result == true) {
                  _fetchAllParties();
                }
              },
              child: Icon(Icons.add, color: configProvider.iconColor),
            ),
          ),
        ],
      ),
    );
  }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\privateChat\places_page.dart ===
import 'dart:convert';
import 'dart:developer';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/pages/places/place_details_page.dart';
import 'package:snarf/pages/places/create_edit_place_page.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/services/api_service.dart';
import 'package:snarf/services/signalr_manager.dart';
import 'package:snarf/utils/show_snackbar.dart';
import 'package:snarf/enums/signalr_event_type.dart';

class PlacesPage extends StatefulWidget {
  const PlacesPage({Key? key}) : super(key: key);

  @override
  State<PlacesPage> createState() => _PlacesPageState();
}

class _PlacesPageState extends State<PlacesPage> {
  bool _isLoading = false;
  List<dynamic> _places = [];
  String? userId;

  @override
  void initState() {
    super.initState();
    _fetchAllPlaces();
    SignalRManager().listenToEvent('ReceiveMessage', _handleSignalRMessage);
  }

  Future<void> _fetchAllPlaces() async {
    userId = await ApiService.getUserIdFromToken();
    if (userId == null) {
      showErrorSnackbar(context, 'Usuário não logado');
      return;
    }
    setState(() => _isLoading = true);
    final data = await ApiService.getAllPlaces();
    setState(() => _isLoading = false);
    if (data == null) {
      showErrorSnackbar(context, 'Erro ao buscar locais');
      return;
    }
    _places = data['data'] ?? [];
    setState(() {});
  }

  void _handleSignalRMessage(List<Object?>? args) {
    if (args == null || args.isEmpty) return;
    try {
      final Map<String, dynamic> message = jsonDecode(args[0] as String);
      final SignalREventType type = SignalREventType.values.firstWhere(
        (e) => e.toString().split('.').last == message['Type'],
        orElse: () => SignalREventType.UserDisconnected,
      );
      if (type == SignalREventType.PlaceChatReceiveMessage ||
          type == SignalREventType.PlaceChatReceiveMessageDeleted) {}
    } catch (e) {
      log("Erro ao processar mensagem SignalR: $e");
    }
  }

  Future<void> _deletePlace(String placeId) async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Excluir Lugar'),
        content: const Text('Tem certeza que deseja excluir este lugar?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx, false),
            child: const Text('Cancelar'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(ctx, true),
            child: const Text('Excluir'),
          ),
        ],
      ),
    );
    if (confirm != true) return;
    final success = await ApiService.deletePlace(placeId);
    if (success) {
      showSuccessSnackbar(context, 'Lugar excluído com sucesso!');
      _fetchAllPlaces();
    } else {
      showErrorSnackbar(context, 'Erro ao excluir lugar');
    }
  }

  Future<void> _signalToRemovePlace(String placeId) async {
    final success = await ApiService.signalToRemovePlace(placeId);
    if (success) {
      showSuccessSnackbar(context, 'Lugar sinalizado para remoção');
    } else {
      showErrorSnackbar(context, 'Erro ao sinalizar remoção');
    }
  }

  Widget _buildPlaceItem(dynamic place) {
    final config = Provider.of<ConfigProvider>(context, listen: false);
    final placeId = place['id'].toString();
    final title = place['title'] ?? '';
    final imageUrl = place['coverImageUrl'] as String? ?? '';
    final ownerId = place['ownerId'] ?? '';
    return Card(
      color: config.secondaryColor,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      margin: const EdgeInsets.symmetric(vertical: 6, horizontal: 8),
      child: ListTile(
        leading: (imageUrl.isNotEmpty)
            ? ClipRRect(
                borderRadius: BorderRadius.circular(8),
                child: Image.network(imageUrl,
                    width: 50, height: 50, fit: BoxFit.cover),
              )
            : Icon(Icons.location_on, color: config.iconColor),
        title: Text(
          title,
          style:
              TextStyle(color: config.textColor, fontWeight: FontWeight.bold),
        ),
        onTap: () {
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (_) => PlaceDetailsPage(placeId: placeId),
            ),
          );
        },
        trailing: (ownerId == userId)
            ? PopupMenuButton<String>(
                color: config.primaryColor,
                icon: Icon(Icons.more_vert, color: config.iconColor),
                onSelected: (value) {
                  if (value == 'edit') {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (_) => CreateEditPlacePage(placeId: placeId),
                      ),
                    ).then((updated) {
                      if (updated == true) _fetchAllPlaces();
                    });
                  } else if (value == 'delete') {
                    _deletePlace(placeId);
                  } else if (value == 'signal') {
                    _signalToRemovePlace(placeId);
                  }
                },
                itemBuilder: (ctx) => [
                  PopupMenuItem(
                    value: 'edit',
                    child: Text('Editar',
                        style: TextStyle(color: config.textColor)),
                  ),
                  PopupMenuItem(
                    value: 'delete',
                    child: Text('Excluir',
                        style: TextStyle(color: config.textColor)),
                  ),
                  PopupMenuItem(
                    value: 'signal',
                    child: Text('Sinalizar Remoção',
                        style: TextStyle(color: config.textColor)),
                  ),
                ],
              )
            : null,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final config = Provider.of<ConfigProvider>(context);
    return Stack(
      children: [
        if (_isLoading)
          Center(child: CircularProgressIndicator(color: config.iconColor))
        else if (_places.isEmpty)
          Center(
            child: Text(
              "Nenhum local encontrado",
              style: TextStyle(color: config.textColor, fontSize: 16),
            ),
          )
        else
          ListView.builder(
            itemCount: _places.length,
            itemBuilder: (ctx, index) => _buildPlaceItem(_places[index]),
          ),
        Positioned(
          bottom: 16,
          right: 16,
          child: FloatingActionButton(
            backgroundColor: config.secondaryColor,
            onPressed: () async {
              final result = await Navigator.push(
                context,
                MaterialPageRoute(builder: (_) => const CreateEditPlacePage()),
              );
              if (result == true) {
                _fetchAllPlaces();
              }
            },
            child: Icon(Icons.add, color: config.iconColor),
          ),
        )
      ],
    );
  }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\privateChat\private_chat_navigation_page.dart ===
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/pages/privateChat/parties_page.dart';
import 'package:snarf/pages/privateChat/places_page.dart';
import 'package:snarf/pages/privateChat/recent_page.dart';
import 'package:snarf/providers/config_provider.dart';

class PrivateChatNavigationPage extends StatefulWidget {
  final ScrollController scrollController;

  const PrivateChatNavigationPage({super.key, required this.scrollController});

  @override
  State<PrivateChatNavigationPage> createState() =>
      _PrivateChatNavigationPageState();
}

class _PrivateChatNavigationPageState extends State<PrivateChatNavigationPage>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;

  final List<Widget> _pages = [
    const RecentPage(showFavorites: false),
    const RecentPage(showFavorites: true),
    const PlacesPage(),
    const PartiesPage(),
  ];

  final List<String> _titles = [
    'Recentes',
    'Fixados',
    'Locais',
    'Festas',
  ];

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: _pages.length, vsync: this);
    _tabController.addListener(() {
      if (_tabController.indexIsChanging) {
        setState(() {});
      }
    });
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  void showPrivacyPolicyDialog() {
    final configProvider = Provider.of<ConfigProvider>(context, listen: false);

    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          backgroundColor: configProvider.primaryColor,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
            side: BorderSide(
              color: configProvider.secondaryColor,
              width: 2,
            ),
          ),
          title: Text(
            "Conscientização de Fraude",
            style: TextStyle(color: configProvider.textColor),
          ),
          content: SingleChildScrollView(
            child: Text(
              "Proteja-se contra extorsão, roubo de identidade e fraude de cartão de crédito.\n\n"
              "O Snarf possui várias ferramentas para deter golpistas, mas também precisamos da sua ajuda.\n\n"
              "Como regra geral:\n"
              "    • Nunca acesse um link que alguém te enviar em uma mensagem.\n"
              "    • Nunca forneça seu número de telefone ou outras informações confidenciais.\n\n"
              "Golpes comuns\n"
              "Existem vários truques comuns que os golpistas usam para enganar as pessoas. Um fraudador, spammer ou golpista é qualquer pessoa que tenta obter informações confidenciais suas, induzi-lo a dar dinheiro a eles ou enganá-lo para fazer algo em benefício deles.\n\n"
              "Sinais de que alguém está tentando te enganar:\n"
              "    • Tentam levar a conversa para outro lugar, por exemplo:\n"
              "        ◦ Pedem seu número de telefone, endereço de e-mail ou nome de usuário de mídia social.\n"
              "        ◦ Te dão o número de telefone deles e pedem para você enviar uma mensagem de texto.\n"
              "        ◦ Pedem para você acessar um link externo.\n"
              "    • Usam caracteres especiais e intencionalmente escrevem palavras erradas para evitar filtros de spam (por exemplo: 'm@ss@ge').\n"
              "    • Oferecem serviços como massagem ou outros e querem que você marque uma consulta em outro site.\n"
              "    • Pedem para você comprar cartões-presente e enviar o código do verso.\n"
              "    • Se apresentam como um administrador do Snarf e pedem para você realizar uma ação ou ameaçam denunciar sua conta para te assustar e te tirar da plataforma.\n"
              "    • Combinam um ou mais dos itens acima e ainda têm uma foto de perfil que parece boa demais para ser verdade.\n\n"
              "O que fazer se identificar um golpe?\n"
              "Se alguém te enviar mensagens usando qualquer uma dessas estratégias, é melhor não responder e bloquear ou denunciar o perfil imediatamente.\n\n"
              "O Snarf possui várias ferramentas para ajudar a combater spam e contas falsas, mas também precisamos da sua ajuda. Spammers só ficam por perto se conseguirem o que procuram.",
              style: TextStyle(color: configProvider.textColor),
              textAlign: TextAlign.justify,
            ),
          ),
          actions: [
            OutlinedButton(
              style: OutlinedButton.styleFrom(
                side: BorderSide(
                  color: configProvider.secondaryColor,
                  width: 1,
                ),
              ),
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: Text(
                "Fechar",
                style: TextStyle(color: configProvider.textColor),
              ),
            )
          ],
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);

    return PopScope(
      child: Scaffold(
        backgroundColor: configProvider.primaryColor,
        appBar: AppBar(
          backgroundColor: configProvider.primaryColor,
          iconTheme: IconThemeData(color: configProvider.iconColor),
          title: Text(
            _titles[_tabController.index],
            style: TextStyle(color: configProvider.textColor),
          ),
          automaticallyImplyLeading: false,
          bottom: TabBar(
            controller: _tabController,
            labelColor: configProvider.iconColor,
            unselectedLabelColor: configProvider.textColor.withOpacity(0.7),
            indicatorColor: configProvider.secondaryColor,
            tabs: [
              Tab(
                icon: Icon(
                  Icons.chat_bubble,
                  color: configProvider.iconColor,
                ),
              ),
              Tab(
                icon: Icon(
                  Icons.push_pin,
                  color: configProvider.iconColor,
                ),
              ),
              Tab(
                icon: Icon(
                  Icons.location_on,
                  color: configProvider.iconColor,
                ),
              ),
              Tab(
                icon: Icon(
                  Icons.people,
                  color: configProvider.iconColor,
                ),
              ),
            ],
          ),
        ),
        body: TabBarView(
          controller: _tabController,
          children: _pages,
        ),
        bottomNavigationBar: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Divider(color: configProvider.secondaryColor),
            Container(
              padding: const EdgeInsets.fromLTRB(0, 6, 0, 25),
              child: GestureDetector(
                onTap: showPrivacyPolicyDialog,
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      Icons.shield_outlined,
                      color: configProvider.iconColor,
                    ),
                    const SizedBox(width: 4),
                    Text(
                      "Proteja-se",
                      style: TextStyle(
                        color: configProvider.textColor,
                      ),
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        "Segurança Online e Prevenção contra Fraude",
                        style: TextStyle(
                          color: Colors.blue,
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\privateChat\private_chat_page.dart ===
import 'dart:async';
import 'dart:convert';
import 'dart:developer';
import 'dart:io';
import 'package:firebase_analytics/firebase_analytics.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:image_picker/image_picker.dart';
import 'package:pro_image_editor/plugins/emoji_picker_flutter/src/config.dart';
import 'package:pro_image_editor/plugins/emoji_picker_flutter/src/emoji_picker.dart';
import 'package:pro_image_editor/pro_image_editor.dart';
import 'package:provider/provider.dart';
import 'package:snarf/pages/account/buy_subscription_page.dart';
import 'package:snarf/pages/account/view_user_page.dart';
import 'package:snarf/pages/home_page.dart';
import 'package:snarf/providers/call_manager.dart';
import 'package:snarf/providers/config_provider.dart';
import 'package:snarf/providers/intercepted_image_provider.dart';
import 'package:snarf/services/location_service.dart';
import 'package:snarf/utils/distance_utils.dart';
import 'package:snarf/utils/show_snackbar.dart';
import 'package:snarf/utils/date_utils.dart';
import 'package:snarf/services/signalr_manager.dart';
import 'package:record/record.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:image/image.dart' as img;
import 'package:snarf/enums/signalr_event_type.dart';
import 'package:video_compress/video_compress.dart';
import 'package:video_player/video_player.dart';
import 'package:chewie/chewie.dart';
import 'package:audioplayers/audioplayers.dart';
import 'package:snarf/services/api_service.dart';

class PrivateChatMessageModel {
  final String id;
  final DateTime createdAt;
  final String senderId;
  final String message;
  final Map<String, String> reactions;
  final String? replyToMessageId;

  PrivateChatMessageModel({
    required this.id,
    required this.createdAt,
    required this.senderId,
    required this.message,
    this.reactions = const {},
    this.replyToMessageId,
  });

  factory PrivateChatMessageModel.fromJson(Map<String, dynamic> json) {
    return PrivateChatMessageModel(
      id: json['Id'] as String? ?? json['MessageId'] as String,
      createdAt: DateTime.parse(
        json['CreatedAt'] as String? ?? DateTime.now().toIso8601String(),
      ).toLocal(),
      senderId: json['SenderId'] as String? ?? json['UserId'] as String? ?? '',
      message: json['Message'] as String? ?? '',
      reactions: (json['Reactions'] is Map)
          ? (json['Reactions'] as Map<dynamic, dynamic>).map<String, String>(
              (key, val) => MapEntry(key as String, val as String))
          : {},
      replyToMessageId: json['ReplyToMessageId'] as String? ??
          json['OriginalMessageId'] as String?,
    );
  }

  PrivateChatMessageModel copyWith({
    String? message,
    Map<String, String>? reactions,
    String? replyToMessageId,
  }) {
    return PrivateChatMessageModel(
      id: id,
      createdAt: createdAt,
      senderId: senderId,
      message: message ?? this.message,
      reactions: reactions ?? this.reactions,
      replyToMessageId: replyToMessageId ?? this.replyToMessageId,
    );
  }
}

class PrivateChatPage extends StatefulWidget {
  final String userId;
  final String userName;
  final String userImage;

  const PrivateChatPage({
    super.key,
    required this.userId,
    required this.userName,
    required this.userImage,
  });

  @override
  _PrivateChatPageState createState() => _PrivateChatPageState();
}

class _PrivateChatPageState extends State<PrivateChatPage> {
  final TextEditingController _messageController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;
  final _locationService = LocationService();
  List<PrivateChatMessageModel> _messages = [];
  final _record = AudioRecorder();
  bool _isRecording = false;
  Timer? _recordingTimer;
  int _recordingSeconds = 0;
  bool _isFavorite = false;
  bool _isSendingMedia = false;
  String? _selectedMessageId;
  PrivateChatMessageModel? _replyingToMessage;
  DateTime? _lastActivity;
  double? _myLatitude;
  double? _myLongitude;
  double? _userLatitude;
  double? _userLongitude;

  bool _isLoading = false;

  bool get _isOnline {
    if (_lastActivity == null) return false;
    final difference = DateTime.now().difference(_lastActivity!);
    return difference.inMinutes < 1;
  }

  @override
  void initState() {
    super.initState();
    _initializeChat();
  }

  Future<void> _initializeChat() async {
    setState(() => _isLoading = true);
    try {
      await _initLocation();
      await _loadUserInfo();

      SignalRManager().listenToEvent('ReceiveMessage', _handleSignalRMessage);

      await SignalRManager().sendSignalRMessage(
        SignalREventType.PrivateChatGetPreviousMessages,
        {'ReceiverUserId': widget.userId},
      );

      await SignalRManager().sendSignalRMessage(
        SignalREventType.PrivateChatMarkMessagesAsRead,
        {'SenderUserId': widget.userId},
      );

      await SignalRManager().sendSignalRMessage(
        SignalREventType.PrivateChatGetFavorites,
        {},
      );

      await _initAudioRecorder();
    } catch (e) {
      log("Erro ao inicializar chat: $e");
      showErrorSnackbar(context, "Erro ao inicializar chat: $e");
    } finally {
      setState(() => _isLoading = false);
    }
  }

  Future<void> _initLocation() async {
    final ok = await _locationService.initialize();
    if (ok) {
      final loc = await _locationService.getCurrentLocation();
      setState(() {
        _myLatitude = loc.latitude;
        _myLongitude = loc.longitude;
      });
      _locationService.onLocationChanged.listen((loc) {
        setState(() {
          _myLatitude = loc.latitude;
          _myLongitude = loc.longitude;
        });
      });
    }
  }

  Future<void> _loadUserInfo() async {
    final userInfo = await ApiService.getUserInfoById(widget.userId);
    if (userInfo == null) {
      showErrorSnackbar(context, "Não foi possível carregar dados do usuário");
      return;
    }
    setState(() {
      if (userInfo['lastActivity'] != null) {
        _lastActivity = DateTime.parse(userInfo['lastActivity']).toLocal();
      }
      if (userInfo['lastLatitude'] != null &&
          userInfo['lastLongitude'] != null) {
        _userLatitude = (userInfo['lastLatitude'] as num).toDouble();
        _userLongitude = (userInfo['lastLongitude'] as num).toDouble();
      }
    });
  }

  void _handleSignalRMessage(List<Object?>? args) {
    if (args == null || args.isEmpty) return;
    try {
      final Map<String, dynamic> message = jsonDecode(args[0] as String);
      if (!message.containsKey('Type') || !message.containsKey('Data')) {
        return;
      }
      final typeString = message['Type'] as String;
      final dynamic data = message['Data'];
      SignalREventType type = SignalREventType.values.firstWhere(
        (e) => e.toString().split('.').last == typeString,
        orElse: () => SignalREventType.PrivateChatReceiveMessage,
      );
      switch (type) {
        case SignalREventType.PrivateChatReceivePreviousMessages:
          _handleReceivedMessages(data);
          break;
        case SignalREventType.PrivateChatReceiveMessage:
          _handleNewPrivateMessage(data);
          break;
        case SignalREventType.PrivateChatReceiveMessageDeleted:
          _handleMessageDeleted(data);
          break;
        case SignalREventType.PrivateChatReceiveFavorites:
          _handleFavoritesData(data);
          break;
        case SignalREventType.PrivateChatReceiveReaction:
          _handleReaction(data);
          break;
        case SignalREventType.PrivateChatReceiveReply:
          _handleReply(data);
          break;
        case SignalREventType.MapReceiveLocation:
          if (data is Map<String, dynamic>) {
            final userId = data['userId'] as String?;
            if (userId == widget.userId) {
              setState(() {
                _lastActivity = DateTime.now();
                if (data['Latitude'] != null && data['Longitude'] != null) {
                  _userLatitude = (data['Latitude'] as num).toDouble();
                  _userLongitude = (data['Longitude'] as num).toDouble();
                }
              });
            }
          }
          break;
        default:
          log("Evento não tratado: $typeString");
      }
    } catch (e) {
      log("Erro ao processar mensagem SignalR: $e");
    }
  }

  void _handleReceivedMessages(dynamic data) {
    if (data == null) return;
    try {
      final List<dynamic> rawList = data as List<dynamic>;
      final List<PrivateChatMessageModel> previousMessages =
          rawList.map((item) {
        final map = item as Map<String, dynamic>;
        return PrivateChatMessageModel.fromJson(map);
      }).toList();
      setState(() {
        _messages = previousMessages;
      });
      _scrollToBottom();
    } catch (err) {
      showErrorSnackbar(context, "Erro ao processar mensagens: $err");
    }
  }

  void _handleNewPrivateMessage(dynamic data) {
    if (data == null) return;
    try {
      final map = data as Map<String, dynamic>;
      final newMessage = PrivateChatMessageModel.fromJson(map);
      setState(() {
        _messages.add(newMessage);
      });
      _scrollToBottom();
    } catch (e) {
      showErrorSnackbar(context, "Erro ao processar nova mensagem: $e");
    }
  }

  void _handleMessageDeleted(dynamic data) {
    if (data == null) return;
    try {
      final map = data as Map<String, dynamic>;
      final String messageId = map['MessageId'] as String;
      setState(() {
        final idx = _messages.indexWhere((m) => m.id == messageId);
        if (idx != -1) {
          final old = _messages[idx];
          _messages[idx] = old.copyWith(message: "Mensagem excluída");
        }
      });
    } catch (e) {
      showErrorSnackbar(context, "Erro ao processar exclusão: $e");
    }
  }

  void _handleFavoritesData(dynamic data) {
    try {
      final List<dynamic> rawList = data as List<dynamic>;
      for (var item in rawList) {
        if (item is Map<String, dynamic>) {
          final chatUserId = item['Id'];
          if (chatUserId == widget.userId) {
            setState(() {
              _isFavorite = true;
            });
            break;
          }
        }
      }
    } catch (e) {
      log("Erro ao processar favoritos: $e");
    }
  }

  void _handleReaction(dynamic data) {
    if (data == null) return;
    try {
      final map = data as Map<String, dynamic>;
      final messageId = map['MessageId'] as String;
      final reaction = map['Reaction'];
      final reactorUserId = map['ReactorUserId'] as String;
      setState(() {
        final idx = _messages.indexWhere((m) => m.id == messageId);
        if (idx != -1) {
          final oldMsg = _messages[idx];
          final newReactions = Map<String, String>.from(oldMsg.reactions);
          if (reaction == null || reaction.isEmpty) {
            newReactions.remove(reactorUserId);
          } else {
            newReactions[reactorUserId] = reaction;
          }
          _messages[idx] = oldMsg.copyWith(reactions: newReactions);
        }
      });
    } catch (e) {
      showErrorSnackbar(context, "Erro ao processar reação: $e");
    }
  }

  void _handleReply(dynamic data) {
    if (data == null) return;
    try {
      final map = data as Map<String, dynamic>;
      final newMessage = PrivateChatMessageModel.fromJson(map);
      setState(() {
        _messages.add(newMessage);
      });
      _scrollToBottom();
    } catch (e) {
      showErrorSnackbar(context, "Erro ao processar resposta: $e");
    }
  }

  Future<void> _deleteMessage(String messageId) async {
    try {
      await SignalRManager().sendSignalRMessage(
        SignalREventType.PrivateChatDeleteMessage,
        {'MessageId': messageId},
      );
    } catch (err) {
      showErrorSnackbar(context, "Erro ao excluir mensagem: $err");
    } finally {
      setState(() => _selectedMessageId = null);
    }
  }

  Future<void> _deleteEntireChat() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (ctx) {
        final configProvider = Provider.of<ConfigProvider>(ctx, listen: false);
        return AlertDialog(
          backgroundColor: configProvider.primaryColor,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
            side: BorderSide(
              color: configProvider.secondaryColor,
              width: 2,
            ),
          ),
          title: Text(
            "Excluir conversa",
            style: TextStyle(
              color: configProvider.textColor,
            ),
          ),
          content: Text(
            "Deseja realmente excluir todo o chat?",
            style: TextStyle(
              color: configProvider.textColor,
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(ctx, false),
              child: Text(
                "Cancelar",
                style: TextStyle(
                  color: configProvider.textColor,
                ),
              ),
            ),
            TextButton(
              onPressed: () => Navigator.pop(ctx, true),
              child: Text(
                "Excluir",
                style: TextStyle(
                  color: configProvider.textColor,
                ),
              ),
            ),
          ],
        );
      },
    );
    if (confirm == true) {
      try {
        await SignalRManager().sendSignalRMessage(
          SignalREventType.PrivateChatDeleteChat,
          {'ReceiverUserId': widget.userId},
        );
        if (mounted) Navigator.pop(context);
      } catch (err) {
        showErrorSnackbar(context, "Erro ao excluir o chat: $err");
      }
    }
  }

  Future<bool> _canSendMessage() async {
    final config = Provider.of<ConfigProvider>(context, listen: false);
    DateTime? firstMessageDate = config.firstMessageToday;
    DateTime now = DateTime.now().toUtc();

    if (firstMessageDate == null) {
      return true;
    }

    log("Data primeira mensagem: ${firstMessageDate.toUtc()} Data atual: $now");
    Duration difference = now.difference(firstMessageDate.toUtc());
    log("Diferença em minutos: ${difference.inMinutes}");

    return difference.inMinutes <= 30;
  }

  void _sendMessage() async {
    final config = Provider.of<ConfigProvider>(context, listen: false);

    if (await _canSendMessage() || config.isSubscriber) {
      final message = _messageController.text.trim();
      if (message.isNotEmpty) {
        try {
          await SignalRManager().sendSignalRMessage(
            SignalREventType.PrivateChatSendMessage,
            {
              'ReceiverUserId': widget.userId,
              'Message': message,
            },
          );
          _messageController.clear();
          _scrollToBottom();
        } catch (err) {
          showErrorSnackbar(context, "Erro ao enviar mensagem: $err");
        }
      }
    } else {
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => BuySubscriptionPage(),
        ),
      );
    }
  }

  void _scrollToBottom() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_scrollController.hasClients) {
        _scrollController.jumpTo(
          _scrollController.position.maxScrollExtent,
        );
      }
    });
  }

  Future<void> _sendReaction(String messageId, String emoji) async {
    try {
      final newReaction = emoji.isEmpty ? null : emoji;
      await SignalRManager().sendSignalRMessage(
        SignalREventType.PrivateChatReactToMessage,
        {
          'MessageId': messageId,
          'Reaction': newReaction,
        },
      );
      setState(() => _selectedMessageId = null);
    } catch (e) {
      showErrorSnackbar(context, "Erro ao enviar reação: $e");
    }
  }

  Future<void> _replyToMessage(
      String originalMessageId, String replyText) async {
    try {
      await SignalRManager().sendSignalRMessage(
        SignalREventType.PrivateChatReplyToMessage,
        {
          'ReceiverUserId': widget.userId,
          'OriginalMessageId': originalMessageId,
          'Message': replyText,
        },
      );
    } catch (e) {
      showErrorSnackbar(context, "Erro ao enviar resposta: $e");
    }
  }

  Future<void> _initAudioRecorder() async {
    final status = await Permission.microphone.request();
    if (status != PermissionStatus.granted) {
      showErrorSnackbar(context, "Permissão de microfone negada");
      return;
    }
  }

  Future<void> _startRecording() async {
    if (_isRecording) return;
    final hasPermission = await _record.hasPermission();
    if (!hasPermission) {
      showErrorSnackbar(context, "Sem permissão para gravar áudio");
      return;
    }
    _isRecording = true;
    setState(() {});
    _recordingSeconds = 0;
    _recordingTimer = Timer.periodic(const Duration(seconds: 1), (timer) async {
      _recordingSeconds++;
      if (_recordingSeconds >= 60) {
        await _stopRecording();
      }
      setState(() {});
    });
    final tempPath =
        '${Directory.systemTemp.path}/temp_audio_${DateTime.now().millisecondsSinceEpoch}.aac';
    await _record.start(
      const RecordConfig(),
      path: tempPath,
    );
  }

  Future<void> _stopRecording() async {
    if (!_isRecording) return;
    final path = await _record.stop();
    _isRecording = false;
    _recordingTimer?.cancel();
    _recordingTimer = null;
    setState(() {});
    if (path != null) {
      await _sendAudio(path);
    }
  }

  Future<void> _sendAudio(String filePath) async {
    setState(() => _isSendingMedia = true);
    try {
      final fileBytes = await File(filePath).readAsBytes();
      final base64Audio = base64Encode(fileBytes);
      await SignalRManager().sendSignalRMessage(
        SignalREventType.PrivateChatSendAudio,
        {
          'ReceiverUserId': widget.userId,
          'Audio': base64Audio,
          'FileName': 'audio_${DateTime.now().millisecondsSinceEpoch}.aac',
        },
      );
    } catch (e) {
      showErrorSnackbar(context, "Erro ao enviar áudio: $e");
    } finally {
      if (mounted) setState(() => _isSendingMedia = false);
    }
  }

  Future<void> _pickImage() async {
    final ImagePicker picker = ImagePicker();
    final XFile? image = await picker.pickImage(source: ImageSource.gallery);
    if (image != null) {
      await _editAndSendImage(image);
    }
  }

  Future<void> _takePhoto() async {
    final ImagePicker picker = ImagePicker();
    final XFile? image = await picker.pickImage(source: ImageSource.camera);
    if (image != null) {
      await _editAndSendImage(image);
    }
  }

  Future<void> _editAndSendImage(XFile image) async {
    setState(() => _isSendingMedia = true);
    try {
      await Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => ProImageEditor.file(
            File(image.path),
            callbacks: ProImageEditorCallbacks(
              onImageEditingComplete: (Uint8List editedBytes) async {
                final compressedBytes =
                    await _compressImage(editedBytes, quality: 40);
                final base64Image = base64Encode(compressedBytes);
                await _sendImage(base64Image, image.name);
                Navigator.pop(context);
              },
            ),
          ),
        ),
      );
    } catch (e) {
      showErrorSnackbar(context, "Erro ao editar/enviar imagem: $e");
    } finally {
      if (mounted) setState(() => _isSendingMedia = false);
    }
  }

  Future<Uint8List> _compressImage(Uint8List imageBytes,
      {int quality = 50}) async {
    final decodedImage = img.decodeImage(imageBytes);
    if (decodedImage != null) {
      return Uint8List.fromList(img.encodeJpg(decodedImage, quality: quality));
    }
    return imageBytes;
  }

  Future<void> _sendImage(String base64Image, String fileName) async {
    try {
      await SignalRManager().sendSignalRMessage(
        SignalREventType.PrivateChatSendImage,
        {
          'ReceiverUserId': widget.userId,
          'Image': base64Image,
          'FileName': fileName,
        },
      );
    } catch (e) {
      showErrorSnackbar(context, "Erro ao enviar imagem: $e");
    }
  }

  Future<void> _pickVideo() async {
    final ImagePicker picker = ImagePicker();
    final XFile? video = await picker.pickVideo(
      source: ImageSource.gallery,
      maxDuration: const Duration(seconds: 15),
    );
    if (video == null) return;
    final durationOk = await _checkVideoDuration(File(video.path));
    if (!durationOk) {
      showErrorSnackbar(context, "O vídeo excede 15 segundos!");
      return;
    }
    await _sendVideo(video);
  }

  Future<void> _recordVideo() async {
    final ImagePicker picker = ImagePicker();
    final XFile? video = await picker.pickVideo(
      source: ImageSource.camera,
      maxDuration: const Duration(seconds: 15),
    );
    if (video == null) return;
    await _sendVideo(video);
  }

  Future<void> _sendVideo(XFile video) async {
    setState(() => _isSendingMedia = true);
    try {
      final originalFile = File(video.path);
      final compressedFile = await _compressVideo(originalFile);
      if (compressedFile == null) {
        showErrorSnackbar(context, "Falha ao comprimir vídeo");
        return;
      }
      final fileBytes = await compressedFile!.readAsBytes();
      final base64Video = base64Encode(fileBytes);
      await SignalRManager().sendSignalRMessage(
        SignalREventType.PrivateChatSendVideo,
        {
          'ReceiverUserId': widget.userId,
          'Video': base64Video,
          'FileName': video.name,
        },
      );
    } catch (e) {
      showErrorSnackbar(context, "Erro ao enviar vídeo: $e");
    } finally {
      if (mounted) setState(() => _isSendingMedia = false);
    }
  }

  Future<bool> _checkVideoDuration(File file) async {
    final controller = VideoPlayerController.file(file);
    await controller.initialize();
    final duration = controller.value.duration;
    controller.dispose();
    return duration <= const Duration(seconds: 15);
  }

  Future<File?> _compressVideo(File file) async {
    final compressedVideo = await VideoCompress.compressVideo(
      file.path,
      quality: VideoQuality.HighestQuality,
      deleteOrigin: false,
      includeAudio: true,
    );
    if (compressedVideo != null && compressedVideo.file != null) {
      return compressedVideo.file;
    }
    return null;
  }

  Future<void> _toggleFavorite() async {
    try {
      if (_isFavorite) {
        await SignalRManager().sendSignalRMessage(
          SignalREventType.PrivateChatRemoveFavorite,
          {
            'ChatUserId': widget.userId,
          },
        );
      } else {
        await SignalRManager().sendSignalRMessage(
          SignalREventType.PrivateChatAddFavorite,
          {
            'ChatUserId': widget.userId,
          },
        );
      }
      setState(() {
        _isFavorite = !_isFavorite;
      });
    } catch (e) {
      showErrorSnackbar(context, "Erro ao alterar favorito: $e");
    }
  }

  Future<void> _blockUser() async {
    final result = await ApiService.blockUser(widget.userId);
    if (result == null) {
      showSuccessSnackbar(context, 'Usuário bloqueado com sucesso.',
          color: Colors.green);
      Navigator.pop(context);
    } else {
      showErrorSnackbar(context, 'Erro ao bloquear usuário: $result');
    }
  }

  Future<void> _reportUser() async {
    final result = await ApiService.reportUser(widget.userId);
    if (result == null) {
      showSuccessSnackbar(context, 'Usuário denunciado com sucesso.',
          color: Colors.green);
      Navigator.pop(context);
    } else {
      showErrorSnackbar(context, 'Erro ao denunciar usuário: $result');
    }
  }

  Future<void> _initiateCall(String targetUserId) async {
    final config = Provider.of<ConfigProvider>(context, listen: false);
    if (config.isSubscriber) {
      try {
        final callManager = Provider.of<CallManager>(context, listen: false);
        callManager.startCall(targetUserId);
        await _analytics.logEvent(
            name: 'view_user_initiate_call',
            parameters: {'targetUserId': targetUserId});
      } catch (e) {
        showErrorSnackbar(context, "Erro ao iniciar chamada: $e");
        await _analytics.logEvent(
            name: 'view_user_initiate_call_error',
            parameters: {'error': e.toString()});
      }
    } else {
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => BuySubscriptionPage(),
        ),
      );
    }
  }

  void _openEmojiPicker(String messageId) {
    final configProvider = Provider.of<ConfigProvider>(context, listen: false);
    showModalBottomSheet(
      context: context,
      backgroundColor: configProvider.primaryColor,
      builder: (ctx) {
        return Container(
          color: configProvider.primaryColor,
          height: 300,
          child: EmojiPicker(
            onBackspacePressed: () {
              _sendReaction(messageId, '');
              Navigator.pop(ctx);
            },
            onEmojiSelected: (category, emoji) {
              final selectedEmoji = emoji.emoji;
              _sendReaction(messageId, selectedEmoji);
              Navigator.pop(ctx);
            },
            config: Config(
              categoryViewConfig: CategoryViewConfig(
                backgroundColor: configProvider.primaryColor,
                iconColor: configProvider.iconColor,
                iconColorSelected: configProvider.secondaryColor,
              ),
              emojiViewConfig: EmojiViewConfig(
                backgroundColor: configProvider.primaryColor,
              ),
              searchViewConfig: SearchViewConfig(
                backgroundColor: configProvider.primaryColor,
                buttonIconColor: configProvider.iconColor,
              ),
              bottomActionBarConfig: BottomActionBarConfig(
                backgroundColor: configProvider.primaryColor,
                buttonIconColor: configProvider.iconColor,
                buttonColor: configProvider.secondaryColor,
              ),
            ),
          ),
        );
      },
    );
  }

  void _onMessageLongPress(PrivateChatMessageModel message) {
    setState(() {
      if (_selectedMessageId == message.id) {
        _selectedMessageId = null;
      } else {
        _selectedMessageId = message.id;
      }
    });
  }

  @override
  void dispose() {
    _recordingTimer?.cancel();
    _scrollController.dispose();
    if (_isRecording) {
      _record.stop();
    }
    super.dispose();
  }

  Widget _buildOnlineStatusBar(ConfigProvider configProvider) {
    String distanceInfo = '';
    if (_myLatitude != null &&
        _myLongitude != null &&
        _userLatitude != null &&
        _userLongitude != null) {
      final distance = DistanceUtils.calculateDistance(
        _myLatitude!,
        _myLongitude!,
        _userLatitude!,
        _userLongitude!,
      );
      distanceInfo = '${distance.toStringAsFixed(2)} km';
    }
    return Container(
      width: double.infinity,
      color: configProvider.primaryColor.withOpacity(0.7),
      padding: const EdgeInsets.all(8),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        children: [
          PopupMenuButton<int>(
            color: configProvider.primaryColor,
            icon: Icon(Icons.more_horiz, color: configProvider.iconColor),
            onSelected: (value) {
              if (value == 0) {
                _deleteEntireChat();
              } else if (value == 1) {
                _reportUser();
              } else if (value == 2) {
                _blockUser();
              }
            },
            itemBuilder: (context) => [
              PopupMenuItem(
                value: 0,
                child: Text(
                  'Excluir todo o chat',
                  style: TextStyle(
                    color: configProvider.textColor,
                  ),
                ),
              ),
              PopupMenuItem(
                value: 1,
                child: Text(
                  'Denunciar',
                  style: TextStyle(
                    color: configProvider.textColor,
                  ),
                ),
              ),
              PopupMenuItem(
                value: 2,
                child: Text(
                  'Bloquear',
                  style: TextStyle(
                    color: configProvider.textColor,
                  ),
                ),
              ),
            ],
          ),
          Text(
            _isOnline
                ? 'Conectado'
                : (_lastActivity != null
                    ? DateJSONUtils.formatRelativeTime(
                        _lastActivity!.toString())
                    : 'Offline'),
            style: TextStyle(color: configProvider.textColor),
          ),
          InkWell(
            onTap: distanceInfo.isNotEmpty
                ? () {
                    Navigator.of(context).pushAndRemoveUntil(
                      MaterialPageRoute(
                        builder: (context) => HomePage(
                          initialLatitude: _userLatitude,
                          initialLongitude: _userLongitude,
                        ),
                      ),
                      (Route<dynamic> route) => false,
                    );
                  }
                : null,
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  Icons.my_location,
                  size: 14,
                  color: Colors.blue,
                ),
                const SizedBox(width: 3),
                Text(
                  distanceInfo,
                  style: TextStyle(
                    color: Colors.blue,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);

    return Scaffold(
      backgroundColor: configProvider.primaryColor,
      appBar: AppBar(
        backgroundColor: configProvider.primaryColor,
        iconTheme: IconThemeData(color: configProvider.iconColor),
        title: InkWell(
          onTap: () {
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) => ViewUserPage(userId: widget.userId),
              ),
            );
          },
          child: Row(
            children: [
              CircleAvatar(
                backgroundImage: InterceptedImageProvider(
                  originalProvider: NetworkImage(widget.userImage),
                  hideImages: configProvider.hideImages,
                ),
                radius: 18,
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  widget.userName,
                  overflow: TextOverflow.ellipsis,
                  style: TextStyle(color: configProvider.textColor),
                ),
              ),
            ],
          ),
        ),
        actions: [
          IconButton(
            icon: Icon(
              _isFavorite ? Icons.star : Icons.star_border,
              color: configProvider.iconColor,
            ),
            onPressed: _toggleFavorite,
          ),
          IconButton(
            onPressed: () => _initiateCall(widget.userId),
            icon: Icon(
              Icons.videocam,
              color: configProvider.iconColor,
            ),
          ),
        ],
      ),
      body: _isLoading
          ? Center(
              child: CircularProgressIndicator(color: configProvider.iconColor),
            )
          : Stack(
              children: [
                Container(
                  decoration: BoxDecoration(
                    image: DecorationImage(
                      image: InterceptedImageProvider(
                        originalProvider: NetworkImage(widget.userImage),
                        hideImages: configProvider.hideImages,
                      ),
                      fit: BoxFit.cover,
                    ),
                  ),
                ),
                Container(
                  decoration: BoxDecoration(
                    gradient: RadialGradient(
                      center: Alignment.center,
                      radius: 0.9,
                      colors: [
                        Colors.transparent,
                        configProvider.primaryColor.withOpacity(0.8),
                      ],
                      stops: const [0.5, 1.0],
                    ),
                  ),
                ),
                Column(
                  children: [
                    Expanded(
                      child: GestureDetector(
                        onTap: () {
                          setState(() => _selectedMessageId = null);
                        },
                        child: ListView.builder(
                          controller: _scrollController,
                          itemCount: _messages.length,
                          itemBuilder: (context, index) {
                            final message = _messages[index];
                            final isMine = message.senderId != widget.userId;
                            final time = DateJSONUtils.formatRelativeTime(
                              message.createdAt.toString(),
                            );
                            return _buildMessageRow(
                              context,
                              message: message,
                              isMine: isMine,
                              time: time,
                              configProvider: configProvider,
                            );
                          },
                        ),
                      ),
                    ),
                    _buildReplyBanner(configProvider),
                    _buildBottomBar(configProvider),
                    _buildOnlineStatusBar(configProvider),
                  ],
                ),
                if (_isSendingMedia)
                  Container(
                    color: Colors.black54,
                    child: const Center(
                      child: CircularProgressIndicator(color: Colors.white),
                    ),
                  ),
              ],
            ),
    );
  }

  Widget _buildReplyBanner(ConfigProvider configProvider) {
    if (_replyingToMessage == null) return const SizedBox();
    final originalText = _replyingToMessage!.message;
    final isMedia = originalText.startsWith('https://');
    return Container(
      color: configProvider.primaryColor,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        child: Row(
          children: [
            Icon(Icons.reply, size: 20, color: configProvider.iconColor),
            const SizedBox(width: 8),
            Expanded(
              child: Text(
                isMedia
                    ? 'Respondendo a um arquivo (imagem/vídeo/áudio)'
                    : 'Respondendo: $originalText',
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
                style: TextStyle(color: configProvider.textColor),
              ),
            ),
            IconButton(
              onPressed: () {
                setState(() => _replyingToMessage = null);
              },
              icon: Icon(Icons.close, color: configProvider.iconColor),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildBottomBar(ConfigProvider configProvider) {
    return Container(
      color: configProvider.primaryColor,
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
      child: Row(
        children: [
          PopupMenuButton<String>(
            color: configProvider.primaryColor,
            icon: Icon(
              Icons.add_circle,
              size: 28,
              color: configProvider.iconColor,
            ),
            onSelected: (value) {
              if (value == 'gallery') _pickImage();
              if (value == 'camera') _takePhoto();
              if (value == 'video_gallery') _pickVideo();
            },
            itemBuilder: (context) => [
              PopupMenuItem(
                value: 'gallery',
                child: Text(
                  'Foto da Galeria',
                  style: TextStyle(
                    color: configProvider.textColor,
                  ),
                ),
              ),
              PopupMenuItem(
                value: 'camera',
                child: Text(
                  'Tirar Foto',
                  style: TextStyle(
                    color: configProvider.textColor,
                  ),
                ),
              ),
              PopupMenuItem(
                value: 'video_gallery',
                child: Text(
                  'Vídeo da Galeria',
                  style: TextStyle(
                    color: configProvider.textColor,
                  ),
                ),
              ),
            ],
          ),
          Expanded(
            child: TextField(
              controller: _messageController,
              style: TextStyle(color: configProvider.textColor),
              decoration: InputDecoration(
                hintText: "Digite sua mensagem...",
                hintStyle:
                    TextStyle(color: configProvider.textColor.withOpacity(0.7)),
                fillColor: configProvider.secondaryColor.withOpacity(0.15),
                filled: true,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(30),
                  borderSide: BorderSide(color: configProvider.secondaryColor),
                ),
                enabledBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(30),
                  borderSide: BorderSide(color: configProvider.secondaryColor),
                ),
              ),
              maxLines: null,
            ),
          ),
          IconButton(
            icon: Icon(Icons.send, color: configProvider.iconColor),
            onPressed: () {
              final text = _messageController.text.trim();
              if (text.isEmpty) return;
              if (_replyingToMessage != null) {
                _replyToMessage(_replyingToMessage!.id, text);
                _replyingToMessage = null;
                _messageController.clear();
              } else {
                _sendMessage();
              }
            },
          ),
          IconButton(
            icon: Icon(Icons.camera_alt, color: configProvider.iconColor),
            onPressed: () => _recordVideo(),
          ),
          IconButton(
            icon: Icon(
              _isRecording ? Icons.stop : Icons.mic,
              color: _isRecording ? Colors.red : configProvider.iconColor,
            ),
            onPressed: _isRecording ? _stopRecording : _startRecording,
          ),
        ],
      ),
    );
  }

  Widget _buildMessageRow(
    BuildContext context, {
    required PrivateChatMessageModel message,
    required bool isMine,
    required String time,
    required ConfigProvider configProvider,
  }) {
    return Container(
      margin: EdgeInsets.only(
        top: 4,
        bottom: 4,
        left: isMine ? 40 : 8,
        right: isMine ? 8 : 40,
      ),
      child: Column(
        crossAxisAlignment:
            isMine ? CrossAxisAlignment.end : CrossAxisAlignment.start,
        children: [
          Text(
            time,
            style: TextStyle(
              fontSize: 12,
              fontStyle: FontStyle.italic,
              color: configProvider.textColor.withOpacity(0.8),
            ),
          ),
          _buildMessageBubble(message, isMine, configProvider),
          if (_selectedMessageId == message.id)
            _buildActionsBar(message, isMine, configProvider),
        ],
      ),
    );
  }

  Widget _buildActionsBar(PrivateChatMessageModel message, bool isMine,
      ConfigProvider configProvider) {
    return Container(
      margin: const EdgeInsets.only(bottom: 4),
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: Row(
        mainAxisAlignment:
            isMine ? MainAxisAlignment.end : MainAxisAlignment.start,
        children: [
          IconButton(
            icon: Icon(Icons.mood, color: configProvider.iconColor),
            onPressed: () => _openEmojiPicker(message.id),
          ),
          IconButton(
            icon: Icon(Icons.reply, color: configProvider.iconColor),
            onPressed: () {
              setState(() {
                _replyingToMessage = message;
                _selectedMessageId = null;
              });
            },
          ),
          if (isMine && message.message != 'Mensagem excluída')
            IconButton(
              icon: Icon(Icons.delete, color: configProvider.iconColor),
              onPressed: () => _deleteMessage(message.id),
            ),
        ],
      ),
    );
  }

  Widget _buildMessageBubble(PrivateChatMessageModel message, bool isMine,
      ConfigProvider configProvider) {
    final isDeleted = message.message == 'Mensagem excluída';
    final content = message.message;
    final lower = content.toLowerCase();
    final bool isImage = lower.startsWith('https://') && _isImageUrl(content);
    final bool isVideo = lower.startsWith('https://') && _isVideoUrl(content);
    final bool isAudio = lower.startsWith('https://') && _isAudioUrl(content);
    final replyToMsg = (message.replyToMessageId != null)
        ? _messages.firstWhere(
            (m) => m.id == message.replyToMessageId,
            orElse: () => PrivateChatMessageModel(
              id: '',
              createdAt: DateTime.now(),
              senderId: '',
              message: '(Mensagem original não encontrada)',
            ),
          )
        : null;

    final bubbleColor = isMine
        ? configProvider.secondaryColor.withOpacity(0.8)
        : configProvider.secondaryColor.withOpacity(0.6);

    final borderRadius = BorderRadius.only(
      topLeft: const Radius.circular(16),
      topRight: const Radius.circular(16),
      bottomLeft: isMine ? const Radius.circular(16) : const Radius.circular(0),
      bottomRight:
          isMine ? const Radius.circular(0) : const Radius.circular(16),
    );
    return GestureDetector(
      onLongPress: () => _onMessageLongPress(message),
      child: Column(
        crossAxisAlignment:
            isMine ? CrossAxisAlignment.end : CrossAxisAlignment.start,
        children: [
          Container(
            padding: const EdgeInsets.all(6),
            margin: const EdgeInsets.only(bottom: 4),
            decoration: BoxDecoration(
              color: bubbleColor,
              borderRadius: borderRadius,
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                if (replyToMsg != null && replyToMsg.id.isNotEmpty)
                  Container(
                    padding: const EdgeInsets.all(8),
                    margin: const EdgeInsets.only(bottom: 8),
                    decoration: BoxDecoration(
                      color: configProvider.primaryColor.withOpacity(0.2),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Text(
                      "Em resposta: ${replyToMsg.message.startsWith('https://') ? '(Mídia)' : replyToMsg.message}",
                      style: TextStyle(
                        fontStyle: FontStyle.italic,
                        color: configProvider.textColor,
                      ),
                    ),
                  ),
                if (isDeleted)
                  Text(
                    "Mensagem excluída",
                    style: TextStyle(
                      fontStyle: FontStyle.italic,
                      color: configProvider.textColor,
                    ),
                  )
                else if (isImage || isVideo || isAudio)
                  _InlineMediaWidget(
                    mediaUrl: content,
                    isImage: isImage,
                    isVideo: isVideo,
                    isAudio: isAudio,
                    textColor: configProvider.textColor,
                  )
                else
                  Text(
                    content,
                    style: TextStyle(
                        fontSize: 16, color: configProvider.textColor),
                  ),
                if (message.reactions.isNotEmpty)
                  Wrap(
                    spacing: 4,
                    children: message.reactions.values.map((emoji) {
                      return Text(emoji, style: const TextStyle(fontSize: 18));
                    }).toList(),
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  bool _isImageUrl(String url) {
    final lower = url.toLowerCase();
    return lower.endsWith('.jpg') ||
        lower.endsWith('.jpeg') ||
        lower.endsWith('.png') ||
        lower.contains('image');
  }

  bool _isVideoUrl(String url) {
    final lower = url.toLowerCase();
    return lower.endsWith('.mp4') ||
        lower.endsWith('.mov') ||
        lower.contains('video');
  }

  bool _isAudioUrl(String url) {
    final lower = url.toLowerCase();
    return lower.endsWith('.aac') ||
        lower.endsWith('.mp3') ||
        lower.contains('audio');
  }
}

class _InlineMediaWidget extends StatefulWidget {
  final String mediaUrl;
  final bool isImage;
  final bool isVideo;
  final bool isAudio;

  final Color textColor;

  const _InlineMediaWidget({
    required this.mediaUrl,
    required this.isImage,
    required this.isVideo,
    required this.isAudio,
    required this.textColor,
  });

  @override
  State<_InlineMediaWidget> createState() => _InlineMediaWidgetState();
}

class _InlineMediaWidgetState extends State<_InlineMediaWidget> {
  VideoPlayerController? _videoController;
  ChewieController? _chewieController;
  bool _videoInitialized = false;
  final AudioPlayer _audioPlayer = AudioPlayer();
  bool _isPlaying = false;
  Duration _currentPosition = Duration.zero;
  Duration _totalDuration = Duration.zero;

  @override
  void initState() {
    super.initState();
    if (widget.isVideo) {
      _initVideo();
    } else if (widget.isAudio) {
      _initAudio();
    }
  }

  Future<void> _initVideo() async {
    _videoController =
        VideoPlayerController.networkUrl(Uri.parse(widget.mediaUrl));
    await _videoController!.initialize();
    _chewieController = ChewieController(
      videoPlayerController: _videoController!,
      autoPlay: false,
      looping: false,
      optionsTranslation: OptionsTranslation(
        playbackSpeedButtonText: 'Velocidade de reprodução',
        cancelButtonText: 'Cancelar',
      ),
      allowFullScreen: true,
      aspectRatio: _videoController!.value.aspectRatio,
    );
    setState(() {
      _videoInitialized = true;
    });
  }

  Future<void> _initAudio() async {
    _audioPlayer.onDurationChanged.listen((dur) {
      setState(() => _totalDuration = dur);
    });
    _audioPlayer.onPositionChanged.listen((pos) {
      setState(() => _currentPosition = pos);
    });
    _audioPlayer.onPlayerComplete.listen((event) {
      setState(() {
        _isPlaying = false;
        _currentPosition = Duration.zero;
      });
    });
    await _audioPlayer.play(UrlSource(widget.mediaUrl));
    await _audioPlayer.stop();
  }

  @override
  void dispose() {
    _videoController?.dispose();
    _chewieController?.dispose();
    _audioPlayer.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (widget.isImage) {
      return _buildImage();
    } else if (widget.isVideo) {
      return _buildVideo();
    } else if (widget.isAudio) {
      return _buildAudio();
    }
    return const SizedBox.shrink();
  }

  Widget _buildImage() {
    return GestureDetector(
      onTap: () {
        showDialog(
          context: context,
          builder: (_) => Dialog(
            insetPadding: EdgeInsets.zero,
            backgroundColor: Colors.black,
            child: InteractiveViewer(
              child: Image.network(widget.mediaUrl),
            ),
          ),
        );
      },
      child: ClipRRect(
        borderRadius: BorderRadius.circular(8),
        child: Image.network(
          widget.mediaUrl,
          width: 250,
          height: 250,
          fit: BoxFit.cover,
        ),
      ),
    );
  }

  Widget _buildVideo() {
    if (!_videoInitialized || _chewieController == null) {
      return const SizedBox(
        width: 50,
        height: 50,
        child: Center(child: CircularProgressIndicator()),
      );
    }
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        color: Colors.black12,
      ),
      child: AspectRatio(
        aspectRatio: 1,
        child: Chewie(controller: _chewieController!),
      ),
    );
  }

  Widget _buildAudio() {
    final configProvider = Provider.of<ConfigProvider>(context);

    return Container(
      width: 200,
      padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 8),
      decoration: BoxDecoration(
        color: Colors.black12,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            children: [
              IconButton(
                icon: Icon(_isPlaying ? Icons.pause : Icons.play_arrow),
                onPressed: _togglePlayPause,
                color: configProvider.iconColor,
              ),
              Expanded(
                child: Slider(
                  activeColor: configProvider.iconColor,
                  inactiveColor: configProvider.iconColor,
                  min: 0,
                  max: _totalDuration.inMilliseconds.toDouble(),
                  value: _currentPosition.inMilliseconds
                      .toDouble()
                      .clamp(0, _totalDuration.inMilliseconds.toDouble()),
                  onChanged: (value) {
                    final pos = Duration(milliseconds: value.floor());
                    _audioPlayer.seek(pos);
                  },
                ),
              ),
            ],
          ),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                _formatDuration(_currentPosition),
                style: TextStyle(
                  color: configProvider.iconColor,
                ),
              ),
              Text(
                _formatDuration(_totalDuration),
                style: TextStyle(
                  color: configProvider.iconColor,
                ),
              ),
            ],
          )
        ],
      ),
    );
  }

  Future<void> _togglePlayPause() async {
    if (_isPlaying) {
      await _audioPlayer.pause();
      setState(() => _isPlaying = false);
    } else {
      await _audioPlayer.play(UrlSource(widget.mediaUrl));
      setState(() => _isPlaying = true);
    }
  }

  String _formatDuration(Duration d) {
    String twoDigits(int n) => n.toString().padLeft(2, '0');
    final minutes = twoDigits(d.inMinutes.remainder(60));
    final seconds = twoDigits(d.inSeconds.remainder(60));
    return '$minutes:$seconds';
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\pages\privateChat\recent_page.dart ===
import 'dart:convert';
import 'dart:developer';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:snarf/pages/privateChat/private_chat_page.dart';
import 'package:snarf/providers/intercepted_image_provider.dart';
import 'package:snarf/services/signalr_manager.dart';
import 'package:snarf/utils/date_utils.dart';
import 'package:snarf/utils/show_snackbar.dart';
import 'package:snarf/enums/signalr_event_type.dart';
import 'package:snarf/providers/config_provider.dart';

class RecentPage extends StatefulWidget {
  final bool showFavorites;

  const RecentPage({super.key, this.showFavorites = false});

  @override
  _RecentChatPageState createState() => _RecentChatPageState();
}

class _RecentChatPageState extends State<RecentPage> {
  List<Map<String, dynamic>> _recentChats = [];
  List<String> _favoriteChatIds = [];
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _initializeSignalRConnection();
  }

  Future<void> _initializeSignalRConnection() async {
    SignalRManager().listenToEvent('ReceiveMessage', _handleSignalRMessage);

    await Future.wait([
      SignalRManager()
          .sendSignalRMessage(SignalREventType.PrivateChatGetRecentChats, {}),
      SignalRManager()
          .sendSignalRMessage(SignalREventType.PrivateChatGetFavorites, {}),
    ]);

    setState(() => _isLoading = false);
  }

  void _handleSignalRMessage(List<Object?>? args) {
    if (args == null || args.isEmpty) return;

    try {
      final Map<String, dynamic> message = jsonDecode(args[0] as String);
      final SignalREventType type = SignalREventType.values.firstWhere(
        (e) => e.toString().split('.').last == message['Type'],
      );

      final dynamic data = message['Data'];

      switch (type) {
        case SignalREventType.PrivateChatReceiveRecentChats:
          _handleRecentChats(data);
          break;
        case SignalREventType.PrivateChatReceiveFavorites:
          _handleFavoriteChats(data);
          break;
        case SignalREventType.PrivateChatReceiveMessage:
          _receiveNewMessages(data);
          break;
        case SignalREventType.MapReceiveLocation:
          _handleMapReceiveLocation(data);
          break;
        case SignalREventType.UserDisconnected:
          _handleUserDisconnected(data);
          break;
        default:
          log("Evento não reconhecido: ${message['Type']}");
      }
    } catch (e) {
      log("Erro ao processar mensagem SignalR: $e");
    }
  }

  void _handleRecentChats(List<Object?>? data) {
    final configProvider = Provider.of<ConfigProvider>(context, listen: false);
    try {
      final parsedData = data as List<dynamic>;
      setState(() {
        _recentChats = parsedData.map((item) {
          final mapItem = item is Map<String, dynamic>
              ? item
              : Map<String, dynamic>.from(item);

          DateTime? lastActivity;
          if (mapItem['LastActivity'] != null) {
            try {
              lastActivity =
                  DateTime.parse(mapItem['LastActivity'].toString()).toLocal();
            } catch (_) {
              lastActivity = null;
            }
          }

          var unread = mapItem['UnreadCount'];
          if(unread > 0){
            configProvider.setNotificationMessage(true);
          }
          
          return {
            'UserId': mapItem['UserId'],
            'UserName': mapItem['UserName'],
            'UserImage': mapItem['UserImage'],
            'LastMessage': mapItem['LastMessage'],
            'LastMessageDate': mapItem['LastMessageDate'],
            'UnreadCount': mapItem['UnreadCount'],
            'LastActivity': lastActivity,
          };
        }).toList();
      });
    } catch (e) {
      showErrorSnackbar(context, "Erro ao processar chats recentes: $e");
    }
  }

  void _handleFavoriteChats(List<Object?>? data) {
    try {
      if (data == null) return;
      final parsedData = data as List<dynamic>;
      setState(() {
        _favoriteChatIds =
            parsedData.map((item) => item['Id'].toString()).toList();
      });
    } catch (e) {
      showErrorSnackbar(context, "Erro ao processar favoritos: $e");
    }
  }

  Future<void> _receiveNewMessages(dynamic data) async {
    await SignalRManager()
        .sendSignalRMessage(SignalREventType.PrivateChatGetRecentChats, {});
  }

  void _handleMapReceiveLocation(dynamic data) {
    if (data is Map<String, dynamic>) {
      final String userId = data['userId'];
      final index = _recentChats.indexWhere((chat) => chat['UserId'] == userId);
      if (index != -1) {
        setState(() {
          _recentChats[index]['LastActivity'] = DateTime.now();
        });
      }
    }
  }

  void _handleUserDisconnected(dynamic data) {
    if (data is Map<String, dynamic>) {
      final String userId = data['userId'];
      final index = _recentChats.indexWhere((chat) => chat['UserId'] == userId);
      if (index != -1) {
        setState(() {
          _recentChats[index]['LastActivity'] =
              DateTime.now().subtract(const Duration(days: 1));
        });
      }
    }
  }

  List<Map<String, dynamic>> get _filteredChats {
    if (widget.showFavorites) {
      return _recentChats
          .where((chat) => _favoriteChatIds.contains(chat['UserId']))
          .toList();
    }
    return _recentChats;
  }

  @override
  void dispose() {
    log('Fechando conexão SignalR...');
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final configProvider = Provider.of<ConfigProvider>(context);

    return Scaffold(
      backgroundColor: configProvider.primaryColor,
      body: _isLoading
          ? Center(
              child: CircularProgressIndicator(
                color: configProvider.iconColor,
              ),
            )
          : _filteredChats.isEmpty
              ? Center(
                  child: Text(
                    'Nenhuma conversa encontrada.',
                    style: TextStyle(
                      fontSize: 16,
                      color: configProvider.textColor,
                    ),
                  ),
                )
              : ListView.builder(
                  itemCount: _filteredChats.length,
                  itemBuilder: (context, index) {
                    final chat = _filteredChats[index];

                    bool isOnline = false;
                    final lastActivity = chat['LastActivity'] as DateTime?;
                    if (lastActivity != null) {
                      final diff = DateTime.now().difference(lastActivity);
                      isOnline = diff.inMinutes < 1;
                    }

                    return ListTile(
                      leading: Stack(
                        children: [
                          CircleAvatar(
                            radius: 30,
                            backgroundColor: isOnline
                                ? configProvider.customGreen
                                : Colors.transparent,
                            child: Padding(
                              padding: const EdgeInsets.all(4),
                              child: ClipOval(
                                child: SizedBox(
                                  width: double.infinity,
                                  height: double.infinity,
                                  child: CircleAvatar(
                                    backgroundImage: InterceptedImageProvider(
                                      originalProvider:
                                          NetworkImage(chat['UserImage']),
                                      hideImages: configProvider.hideImages,
                                    ),
                                    radius: 18,
                                  ),
                                ),
                              ),
                            ),
                          ),
                          if (isOnline)
                            Positioned(
                              left: 10,
                              top: 4,
                              child: Container(
                                width: 12,
                                height: 12,
                                decoration: BoxDecoration(
                                  color: configProvider.customGreen,
                                  shape: BoxShape.circle,
                                  border: Border.all(
                                    color: configProvider.primaryColor,
                                    width: 2,
                                  ),
                                ),
                              ),
                            ),
                        ],
                      ),
                      title: Text(
                        chat['UserName'],
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          fontSize: 16,
                          color: configProvider.textColor,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                      subtitle: Text(
                        chat['LastMessage'].toString().startsWith('https://')
                            ? 'Arquivo'
                            : chat['LastMessage'],
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                        style: TextStyle(color: configProvider.textColor),
                      ),
                      trailing: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        crossAxisAlignment: CrossAxisAlignment.end,
                        children: [
                          Text(
                            DateJSONUtils.formatRelativeTime(
                                chat['LastMessageDate'].toString()),
                            style: TextStyle(
                              fontSize: 12,
                              color: configProvider.textColor.withOpacity(0.7),
                              fontStyle: FontStyle.italic,
                            ),
                          ),
                          if (chat['UnreadCount'] > 0)
                            const SizedBox(height: 4),
                          if (chat['UnreadCount'] > 0)
                            Stack(
                              alignment: Alignment.center,
                              children: [
                                Container(
                                  width: 24,
                                  height: 24,
                                  decoration: BoxDecoration(
                                    color: configProvider.customOrange,
                                    shape: BoxShape.circle,
                                  ),
                                ),
                                Positioned(
                                  right: 0,
                                  child: Padding(
                                    padding: const EdgeInsets.only(right: 10),
                                    child: Text(
                                      '${chat['UnreadCount']}',
                                      style: TextStyle(
                                        color: configProvider.textColor,
                                        fontSize: 12,
                                        fontWeight: FontWeight.bold,
                                      ),
                                      textAlign: TextAlign.center,
                                    ),
                                  ),
                                ),
                              ],
                            ),
                        ],
                      ),
                      onTap: () async {
                        await Navigator.push(
                          context,
                          MaterialPageRoute(
                            builder: (context) => PrivateChatPage(
                              userId: chat['UserId'],
                              userName: chat['UserName'],
                              userImage: chat['UserImage'],
                            ),
                          ),
                        );
                      },
                    );
                  },
                ),
    );
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\providers\call_manager.dart ===
import 'dart:convert';
import 'dart:developer';
import 'package:flutter/foundation.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:jitsi_meet_flutter_sdk/jitsi_meet_flutter_sdk.dart';
import 'package:firebase_analytics/firebase_analytics.dart';
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:provider/provider.dart';
import 'package:snarf/providers/config_provider.dart';

import 'package:snarf/services/signalr_manager.dart';
import 'package:snarf/enums/signalr_event_type.dart';

class CallManager extends ChangeNotifier {
  final JitsiMeet jitsiMeet = JitsiMeet();
  final ConfigProvider configProvider;

  bool _isInCall = false;
  bool _isCallOverlayVisible = false;
  bool _isCallRejectedOverlayVisible = false;

  String? _activeRoomId;
  String? _activeCallerUserId;
  String? _activeCallerName;

  String? _incomingRoomId;
  String? _incomingCallerUserId;
  String? _incomingCallerName;

  bool get isInCall => _isInCall;

  bool get isCallOverlayVisible => _isCallOverlayVisible;

  String? get incomingRoomId => _incomingRoomId;

  String? get incomingCallerUserId => _incomingCallerUserId;

  String? get incomingCallerName => _incomingCallerName;

  String? get activeRoomId => _activeRoomId;

  String? get activeCallerUserId => _activeCallerUserId;

  String? get activeCallerName => _activeCallerName;

  bool get isCallRejectedOverlayVisible => _isCallRejectedOverlayVisible;
  String _callRejectionReason = "";

  String get callRejectionReason => _callRejectionReason;

  CallManager(this.configProvider) {
    _setupCallSignals();
  }

  void _setupCallSignals() {
    SignalRManager().listenToEvent("ReceiveMessage", _onReceiveMessage);
  }

  void _onReceiveMessage(List<Object?>? args) {
    if (args == null || args.isEmpty) return;

    try {
      final Map<String, dynamic> message = jsonDecode(args[0] as String);

      final SignalREventType type = SignalREventType.values.firstWhere(
        (e) => e.toString().split('.').last == message['Type'],
        orElse: () => SignalREventType.MapReceiveLocation,
      );

      final dynamic data = message['Data'];

      switch (type) {
        case SignalREventType.VideoCallIncoming:
          _handleVideoCallIncoming(data);
          break;
        case SignalREventType.VideoCallAccept:
          _handleVideoCallAccept(data);
          break;
        case SignalREventType.VideoCallReject:
          _handleVideoCallReject(data);
          break;
        case SignalREventType.VideoCallEnd:
          _handleVideoCallEnd(data);
          break;
          case SignalREventType.PrivateChatReceiveMessage:
          _handleReceivedNewMessage(data);
          break;
        case SignalREventType.PrivateChatReceiveRecentChats:
          _handleRecentChats(data);
          break;
        default:
          break;
      }
    } catch (e, s) {
      FirebaseCrashlytics.instance.recordError(
        e,
        s,
        reason: "Erro ao processar mensagem SignalR",
      );
    }
  }

  void _handleReceivedNewMessage(dynamic data) {
    configProvider.setNotificationMessage(true);
  }

  void _handleRecentChats(List<Object?>? data) {
    try {
      final parsedData = data as List<dynamic>;
      parsedData.map((item) {
        final mapItem = item is Map<String, dynamic>
            ? item
            : Map<String, dynamic>.from(item);
        
        var count = mapItem['UnreadCount'];
        
        if(count > 0){
          configProvider.setNotificationMessage(true);
        }
      }).toList();
    } catch (e, s) {
      FirebaseCrashlytics.instance
          .recordError(e, s, reason: "Erro ao iniciar chamada");
    }
  }

  void _handleVideoCallIncoming(Map<String, dynamic> data) {
    if (!configProvider.isSubscriber) {
      _handleVideoCallReject(data);
      return;
    }

    final newRoomId = data['roomId'] as String?;
    final newCallerUserId = data['callerUserId'] as String?;
    final newCallerUserName = data['callerName'] as String?;

    _incomingRoomId = newRoomId;
    _incomingCallerUserId = newCallerUserId;
    _incomingCallerName = newCallerUserName;
    _isCallOverlayVisible = true;

    FirebaseAnalytics.instance.logEvent(
      name: 'video_call_incoming',
      parameters: {
        'roomId': newRoomId!,
        'callerUserId': newCallerUserId!,
        'callerName': newCallerUserName!,
      },
    );

    notifyListeners();
  }

  void _handleVideoCallAccept(Map<String, dynamic> data) {
    final acceptedRoomId = data['roomId'];

    FirebaseAnalytics.instance.logEvent(
      name: 'video_call_accepted',
      parameters: {
        'roomId': acceptedRoomId,
      },
    );

    _joinJitsiRoom(acceptedRoomId);
  }

  void _handleVideoCallReject(Map<String, dynamic> data) {
    final rejectedRoomId = data['roomId'];
    final reason = data['reason'] as String? ?? "Chamada rejeitada.";

    FirebaseAnalytics.instance.logEvent(
      name: 'video_call_rejected',
      parameters: {
        'roomId': rejectedRoomId ?? '',
        'reason': reason,
      },
    );

    if (rejectedRoomId == _activeRoomId) {
      _finishCall();
    }

    _callRejectionReason = reason;
    _isCallRejectedOverlayVisible = true;
    notifyListeners();
  }

  void closeRejectionOverlay() {
    _isCallRejectedOverlayVisible = false;
    _callRejectionReason = "";
    notifyListeners();
  }

  void _handleVideoCallEnd(Map<String, dynamic> data) {
    final endedRoomId = data['roomId'];

    FirebaseAnalytics.instance.logEvent(
      name: 'video_call_ended',
      parameters: {
        'roomId': endedRoomId,
      },
    );

    if (endedRoomId == _activeRoomId) {
      _finishCall();
    }
    notifyListeners();
  }

  Future<void> acceptCall() async {
    if (_isInCall && _incomingRoomId != null) {
      FirebaseAnalytics.instance.logEvent(
        name: 'accept_call_while_in_call',
        parameters: {
          'message': "Encerrando chamada ativa para aceitar a nova",
        },
      );
      await _endCurrentCall();
    }

    if (_incomingRoomId == null || _incomingCallerUserId == null) return;

    await SignalRManager().sendSignalRMessage(
      SignalREventType.VideoCallAccept,
      {
        "CallerUserId": _incomingCallerUserId,
        "RoomId": _incomingRoomId,
      },
    );

    _activeRoomId = _incomingRoomId;
    _activeCallerUserId = _incomingCallerUserId;
    _activeCallerName = _incomingCallerName;

    _incomingRoomId = null;
    _incomingCallerUserId = null;
    _incomingCallerName = null;
    _isCallOverlayVisible = false;

    _joinJitsiRoom(_activeRoomId!);
    notifyListeners();
  }

  Future<void> rejectCall() async {
    if (_incomingRoomId == null || _incomingCallerUserId == null) return;

    await SignalRManager().sendSignalRMessage(
      SignalREventType.VideoCallReject,
      {
        "CallerUserId": _incomingCallerUserId,
        "RoomId": _incomingRoomId,
      },
    );

    _incomingRoomId = null;
    _incomingCallerUserId = null;
    _incomingCallerName = null;
    _isCallOverlayVisible = false;

    notifyListeners();
  }

  Future<void> startCall(String targetUserId) async {
    try {
      await SignalRManager().sendSignalRMessage(
        SignalREventType.VideoCallInitiate,
        {
          "TargetUserId": targetUserId,
        },
      );

      FirebaseAnalytics.instance.logEvent(
        name: 'video_call_start',
        parameters: {
          'targetUserId': targetUserId,
        },
      );
    } catch (e, s) {
      FirebaseCrashlytics.instance
          .recordError(e, s, reason: "Erro ao iniciar chamada");
    }
  }

  Future<void> _joinJitsiRoom(String roomId) async {
    _isInCall = true;
    notifyListeners();

    final options = JitsiMeetConferenceOptions(
      room: roomId,
      userInfo: JitsiMeetUserInfo(
        displayName: _activeCallerName,
      ),
      serverURL: 'https://snarf-meet.inovitech.inf.br',
    );

    jitsiMeet.join(
      options,
      JitsiMeetEventListener(
        participantLeft: (message) async {
          await _endCurrentCall();
        },
        conferenceTerminated: (message, error) async {
          await _endCurrentCall();
        },
      ),
    );
  }

  Future<void> _endCurrentCall() async {
    if (_activeRoomId != null) {
      await SignalRManager().sendSignalRMessage(
        SignalREventType.VideoCallEnd,
        {
          "RoomId": _activeRoomId,
        },
      );
    }
    _finishCall();
  }

  void _finishCall() {
    jitsiMeet.hangUp();
    _isInCall = false;
    _activeRoomId = null;
    _activeCallerUserId = null;
    _activeCallerName = null;
    _isCallOverlayVisible = false;
    notifyListeners();
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\providers\config_provider.dart ===
import 'package:flutter/material.dart';

class ConfigProvider with ChangeNotifier {
  bool _isDarkMode = true;

  bool get isDarkMode => _isDarkMode;

  Color get primaryColor => _isDarkMode ? darkPrimaryColor : lightPrimaryColor;

  Color get darkPrimaryColor => const Color(0xFF0b0951);

  Color get lightPrimaryColor => const Color(0xFFFFEBFA);

  Color get secondaryColor =>
      _isDarkMode ? darkSecondaryColor : lightSecondaryColor;

  Color get darkSecondaryColor => const Color(0xFF4c2a85);
  Color get lightSecondaryColor => const Color(0xFF6260F3);

  Color get textColor => _isDarkMode ? darkTextColor : lightTextColor;

  Color get darkTextColor => Colors.white;

  Color get lightTextColor => Colors.black;

  Color get customGreen => const Color(0xFF008000);

  Color get customOrange => const Color(0xFFFFA500);

  Color get customWhite => const Color(0xFFFFFFFF);

  Color get customBlue => const Color(0xFF0000FF);

  Color get customRed => const Color(0xFFFF0000);

  Color get iconColor => isDarkMode ? Colors.white : Colors.black;

  void toggleTheme() {
    _isDarkMode = !_isDarkMode;
    notifyListeners();
  }

  void setLightTheme() {
    _isDarkMode = false;
    notifyListeners();
  }

  void setDarkTheme() {
    _isDarkMode = true;
    notifyListeners();
  }

  bool _hideImages = false;

  bool get hideImages => _hideImages;

  void toggleHideImages() {
    _hideImages = !_hideImages;
    notifyListeners();
  }

  bool _hideVideoCall = false;

  bool get hideVideoCall => _hideVideoCall;

  void toggleVideoCall() {
    _hideVideoCall = !_hideVideoCall;
    notifyListeners();
  }

  List<bool> _statisticsList = List.filled(5, false);
  bool getStatistic(int index) => _statisticsList[index];

  void toggleStatistic(int index){
    _statisticsList[index] = !_statisticsList[index];
    notifyListeners();
  }

  List<bool> _sexualityList = List.filled(3, false);
  bool getSexuality(int index) => _sexualityList[index];

  void toggleSexuality(int index){
    _sexualityList[index] = !_sexualityList[index];
    notifyListeners();
  }

  List<bool> _sceneList = List.filled(7, false);
  bool getScene(int index) => _sceneList[index];

  void toggleScene(int index){
    _sceneList[index] = !_sceneList[index];
    notifyListeners();
  }

  List<bool> _preferencesList = List.filled(7, false);
  bool getPreferences(int index) => _preferencesList[index];

  void togglePreferences(int index){
    _preferencesList[index] = !_preferencesList[index];
    notifyListeners();
  }

  bool _isSubscriber = false;

  void setIsSubscriber(bool subscriber){
    _isSubscriber = subscriber;
    notifyListeners();
  }

  bool get isSubscriber => _isSubscriber;

  bool _notificationMessage = false;

  bool get notificationMessage => _notificationMessage;

  void setNotificationMessage(bool value){
    _notificationMessage =value;
    notifyListeners();
  }

  DateTime? _firstMessageToday;

  void setFirstMessageToday(DateTime date){
    _firstMessageToday = date;
    notifyListeners();
  }

  DateTime? get firstMessageToday => _firstMessageToday;


  bool _usePreciseLocation = false;
  bool get usePreciseLocation => _usePreciseLocation;

  void toggleUsePreciseLocation() {
    _usePreciseLocation = !_usePreciseLocation;
    notifyListeners();
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\providers\intercepted_image_provider.dart ===
import 'dart:async';
import 'dart:ui' as ui;
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

class InterceptedImageProvider extends ImageProvider<InterceptedImageProvider> {
  final ImageProvider originalProvider;
  final bool hideImages;

  static final Map<ImageProvider, ImageInfo> _originalImageCache = {};
  static final Map<ImageProvider, ImageInfo> _blockedImageCache = {};

  InterceptedImageProvider({
    required this.originalProvider,
    required this.hideImages,
  });

  @override
  Future<InterceptedImageProvider> obtainKey(ImageConfiguration configuration) {
    return SynchronousFuture<InterceptedImageProvider>(this);
  }

  @override
  ImageStreamCompleter loadImage(
      InterceptedImageProvider key, ImageDecoderCallback decode) {
    if (hideImages) {
      if (!_blockedImageCache.containsKey(originalProvider)) {
        _blockedImageCache[originalProvider] = ImageInfo(
          image: _generateBlockedImage(),
          scale: 1.0,
        );
      }

      return OneFrameImageStreamCompleter(
        Future.value(_blockedImageCache[originalProvider]!.clone()),
      );
    }

    if (_originalImageCache.containsKey(originalProvider)) {
      return OneFrameImageStreamCompleter(
        Future.value(_originalImageCache[originalProvider]!.clone()),
      );
    }

    final completer = Completer<ImageInfo>();
    final stream = originalProvider.resolve(ImageConfiguration.empty);

    stream.addListener(
      ImageStreamListener((imageInfo, _) {
        _originalImageCache[originalProvider] = imageInfo;
        completer.complete(imageInfo.clone());
      }),
    );

    return OneFrameImageStreamCompleter(completer.future);
  }

  ui.Image _generateBlockedImage() {
    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);
    final paint = Paint()..color = _getRandomColor();
    canvas.drawRect(Rect.fromLTWH(0, 0, 100, 100), paint);
    final picture = recorder.endRecording();
    return picture.toImageSync(100, 100);
  }

  Color _getRandomColor() {
    final random = Random();
    return Color.fromARGB(
      255,
      random.nextInt(256),
      random.nextInt(256),
      random.nextInt(256),
    );
  }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\services\api_service.dart ===
import 'dart:convert';
import 'dart:developer';
import 'package:firebase_analytics/firebase_analytics.dart';
import 'package:http/http.dart' as http;
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:jwt_decode/jwt_decode.dart';
import 'package:snarf/utils/api_constants.dart';

class ApiService {
  static const _secureStorage = FlutterSecureStorage();
  static final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;

  static Future<String?> login(String email, String password) async {
    final url = Uri.parse('${ApiConstants.baseUrl}/Account/Login');
    final headers = {'Content-Type': 'application/json'};
    final body = jsonEncode({'email': email, 'password': password});
    try {
      await _analytics.logEvent(name: 'api_login_attempt');
      final response = await http.post(url, headers: headers, body: body);
      if (response.statusCode == 200) {
        final Map<String, dynamic> responseData = jsonDecode(response.body);
        if (responseData['object'] != null &&
            responseData['object']['token'] != null) {
          final token = responseData['object']['token'];
          await _secureStorage.write(key: 'token', value: token);
          await _analytics.logEvent(name: 'api_login_success');
          return null;
        }
      }
      final responseData = jsonDecode(response.body);
      await _analytics.logEvent(
        name: 'api_login_failure',
        parameters: {'error': responseData['message'] ?? 'Erro desconhecido'},
      );
      return responseData['message'] ?? 'Erro desconhecido';
    } catch (e) {
      await _analytics.logEvent(
          name: 'api_login_exception', parameters: {'error': e.toString()});
      return 'Erro ao conectar à API: $e';
    }
  }

  static Future<String?> register(
      String email, String name, String password, String image) async {
    final url = Uri.parse('${ApiConstants.baseUrl}/Account');
    final headers = {'Content-Type': 'application/json'};
    final body = jsonEncode({
      'email': email,
      'name': name,
      'password': password,
      'images': [image]
    });
    try {
      await _analytics.logEvent(name: 'api_register_attempt');
      final response = await http.post(url, headers: headers, body: body);
      if (response.statusCode == 200) {
        await _analytics.logEvent(name: 'api_register_success');
        return null;
      } else {
        final responseData = jsonDecode(response.body);
        await _analytics.logEvent(
          name: 'api_register_failure',
          parameters: {'error': responseData['message'] ?? 'Erro desconhecido'},
        );
        return responseData['message'] ?? 'Erro desconhecido';
      }
    } catch (e) {
      await _analytics.logEvent(
          name: 'api_register_exception', parameters: {'error': e.toString()});
      return 'Erro ao conectar à API: $e';
    }
  }

  static Future<String?> requestResetPassword(String email) async {
    final url =
        Uri.parse('${ApiConstants.baseUrl}/Account/RequestResetPassword');
    final headers = {'Content-Type': 'application/json'};
    try {
      await _analytics.logEvent(name: 'api_request_reset_password_attempt');
      final response =
          await http.post(url, headers: headers, body: jsonEncode(email));
      if (response.statusCode == 200) {
        await _analytics.logEvent(name: 'api_request_reset_password_success');
        return null;
      }
      final responseData = jsonDecode(response.body);
      await _analytics.logEvent(
        name: 'api_request_reset_password_failure',
        parameters: {'error': responseData['message'] ?? 'Erro desconhecido'},
      );
      return responseData['message'] ?? 'Erro desconhecido';
    } catch (e) {
      await _analytics.logEvent(
          name: 'api_request_reset_password_exception',
          parameters: {'error': e.toString()});
      return 'Erro ao conectar à API: $e';
    }
  }

  static Future<String?> resetPassword(
      String email, String code, String password) async {
    final url = Uri.parse('${ApiConstants.baseUrl}/Account/ResetPassword');
    final headers = {'Content-Type': 'application/json'};
    final body =
        jsonEncode({'email': email, 'code': code, 'password': password});
    try {
      await _analytics.logEvent(name: 'api_reset_password_attempt');
      final response = await http.post(url, headers: headers, body: body);
      if (response.statusCode == 200) {
        await _analytics.logEvent(name: 'api_reset_password_success');
        return null;
      }
      final responseData = jsonDecode(response.body);
      await _analytics.logEvent(
        name: 'api_reset_password_failure',
        parameters: {'error': responseData['message'] ?? 'Erro desconhecido'},
      );
      return responseData['message'] ?? 'Erro desconhecido';
    } catch (e) {
      await _analytics.logEvent(
          name: 'api_reset_password_exception',
          parameters: {'error': e.toString()});
      return 'Erro ao conectar à API: $e';
    }
  }

  static Future<String?> getUserIdFromToken() async {
    final token = await ApiService.getToken();
    if (token != null) {
      Map<String, dynamic> payload = Jwt.parseJwt(token);
      return payload['nameid'];
    }
    return null;
  }

  static Future<String?> blockUser(String blockedUserId) async {
    final token = await ApiService.getToken();
    if (token == null) return 'Token não encontrado';
    final url = Uri.parse(
        '${ApiConstants.baseUrl}/Account/BlockUser?blockedUserId=$blockedUserId');
    try {
      await _analytics.logEvent(
          name: 'api_block_user_attempt',
          parameters: {'blockedUserId': blockedUserId});
      final response = await http.post(url,
          headers: {'accept': '*/*', 'Authorization': 'Bearer $token'});
      if (response.statusCode == 200) {
        await _analytics.logEvent(
            name: 'api_block_user_success',
            parameters: {'blockedUserId': blockedUserId});
        return null;
      } else {
        final responseData = jsonDecode(response.body);
        await _analytics.logEvent(
          name: 'api_block_user_failure',
          parameters: {
            'error': responseData['message'] ?? 'Erro ao bloquear usuário'
          },
        );
        return responseData['message'] ?? 'Erro ao bloquear usuário';
      }
    } catch (e) {
      await _analytics.logEvent(
          name: 'api_block_user_exception',
          parameters: {'error': e.toString()});
      return 'Erro ao conectar à API: $e';
    }
  }

  static Future<String?> unblockUser(String blockedUserId) async {
    final token = await ApiService.getToken();
    if (token == null) return 'Token não encontrado';
    final url = Uri.parse(
        '${ApiConstants.baseUrl}/Account/UnblockUser?blockedUserId=$blockedUserId');
    try {
      await _analytics.logEvent(
          name: 'api_unblock_user_attempt',
          parameters: {'blockedUserId': blockedUserId});
      final response = await http.post(url,
          headers: {'accept': '*/*', 'Authorization': 'Bearer $token'});
      if (response.statusCode == 200) {
        await _analytics.logEvent(
            name: 'api_unblock_user_success',
            parameters: {'blockedUserId': blockedUserId});
        return null;
      } else {
        final responseData = jsonDecode(response.body);
        await _analytics.logEvent(
          name: 'api_unblock_user_failure',
          parameters: {
            'error': responseData['message'] ?? 'Erro ao desbloquear usuário'
          },
        );
        return responseData['message'] ?? 'Erro ao desbloquear usuário';
      }
    } catch (e) {
      await _analytics.logEvent(
          name: 'api_unblock_user_exception',
          parameters: {'error': e.toString()});
      return 'Erro ao conectar à API: $e';
    }
  }

  static Future<Map<String, dynamic>?> getUserInfoById(String userId) async {
    final token = await ApiService.getToken();
    if (token == null) return null;
    try {
      await _analytics.logEvent(
          name: 'api_get_user_info_attempt', parameters: {'userId': userId});
      final response = await http.get(
        Uri.parse('${ApiConstants.baseUrl}/Account/GetUser/$userId'),
        headers: {'accept': '*/*', 'Authorization': 'Bearer $token'},
      );
      if (response.statusCode == 200) {
        final Map<String, dynamic> responseData = jsonDecode(response.body);
        await _analytics.logEvent(
            name: 'api_get_user_info_success', parameters: {'userId': userId});
        return responseData['object'];
      } else {
        log('Erro ao obter informações do usuário: ${response.body}');
        await _analytics.logEvent(
          name: 'api_get_user_info_failure',
          parameters: {'error': response.body},
        );
        return null;
      }
    } catch (e) {
      await _analytics.logEvent(
          name: 'api_get_user_info_exception',
          parameters: {'error': e.toString()});
      return null;
    }
  }

  static Future<Map<String, dynamic>?> getFirstMessageOfDay() async {
    final token = await ApiService.getToken();
    if (token == null) return null;
    try {
      await _analytics.logEvent(name: 'api_get_first_message_today_attempt');
      final response = await http.get(
        Uri.parse('${ApiConstants.baseUrl}/Account/GetFirstMessageToday'),
        headers: {'accept': '*/*', 'Authorization': 'Bearer $token'},
      );
      if (response.statusCode == 200) {
        final Map<String, dynamic> responseData = jsonDecode(response.body);
        await _analytics.logEvent(name: 'api_get_first_message_today_success');
        return responseData['object'];
      } else {
        log('Erro ao obter informações do usuário: ${response.body}');
        await _analytics.logEvent(
          name: 'api_get_first_message_today_failure',
          parameters: {'error': response.body},
        );
        return null;
      }
    } catch (e) {
      await _analytics.logEvent(
          name: 'api_get_first_message_today_exception',
          parameters: {'error': e.toString()});
      return null;
    }
  }

  static Future<String?> editUser(
    String userId,
    String name,
    String email,
    String? password,
    String? base64Image,
  ) async {
    final token = await ApiService.getToken();
    if (token == null) return 'Token não encontrado';
    final body = jsonEncode({
      'email': email,
      'name': name,
      'password': password,
      'Image': base64Image,
    });
    try {
      await _analytics.logEvent(
          name: 'api_edit_user_attempt', parameters: {'userId': userId});
      final response = await http.put(
        Uri.parse('${ApiConstants.baseUrl}/Account/$userId'),
        headers: {
          'accept': '*/*',
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $token',
        },
        body: body,
      );
      if (response.statusCode == 200) {
        await _analytics.logEvent(
            name: 'api_edit_user_success', parameters: {'userId': userId});
        return null;
      } else {
        await _analytics.logEvent(
          name: 'api_edit_user_failure',
          parameters: {'error': response.body},
        );
        return 'Erro ao editar usuário: ${response.body}';
      }
    } catch (e) {
      await _analytics.logEvent(
          name: 'api_edit_user_exception', parameters: {'error': e.toString()});
      return 'Erro ao conectar à API: $e';
    }
  }

  static Future<String?> deleteUser(String userId) async {
    final token = await ApiService.getToken();
    if (token == null) return 'Token não encontrado';
    try {
      await _analytics.logEvent(
          name: 'api_delete_user_attempt', parameters: {'userId': userId});
      final response = await http.delete(
        Uri.parse('${ApiConstants.baseUrl}/Account/$userId'),
        headers: {'accept': '*/*', 'Authorization': 'Bearer $token'},
      );
      if (response.statusCode == 200) {
        await _analytics.logEvent(
            name: 'api_delete_user_success', parameters: {'userId': userId});
        return null;
      } else {
        await _analytics.logEvent(
          name: 'api_delete_user_failure',
          parameters: {'error': response.body},
        );
        return 'Erro ao deletar usuário: ${response.body}';
      }
    } catch (e) {
      await _analytics.logEvent(
          name: 'api_delete_user_exception',
          parameters: {'error': e.toString()});
      return 'Erro ao conectar à API: $e';
    }
  }

  static Future<String?> reportMessage(String messageId) async {
    final token = await getToken();
    if (token == null) return 'Token não encontrado';
    final url = Uri.parse(
        '${ApiConstants.baseUrl}/Account/ReportUserPublicMessage?messageId=$messageId');
    try {
      await _analytics.logEvent(
          name: 'api_report_message_attempt',
          parameters: {'messageId': messageId});
      final response = await http.post(url,
          headers: {'accept': '*/*', 'Authorization': 'Bearer $token'});
      if (response.statusCode == 200) {
        await _analytics.logEvent(
            name: 'api_report_message_success',
            parameters: {'messageId': messageId});
        return null;
      } else {
        final responseData = jsonDecode(response.body);
        await _analytics.logEvent(
          name: 'api_report_message_failure',
          parameters: {
            'error': responseData['message'] ?? 'Erro ao denunciar mensagem'
          },
        );
        return responseData['message'] ?? 'Erro ao denunciar mensagem';
      }
    } catch (e) {
      await _analytics.logEvent(
          name: 'api_report_message_exception',
          parameters: {'error': e.toString()});
      return 'Erro ao conectar à API: $e';
    }
  }

  static Future<String?> reportUser(String userId) async {
    final token = await getToken();
    if (token == null) return 'Token não encontrado';
    final url =
        Uri.parse('${ApiConstants.baseUrl}/Account/ReportUser?userId=$userId');
    try {
      await _analytics.logEvent(
          name: 'api_report_user_attempt', parameters: {'userId': userId});
      final response = await http.post(url,
          headers: {'accept': '*/*', 'Authorization': 'Bearer $token'});
      if (response.statusCode == 200) {
        await _analytics.logEvent(
            name: 'api_report_user_success', parameters: {'userId': userId});
        return null;
      } else {
        final responseData = jsonDecode(response.body);
        await _analytics.logEvent(
          name: 'api_report_user_failure',
          parameters: {
            'error': responseData['message'] ?? 'Erro ao denunciar mensagem'
          },
        );
        return responseData['message'] ?? 'Erro ao denunciar mensagem';
      }
    } catch (e) {
      await _analytics.logEvent(
          name: 'api_report_user_exception',
          parameters: {'error': e.toString()});
      return 'Erro ao conectar à API: $e';
    }
  }

  static Future<String?> addExtraMinutes({
    required int minutes,
    String? subscriptionId,
    String? tokenFromPurchase,
  }) async {
    final userJwtToken = await getToken();
    final url = Uri.parse('${ApiConstants.baseUrl}/Account/AddExtraMinutes');
    final headers = {
      'accept': '*/*',
      'Content-Type': 'application/json',
      'Authorization': 'Bearer $userJwtToken',
    };
    final body = jsonEncode({
      "subscriptionId": subscriptionId ?? "string",
      "token": tokenFromPurchase ?? "string",
      "minutes": minutes,
    });
    try {
      await _analytics.logEvent(
        name: 'api_add_extra_minutes_attempt',
        parameters: {
          'minutes': minutes,
        },
      );
      final response = await http.post(url, headers: headers, body: body);
      if (response.statusCode == 200) {
        await _analytics.logEvent(
          name: 'api_add_extra_minutes_success',
          parameters: {
            'minutes': minutes,
          },
        );
        return null;
      } else {
        await _analytics.logEvent(
          name: 'api_add_extra_minutes_failure',
          parameters: {
            'minutes': minutes,
            'statusCode': response.statusCode,
            'error': response.body,
          },
        );
        return 'Erro: ${response.body}';
      }
    } catch (e) {
      await _analytics.logEvent(
        name: 'api_add_extra_minutes_exception',
        parameters: {
          'minutes': minutes,
          'error': e.toString(),
        },
      );
      return 'Exceção: $e';
    }
  }

  static Future<String?> changeEmail({
    required String newEmail,
    required String currentPassword,
  }) async {
    final token = await getToken();
    final url = Uri.parse('${ApiConstants.baseUrl}/Account/ChangeEmail');
    final headers = {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer $token',
    };
    final body = jsonEncode({
      'newEmail': newEmail,
      'currentPassword': currentPassword,
    });
    try {
      await FirebaseAnalytics.instance
          .logEvent(name: 'api_change_email_attempt');
      final response = await http.post(url, headers: headers, body: body);
      if (response.statusCode == 200) {
        await FirebaseAnalytics.instance
            .logEvent(name: 'api_change_email_success');
        return null;
      } else {
        final responseData = jsonDecode(response.body);
        await FirebaseAnalytics.instance.logEvent(
          name: 'api_change_email_failure',
          parameters: {'error': responseData.toString()},
        );
        return responseData['message'];
      }
    } catch (e) {
      await FirebaseAnalytics.instance.logEvent(
        name: 'api_change_email_exception',
        parameters: {'error': e.toString()},
      );
      return 'Erro ao conectar à API: $e';
    }
  }

  static Future<String?> changePassword({
    required String oldPassword,
    required String newPassword,
  }) async {
    final token = await getToken();
    final url = Uri.parse('${ApiConstants.baseUrl}/Account/ChangePassword');
    final headers = {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer $token',
    };
    final body = jsonEncode({
      'oldPassword': oldPassword,
      'newPassword': newPassword,
    });
    try {
      await FirebaseAnalytics.instance
          .logEvent(name: 'api_change_password_attempt');
      final response = await http.post(url, headers: headers, body: body);
      if (response.statusCode == 200) {
        await FirebaseAnalytics.instance
            .logEvent(name: 'api_change_password_success');
        return null;
      } else {
        final responseData = jsonDecode(response.body);
        await FirebaseAnalytics.instance.logEvent(
          name: 'api_change_password_failure',
          parameters: {'error': responseData.toString()},
        );
        return responseData['message'];
      }
    } catch (e) {
      await FirebaseAnalytics.instance.logEvent(
        name: 'api_change_password_exception',
        parameters: {'error': e.toString()},
      );
      return 'Erro ao conectar à API: $e';
    }
  }

  static Future<String?> getToken() async {
    return await _secureStorage.read(key: 'token');
  }

  static Future<void> logout() async {
    await _secureStorage.delete(key: 'token');
    await _analytics.logEvent(name: 'api_logout');
  }

  static Future<Map<String, dynamic>?> createParty({
    required String email,
    required String title,
    required String description,
    required DateTime startDate,
    required int duration,
    required int type,
    required String location,
    required String instructions,
    required double latitude,
    required double longitude,
    required String coverImageBase64,
  }) async {
    final token = await getToken();
    if (token == null) return null;
    final url = Uri.parse('${ApiConstants.baseUrl}/Party');
    final headers = {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer $token',
    };
    final body = jsonEncode({
      "email": email,
      "title": title,
      "description": description,
      "startDate": startDate.toUtc().toIso8601String(),
      "duration": duration,
      "type": type,
      "location": location,
      "instructions": instructions,
      "lastLatitude": latitude,
      "lastLongitude": longitude,
      "coverImage": coverImageBase64
    });
    try {
      final response = await http.post(url, headers: headers, body: body);
      if (response.statusCode == 200) {
        final json = jsonDecode(response.body);
        return json['object'];
      }
      return null;
    } catch (e) {
      return null;
    }
  }

  static Future<Map<String, dynamic>?> updateParty({
    required String partyId,
    required String title,
    required String description,
    required String location,
    required String instructions,
    required DateTime startDate,
    required int duration,
  }) async {
    final token = await getToken();
    if (token == null) return null;
    final url = Uri.parse('${ApiConstants.baseUrl}/Party/$partyId');
    final headers = {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer $token',
    };
    final body = jsonEncode({
      "title": title,
      "description": description,
      "location": location,
      "instructions": instructions,
      "startDate": startDate.toUtc().toIso8601String(),
      "duration": duration
    });
    try {
      final response = await http.put(url, headers: headers, body: body);
      if (response.statusCode == 200) {
        final json = jsonDecode(response.body);
        return json['object'];
      }
      return null;
    } catch (e) {
      return null;
    }
  }

  static Future<Map<String, dynamic>?> getAllParties(String userId) async {
    final token = await getToken();
    if (token == null) return null;
    final url = Uri.parse('${ApiConstants.baseUrl}/Party/all$userId');
    try {
      final response = await http.get(url, headers: {
        'accept': '*/*',
        'Authorization': 'Bearer $token',
      });
      if (response.statusCode == 200) {
        final Map<String, dynamic> responseData = jsonDecode(response.body);
        return responseData['object'] is List
            ? {"data": responseData['object']}
            : null;
      }
      return null;
    } catch (e) {
      return null;
    }
  }

  static Future<Map<String, dynamic>?> getPartyDetails({
    required String partyId,
    required String userId,
  }) async {
    final token = await getToken();
    if (token == null) return null;
    final url =
        Uri.parse('${ApiConstants.baseUrl}/Party/$partyId/details/$userId');
    try {
      final response = await http.get(url, headers: {
        'accept': '*/*',
        'Authorization': 'Bearer $token',
      });
      if (response.statusCode == 200) {
        final Map<String, dynamic> responseData = jsonDecode(response.body);
        return responseData['object'];
      }
      return null;
    } catch (e) {
      return null;
    }
  }

  static Future<bool> requestPartyParticipation({
    required String partyId,
    required String userId,
  }) async {
    final token = await getToken();
    if (token == null) return false;
    final url =
        Uri.parse('${ApiConstants.baseUrl}/Party/$partyId/invite-users');
    final headers = {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer $token',
    };
    final userIds = [userId];
    final body = jsonEncode(userIds);
    try {
      final response = await http.put(url, headers: headers, body: body);
      if (response.statusCode == 200) {
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }

  static Future<Map<String, dynamic>?> getAllParticipants(
      String partyId, String userId) async {
    final token = await getToken();
    if (token == null) return null;
    final url =
        Uri.parse('${ApiConstants.baseUrl}/Party/$partyId/all-users/$userId');
    try {
      final response = await http.get(url, headers: {
        'accept': '*/*',
        'Authorization': 'Bearer $token',
      });
      if (response.statusCode == 200) {
        final Map<String, dynamic> responseData = jsonDecode(response.body);
        return responseData['object'];
      }
      return null;
    } catch (e) {
      return null;
    }
  }

  static Future<bool> deleteParty(String partyId, String userId) async {
    final token = await getToken();
    if (token == null) return false;
    final url =
        Uri.parse('${ApiConstants.baseUrl}/Party/$partyId/delete/$userId');
    final headers = {
      'Authorization': 'Bearer $token',
    };
    try {
      final response = await http.delete(url, headers: headers);
      if (response.statusCode == 200) {
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }

  static Future<bool> requestParticipation(String partyId) async {
    final token = await getToken();
    if (token == null) return false;
    final url = Uri.parse(
        '${ApiConstants.baseUrl}/Party/$partyId/request-participation');
    final headers = {
      'Authorization': 'Bearer $token',
      'Content-Type': 'application/json',
    };
    try {
      final response = await http.put(url, headers: headers);
      return (response.statusCode == 200);
    } catch (e) {
      return false;
    }
  }

  static Future<bool> inviteUsers(String partyId, List<String> userIds) async {
    final token = await getToken();
    if (token == null) return false;
    final url =
        Uri.parse('${ApiConstants.baseUrl}/Party/$partyId/invite-users');
    final headers = {
      'Authorization': 'Bearer $token',
      'Content-Type': 'application/json',
    };
    final body = jsonEncode(userIds);
    try {
      final response = await http.put(url, headers: headers, body: body);
      return (response.statusCode == 200);
    } catch (e) {
      return false;
    }
  }

  static Future<bool> confirmUser(String partyId, String targetUserId) async {
    final token = await getToken();
    if (token == null) return false;
    final url = Uri.parse(
        '${ApiConstants.baseUrl}/Party/$partyId/confirm/$targetUserId');
    final headers = {
      'Authorization': 'Bearer $token',
    };
    try {
      final response = await http.post(url, headers: headers);
      return (response.statusCode == 200);
    } catch (e) {
      return false;
    }
  }

  static Future<bool> declineUser(String partyId, String targetUserId) async {
    final token = await getToken();
    if (token == null) return false;
    final url = Uri.parse(
        '${ApiConstants.baseUrl}/Party/$partyId/decline/$targetUserId');
    final headers = {
      'Authorization': 'Bearer $token',
    };
    try {
      final response = await http.post(url, headers: headers);
      return (response.statusCode == 200);
    } catch (e) {
      return false;
    }
  }

  static Future<Map<String, dynamic>?> getAllPlaces() async {
    final token = await getToken();
    if (token == null) return null;
    final url = Uri.parse('${ApiConstants.baseUrl}/Place/all');
    try {
      final response = await http.get(url, headers: {
        'accept': '*/*',
        'Authorization': 'Bearer $token',
      });
      if (response.statusCode == 200) {
        final Map<String, dynamic> responseData = jsonDecode(response.body);
        return {"data": responseData['object']};
      }
      return null;
    } catch (e) {
      return null;
    }
  }

  static Future<Map<String, dynamic>?> getPlaceDetails(String placeId) async {
    final token = await getToken();
    if (token == null) return null;
    final url = Uri.parse('${ApiConstants.baseUrl}/Place/$placeId');
    try {
      final response = await http.get(url, headers: {
        'accept': '*/*',
        'Authorization': 'Bearer $token',
      });
      if (response.statusCode == 200) {
        final Map<String, dynamic> responseData = jsonDecode(response.body);
        return responseData['object'];
      }
      return null;
    } catch (e) {
      return null;
    }
  }

  static Future<bool> createPlace({
    required String title,
    required String description,
    required double latitude,
    required double longitude,
    required String coverImageBase64,
    int type = 0,
  }) async {
    final token = await getToken();
    if (token == null) return false;
    final url = Uri.parse('${ApiConstants.baseUrl}/Place');
    final headers = {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer $token',
    };
    final body = jsonEncode({
      "title": title,
      "description": description,
      "latitude": latitude,
      "longitude": longitude,
      "coverImage": coverImageBase64,
      "type": type
    });
    try {
      final response = await http.post(url, headers: headers, body: body);
      return (response.statusCode == 200);
    } catch (e) {
      return false;
    }
  }

  static Future<bool> updatePlace({
    required String placeId,
    required String title,
    required String description,
    required double latitude,
    required double longitude,
    String? coverImageBase64,
    int type = 0,
  }) async {
    final token = await getToken();
    if (token == null) return false;
    final url = Uri.parse('${ApiConstants.baseUrl}/Place/$placeId');
    final headers = {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer $token',
    };
    final body = {
      "title": title,
      "description": description,
      "latitude": latitude,
      "longitude": longitude,
      "type": type
    };
    if (coverImageBase64 != null && coverImageBase64.isNotEmpty) {
      body["coverImage"] = coverImageBase64;
    }
    try {
      final response =
          await http.put(url, headers: headers, body: jsonEncode(body));
      return (response.statusCode == 200);
    } catch (e) {
      return false;
    }
  }

  static Future<bool> deletePlace(String placeId) async {
    final token = await getToken();
    if (token == null) return false;
    final url = Uri.parse('${ApiConstants.baseUrl}/Place/$placeId');
    try {
      final response = await http.delete(url, headers: {
        'Authorization': 'Bearer $token',
      });
      return (response.statusCode == 200);
    } catch (e) {
      return false;
    }
  }

  static Future<bool> signalToRemovePlace(String placeId) async {
    final token = await getToken();
    if (token == null) return false;
    final url =
        Uri.parse('${ApiConstants.baseUrl}/Place/$placeId/signal-to-remove');
    final headers = {
      'Authorization': 'Bearer $token',
    };
    try {
      final response = await http.put(url, headers: headers);
      return (response.statusCode == 200);
    } catch (e) {
      return false;
    }
  }

  static Future<Map<String, dynamic>?> getPlaceVisitorsAndStats(
      String placeId) async {
    final token = await getToken();
    final url =
        Uri.parse('${ApiConstants.baseUrl}/Place/$placeId/visitors-and-stats');
    final headers = {
      'Authorization': 'Bearer $token',
    };
    try {
      final response = await http.get(url, headers: headers);
      final data = jsonDecode(response.body) as Map<String, dynamic>;
      return data;
    } catch (e) {
      return null;
    }
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\services\auth_checker.dart ===
import 'package:flutter/material.dart';
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:jwt_decoder/jwt_decoder.dart';
import 'package:snarf/pages/account/initial_page.dart';
import 'package:snarf/pages/home_page.dart';
import 'package:snarf/services/api_service.dart';

class AuthChecker extends StatefulWidget {
  const AuthChecker({super.key});

  @override
  _AuthCheckerState createState() => _AuthCheckerState();
}

class _AuthCheckerState extends State<AuthChecker> {
  String? token;
  bool isLoading = true;

  @override
  void initState() {
    super.initState();
    _checkAuth();
  }

  Future<void> _checkAuth() async {
    try {
      FirebaseCrashlytics.instance
          .log("AuthChecker: Iniciando verificação do token...");

      final result = await ApiService.getToken();

      if (result != null && !JwtDecoder.isExpired(result)) {
        FirebaseCrashlytics.instance.log("AuthChecker: Token válido.");

        setState(() {
          token = result;
        });
      } else {
        FirebaseCrashlytics.instance
            .log("AuthChecker: Token ausente ou expirado.");

        setState(() {
          token = null;
        });
      }
    } catch (error, stackTrace) {
      FirebaseCrashlytics.instance.recordError(error, stackTrace);
    } finally {
      setState(() {
        isLoading = false;
      });

      FirebaseCrashlytics.instance.log("AuthChecker: Finalizado.");
    }
  }

  @override
  Widget build(BuildContext context) {
    if (isLoading) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    return token != null ? const HomePage() : const InitialPage();
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\services\location_service.dart ===
import 'dart:async';
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:geolocator/geolocator.dart';

class LocationService {
  final bool usePrecise;

  LocationService({this.usePrecise = false});

  final _controller = StreamController<Position>.broadcast();
  StreamSubscription<Position>? _subscription;

  Stream<Position> get onLocationChanged => _controller.stream;

  Future<bool> initialize() async {
    if (!usePrecise) return true;
    bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) return false;
    LocationPermission permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) return false;
    }
    if (permission == LocationPermission.deniedForever) return false;
    return true;
  }

  Future<Position> getCurrentLocation() async {
    if (usePrecise) {
      final pos = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
      );
      _controller.add(pos);
      return pos;
    } else {
      final ipRes = await http.get(
        Uri.parse('https://api.ipify.org?format=json'),
      );
      final ipData = jsonDecode(ipRes.body) as Map<String, dynamic>;
      final ip = ipData['ip'] as String;

      final geoRes = await http.get(
        Uri.parse('http://ip-api.com/json/$ip'),
      );
      final data = jsonDecode(geoRes.body) as Map<String, dynamic>;
      final lat = (data['lat'] as num).toDouble();
      final lon = (data['lon'] as num).toDouble();

      final fakePos = Position(
        latitude: lat,
        longitude: lon,
        timestamp: DateTime.now(),
        accuracy: 50,
        altitude: 0.0,
        heading: 0.0,
        speed: 0.0,
        speedAccuracy: 0.0,
        altitudeAccuracy: 0.0,
        headingAccuracy: 0.0,
      );
      _controller.add(fakePos);
      return fakePos;
    }
  }

  void startUpdates({
    LocationAccuracy accuracy = LocationAccuracy.high,
    int intervalMs = 20000,
  }) {
    if (usePrecise) {
      _subscription = Geolocator.getPositionStream(
        locationSettings: LocationSettings(
          accuracy: accuracy,
          distanceFilter: 10,
          timeLimit: Duration(milliseconds: intervalMs),
        ),
      ).listen(_controller.add);
    }
  }

  void dispose() {
    _subscription?.cancel();
    _controller.close();
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\services\signalr_manager.dart ===
import 'dart:convert';
import 'package:firebase_analytics/firebase_analytics.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:signalr_netcore/signalr_client.dart';
import 'package:snarf/utils/api_constants.dart';
import 'package:snarf/enums/signalr_event_type.dart';

class SignalRManager {
  static final SignalRManager _instance = SignalRManager._internal();

  factory SignalRManager() => _instance;

  SignalRManager._internal();

  late HubConnection _hubConnection;
  final FlutterSecureStorage _storage = const FlutterSecureStorage();
  final FirebaseAnalytics _analytics = FirebaseAnalytics.instance;
  bool _isConnected = false;

  Future<String> _getAccessToken() async {
    return await _storage.read(key: 'token') ?? '';
  }

  Future<void> initializeConnection() async {
    if (_isConnected) return;
    _hubConnection = HubConnectionBuilder()
        .withUrl(
          '${ApiConstants.baseUrl.replaceAll('/api', '')}/SnarfHub',
          options: HttpConnectionOptions(
            accessTokenFactory: () async => await _getAccessToken(),
            requestTimeout: 10000,
            logMessageContent: true,
          ),
        )
        .withAutomaticReconnect()
        .build();
    try {
      await _hubConnection.start();
      _isConnected = true;
      await _analytics.logEvent(name: 'signalr_connection_success');
    } catch (e) {
      await _analytics.logEvent(
          name: 'signalr_connection_error',
          parameters: {'error': e.toString()});
    }
  }

  Future<void> stopConnection() async {
    if (_isConnected) {
      await _hubConnection.stop();
      _isConnected = false;
      await _analytics.logEvent(name: 'signalr_connection_stopped');
    }
  }

  Future<void> sendSignalRMessage(
      SignalREventType type, Map<String, dynamic> data) async {
    final message = jsonEncode({
      "Type": type.toString().split('.').last,
      "Data": data,
    });
    try {
      await invokeMethod("SendMessage", [message]);
      await _analytics.logEvent(
          name: 'signalr_send_message', parameters: {'message': message});
    } catch (e) {
      await _analytics.logEvent(
          name: 'signalr_send_message_error',
          parameters: {'error': e.toString()});
    }
  }

  Future<void> invokeMethod(String methodName, List<Object> args) async {
    if (!_isConnected) await initializeConnection();
    try {
      await _hubConnection.invoke(methodName, args: args);
    } catch (e) {
      await _analytics.logEvent(
          name: 'signalr_invoke_method_error',
          parameters: {'method': methodName, 'error': e.toString()});
    }
  }

  void listenToEvent(String eventName, Function(List<Object?>?) callback) {
    if (!_isConnected) return;
    _hubConnection.on(eventName, callback);
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\utils\api_constants.dart ===
class ApiConstants {
  static String baseUrl = "https://snarf-dev.inovitech.inf.br/api";
  //static String baseUrl = "http://192.168.1.15:5007/api";
  static String subscriptionId = 'snarf_plus';
  static String productId = '5_minutos_video_chamada';
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\utils\app_themes.dart ===
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class AppThemes {
  static final ThemeData lightTheme = ThemeData(
    fontFamily: GoogleFonts.kanit().fontFamily,
    brightness: Brightness.light,
    appBarTheme: const AppBarTheme(
        iconTheme: IconThemeData(color: Colors.black), centerTitle: true),
    textTheme: const TextTheme(
      bodySmall: TextStyle(color: Colors.black),
      bodyMedium: TextStyle(color: Colors.black),
      bodyLarge: TextStyle(color: Colors.black),
    ),
    bottomNavigationBarTheme: const BottomNavigationBarThemeData(
      backgroundColor: Colors.white,
      selectedItemColor: Colors.black,
      unselectedItemColor: Colors.black,
      showUnselectedLabels: true,
    ),
    outlinedButtonTheme: OutlinedButtonThemeData(
      style: OutlinedButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 25.0, vertical: 8.0),
        side: const BorderSide(
          color: Color(0xFF0b0951),
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(30.0),
        ),
        textStyle: const TextStyle(
          color: Color(0xFF0b0951),
          fontWeight: FontWeight.bold,
        ),
      ),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 25.0, vertical: 8.0),
        backgroundColor: const Color(0xFF0b0951),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(30.0),
        ),
        textStyle: const TextStyle(
          color: Colors.white,
          fontWeight: FontWeight.bold,
        ),
      ),
    ),
  );

  static final ThemeData darkTheme = ThemeData(
    fontFamily: GoogleFonts.kanit().fontFamily,
    brightness: Brightness.dark,
    primaryColor: const Color(0xFF4c2a85),
    scaffoldBackgroundColor: const Color(0xFF0b0951),
    appBarTheme: const AppBarTheme(
      iconTheme: IconThemeData(color: Colors.white),
      backgroundColor: Color(0xFF0b0951),
      centerTitle: true,
    ),
    textTheme: const TextTheme(
      bodySmall: TextStyle(color: Colors.white),
      bodyMedium: TextStyle(color: Colors.white),
      bodyLarge: TextStyle(color: Colors.white),
    ),
    bottomNavigationBarTheme: const BottomNavigationBarThemeData(
      backgroundColor: Color(0xFF0b0951),
      selectedItemColor: Colors.white,
      unselectedItemColor: Colors.white,
    ),
    outlinedButtonTheme: OutlinedButtonThemeData(
      style: OutlinedButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 25.0, vertical: 8.0),
        side: const BorderSide(
          color: Color(0xFF0b0951),
        ),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(30.0),
        ),
        textStyle: const TextStyle(
          color: Color(0xFF0b0951),
          fontWeight: FontWeight.bold,
        ),
      ),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 25.0, vertical: 8.0),
        backgroundColor: const Color(0xFF0b0951),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(30.0),
        ),
        textStyle: const TextStyle(
          color: Colors.white,
          fontWeight: FontWeight.bold,
        ),
      ),
    ),
  );
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\utils\date_utils.dart ===
import 'package:intl/intl.dart';

class DateJSONUtils {
  static String formatDate(String dateString) {
    final date = DateTime.parse(dateString);
    return '${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}, ${date.day.toString().padLeft(2, '0')}/${date.month.toString().padLeft(2, '0')}/${date.year}';
  }

  static String formatMessageTime(DateTime dateTime) {
    final now = DateTime.now();
    if (dateTime.day == now.day &&
        dateTime.month == now.month &&
        dateTime.year == now.year) {
      return DateFormat.Hm().format(dateTime);
    } else {
      return DateFormat('dd/MM/yyyy HH:mm').format(dateTime);
    }
  }

  static String formatRelativeTime(String dateString) {
    final date = DateTime.parse(dateString).toLocal();
    final now = DateTime.now();
    final difference = now.difference(date);

    if (difference.inSeconds < 60) {
      return 'Há alguns segundos';
    } else if (difference.inMinutes < 60) {
      return 'Há ${difference.inMinutes} minuto${difference.inMinutes > 1 ? 's' : ''}';
    } else if (difference.inHours < 24) {
      return 'Há ${difference.inHours} hora${difference.inHours > 1 ? 's' : ''}';
    } else if (difference.inDays < 7) {
      return 'Há ${difference.inDays} dia${difference.inDays > 1 ? 's' : ''}';
    } else if (difference.inDays < 30) {
      final weeks = (difference.inDays / 7).floor();
      return 'Há $weeks semana${weeks > 1 ? 's' : ''}';
    } else if (difference.inDays < 365) {
      final months = (difference.inDays / 30).floor();
      return 'Há $months mês${months > 1 ? 'es' : ''}';
    } else {
      final years = (difference.inDays / 365).floor();
      return 'Há $years ano${years > 1 ? 's' : ''}';
    }
  }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\utils\distance_utils.dart ===
import 'package:geolocator/geolocator.dart';

class DistanceUtils {
  static double calculateDistance(
    double lat1,
    double lon1,
    double lat2,
    double lon2,
  ) {
    return Geolocator.distanceBetween(lat1, lon1, lat2, lon2);
  }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\utils\show_snackbar.dart ===
import 'package:flutter/material.dart';

void showErrorSnackbar(BuildContext context, String message, {Color color = Colors.red}) {
  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(
      content: Text(message),
      backgroundColor: color,
      duration: const Duration(seconds: 5),
    ),
  );
}

void showSuccessSnackbar(BuildContext context, String message, {Color color = Colors.green}) {
  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(
      content: Text(message),
      backgroundColor: color,
      duration: const Duration(seconds: 3),
    ),
  );
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\snarf\lib\utils\subscription_base_plan_details.dart ===
import "package:in_app_purchase/in_app_purchase.dart";
import "package:in_app_purchase_android/in_app_purchase_android.dart";
import "package:in_app_purchase_android/src/billing_client_wrappers/subscription_offer_details_wrapper.dart";
import "package:snarf/enums/base_plan_length.dart";

class SubscriptionBasePlanDetails {
  final ProductDetails productDetails;

  late final String subscriptionId;
  late String formattedPrice;
  late String? basePlanId;
  late BasePlanLength? basePlanLength;
  late bool? isFreeTrialAvailable;

  SubscriptionBasePlanDetails(
    this.productDetails,
  ) {
    subscriptionId = productDetails.id;
    formattedPrice = productDetails.price;
    final GooglePlayProductDetails googlePlayProductDetails =
        productDetails as GooglePlayProductDetails;
    final int? basePlanIndex = googlePlayProductDetails.subscriptionIndex;
    final List<SubscriptionOfferDetailsWrapper>? subscriptionOfferDetails =
        googlePlayProductDetails.productDetails.subscriptionOfferDetails;

    if (basePlanIndex != null && subscriptionOfferDetails != null) {
      final SubscriptionOfferDetailsWrapper offerDetailsWrapper =
          subscriptionOfferDetails[basePlanIndex];
      basePlanId = offerDetailsWrapper.basePlanId;
      basePlanLength = _getBasePlanLength(
          offerDetailsWrapper.pricingPhases.first.billingPeriod);
      isFreeTrialAvailable = offerDetailsWrapper.pricingPhases
          .any((phase) => phase.priceAmountMicros == 0);
    }
  }

  BasePlanLength? _getBasePlanLength(String billingPeriod) {
    switch (billingPeriod) {
      case "P1W":
        return BasePlanLength.weekly;
      case "P4W":
        return BasePlanLength.everyFourWeeks;
      case "P1M":
        return BasePlanLength.monthly;
      case "P2M":
        return BasePlanLength.everyTwoMonths;
      case "P3M":
        return BasePlanLength.everyThreeMonths;
      case "P4M":
        return BasePlanLength.everyFourMonths;
      case "P6M":
        return BasePlanLength.everySixMonths;
      case "P8M":
        return BasePlanLength.everyEightMonths;
      case "P1Y":
        return BasePlanLength.yearly;
      default:
        return null;
    }
  }

  String getBasePlanLengthTranslated() {
    switch (basePlanLength) {
      case BasePlanLength.weekly:
        return "Semanal";
      case BasePlanLength.everyFourWeeks:
        return "A cada 4 semanas";
      case BasePlanLength.monthly:
        return "Mensal";
      case BasePlanLength.everyTwoMonths:
        return "A cada 2 meses";
      case BasePlanLength.everyThreeMonths:
        return "A cada 3 meses";
      case BasePlanLength.everyFourMonths:
        return "A cada 4 meses";
      case BasePlanLength.everySixMonths:
        return "Semestral";
      case BasePlanLength.everyEightMonths:
        return "A cada 8 meses";
      case BasePlanLength.yearly:
        return "Anual";
      default:
        return "Indefinido";
    }
  }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.API\Program.cs ===
using FirebaseAdmin;
using Google.Apis.Auth.OAuth2;
using Hangfire;
using Hangfire.Dashboard.BasicAuthorization;
using Hangfire.PostgreSql;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.SignalR;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.Tokens;
using Microsoft.OpenApi.Models;
using Serilog;
using Snarf.API.Controllers;
using Snarf.DataAccess;
using Snarf.Domain.Base;
using Snarf.Domain.Enum;
using Snarf.Infrastructure.Repository;
using Snarf.Infrastructure.Service;
using Snarf.Persistence;
using Snarf.Service;
using Snarf.Utils;
using System.Text;

namespace Snarf.API
{
    public class Program
    {
        public static void Main(string[] args)
        {
            AppContext.SetSwitch("Npgsql.EnableLegacyTimestampBehavior", true);
            AppContext.SetSwitch("Npgsql.DisableDateTimeInfinityConversions", true);
            var builder = WebApplication.CreateBuilder(args);
            var configuration = builder.Configuration;

            Log.Logger = new LoggerConfiguration()
            .MinimumLevel.Information()
            .Enrich.FromLogContext()
            .WriteTo.Console()
            .WriteTo.File(Path.Combine("logs", "log.txt"),
                rollingInterval: RollingInterval.Day,
                retainedFileCountLimit: 10,
                outputTemplate: "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} {CorrelationId} {Level:u3} {Username} {Message:lj}{Exception}{NewLine}")
            .CreateLogger();

            builder.Logging.ClearProviders();
            builder.Host.UseSerilog();

            string databaseSnarf = Environment.GetEnvironmentVariable("DatabaseConnection") ?? configuration.GetConnectionString("DatabaseConnection")!;

            builder.Services.AddDbContext<SnarfContext>(x =>
            {
                x.UseNpgsql(databaseSnarf);
                if (builder.Environment.IsDevelopment())
                {
                    x.EnableSensitiveDataLogging();
                    x.EnableDetailedErrors();
                }
            });

            builder.Services.AddHttpLogging(x =>
            {
                x.LoggingFields = Microsoft.AspNetCore.HttpLogging.HttpLoggingFields.All;
            });

            builder.Services.AddScoped<SessionMiddleware>();

            InjectUserDependencies(builder);

            InjectRepositoryDependencies(builder);
            InjectServiceDependencies(builder);

            SetupAuthentication(builder, configuration);

            builder.Services.AddSession();

            builder.Services.AddControllers();
            //.AddJsonOptions(options =>
            //{
            //    options.JsonSerializerOptions.Converters.Add(new JsonStringEnumConverter());
            //});

            builder.Services.AddOutputCache(x =>
            {
                x.AddPolicy("CacheImmutableResponse", OutputCachePolicy.Instance);
            });

            builder.Services.AddEndpointsApiExplorer();

            SetupSwaggerGen(builder);

            builder.Services.AddCors();

            builder.Services.AddHangfire(x =>
            {
                x.UsePostgreSqlStorage(options => options.UseNpgsqlConnection(databaseSnarf));
            });

            builder.Services.AddHangfireServer(x => x.WorkerCount = 1);

            builder.Services.AddMvc();
            builder.Services.AddRouting();

            builder.Services.AddSignalR();

            builder.Services.Configure<HubOptions>(options =>
            {
                options.MaximumReceiveMessageSize = 1024 * 1024 * 50;
            });

            var app = builder.Build();

            using (var scope = app.Services.CreateScope())
            {
                var db = scope.ServiceProvider.GetRequiredService<SnarfContext>();
                db.Database.Migrate();
                SeedAdminUser(scope.ServiceProvider).Wait();
            }

            app.UseHangfireDashboard("/hangfire", new DashboardOptions
            {
                Authorization = new[] { new BasicAuthAuthorizationFilter(
                    new BasicAuthAuthorizationFilterOptions
                    {
                        RequireSsl = false,
                        SslRedirect = false,
                        LoginCaseSensitive = true,
                        Users = new[]
                        {
                            new BasicAuthAuthorizationUser
                            {
                                Login = GetAdminEmail(),
                                PasswordClear = GetAdminPassword()

                            }
                        }
                    }) }
            });

            string firebaseCredentials = Environment.GetEnvironmentVariable("FirebaseCredentials") ?? configuration.GetConnectionString("FirebaseCredentials")!;
            FirebaseApp.Create(new AppOptions()
            {
                Credential = GoogleCredential.FromJson(firebaseCredentials)
            });

            app.UseSwagger();
            app.UseSwaggerUI();

            app.UseCors(corsPolicyBuilder =>
            {
                corsPolicyBuilder.AllowAnyMethod()
                       .AllowAnyOrigin()
                       .AllowAnyHeader();
            });

            app.UseSession();
            app.UseOutputCache();

            app.UseRouting();

            app.UseAuthentication();
            app.UseAuthorization();

            app.MapHub<SnarfHub>("/SnarfHub").RequireAuthorization();

            app.MapControllers();

            app.Run();
        }

        private static void SetupAuthentication(WebApplicationBuilder builder, ConfigurationManager configuration)
        {
            builder.Services.AddAuthentication(options =>
            {
                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            })
            .AddJwtBearer(options =>
            {
                options.TokenValidationParameters = new TokenValidationParameters
                {
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(configuration.GetValue<string>("TokenKey")!)),
                    ValidateLifetime = true,
                    ValidateIssuer = false,
                    ValidateAudience = false
                };
            });
        }

        private static void SetupSwaggerGen(WebApplicationBuilder builder)
        {
            builder.Services.AddSwaggerGen(options =>
            {
                options.SwaggerDoc("v1", new OpenApiInfo { Title = "Snarf.API", Version = "v1" });
                options.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
                {
                    Description = @"JWT Authorization header usando Bearer.
                                Entre com 'Bearer ' [espaço] então coloque seu token.
                                Exemplo: 'Bearer 12345abcdef'",
                    Name = "Authorization",
                    In = ParameterLocation.Header,
                    Type = SecuritySchemeType.ApiKey,
                    Scheme = "Bearer"
                });

                options.AddSecurityRequirement(new OpenApiSecurityRequirement()
                {
                    {
                        new OpenApiSecurityScheme
                        {
                            Reference = new OpenApiReference
                            {
                                Type = ReferenceType.SecurityScheme,
                                Id = "Bearer"
                            },
                            Scheme = "oauth2",
                            Name = "Bearer",
                            In = ParameterLocation.Header
                        },
                        new List<string>()
                    }
                });
            });
        }

        private static void InjectUserDependencies(WebApplicationBuilder builder)
        {
            builder.Services.AddIdentityCore<User>(options =>
            {
                options.Password.RequireDigit = false;
                options.Password.RequireNonAlphanumeric = false;
                options.Password.RequireLowercase = false;
                options.Password.RequireUppercase = false;
                options.Password.RequiredLength = 4;
                options.User.RequireUniqueEmail = true;
            })
            .AddEntityFrameworkStores<SnarfContext>()
            .AddSignInManager()
            .AddDefaultTokenProviders();

            builder.Services.AddScoped<UserManager<User>>();
        }

        private static void InjectRepositoryDependencies(WebApplicationBuilder builder)
        {
            builder.Services.AddScoped<IUserRepository, UserRepository>();
            builder.Services.AddScoped<IVideoCallLogRepository, VideoCallLogRepository>();
            builder.Services.AddScoped<IVideoCallPurchaseRepository, VideoCallPurchaseRepository>();
            builder.Services.AddScoped<IPrivateChatMessageRepository, PrivateChatMessageRepository>();
            builder.Services.AddScoped<IPublicChatMessageRepository, PublicChatMessageRepository>();
            builder.Services.AddScoped<IPartyChatMessageRepository, PartyChatMessageRepository>();
            builder.Services.AddScoped<IPartyRepository, PartyRepository>();
            builder.Services.AddScoped<IFavoriteChatRepository, FavoriteChatRepository>();
            builder.Services.AddScoped<IBlockedUserRepository, BlockedUserRepository>();
            builder.Services.AddScoped<IPlaceRepository, PlaceRepository>();
            builder.Services.AddScoped<IPlaceChatMessageRepository, PlaceChatMessageRepository>();
            builder.Services.AddScoped<IPlaceVisitLogRepository, PlaceVisitLogRepository>();
        }

        private static void InjectServiceDependencies(WebApplicationBuilder builder)
        {
            builder.Services.AddScoped<IAccountService, AccountService>();
            builder.Services.AddScoped<S3Service>();
            builder.Services.AddScoped<IEmailService, EmailService>();
            builder.Services.AddScoped<ITokenService, TokenService>();
            builder.Services.AddScoped<IPartyService, PartyService>();
            builder.Services.AddScoped<IPlaceService, PlaceService>();
        }

        private static async Task SeedAdminUser(IServiceProvider serviceProvider)
        {
            var userManager = serviceProvider.GetRequiredService<UserManager<User>>();
            var adminEmail = GetAdminEmail();

            var adminUser = await userManager.FindByEmailAsync(adminEmail);
            var user = new User { Name = "Admin", UserName = "admin", Email = adminEmail, Role = RoleName.Admin, EmailConfirmed = true };
            if (adminUser == null)
                await userManager.CreateAsync(user, GetAdminPassword());
        }

        private static string GetAdminEmail()
        {
            return "admin@admin.com";
        }

        private static string GetAdminPassword()
        {
            return "Admin@123";
        }
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.API\Controllers\AccountController.cs ===
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Snarf.DTO;
using Snarf.Infrastructure.Service;
using System.Security.Claims;

namespace Snarf.API.Controllers
{
    public class AccountController(IAccountService accountService) : BaseController
    {
        [HttpPost("Login")]
        [AllowAnonymous]
        public async Task<IActionResult> Login([FromBody] UserLoginDTO userLogin)
        {
            var user = await accountService.Login(userLogin);
            return StatusCode(user.Code, user);
        }

        [HttpGet("GetUser/{requestedUserId:guid}")]
        public async Task<IActionResult> GetUser([FromRoute] Guid requestedUserId)
        {
            var userId = Guid.Parse(User.Claims.First(x => x.Type == ClaimTypes.NameIdentifier.ToString()).Value);
            var user = await accountService.GetUserInfo(requestedUserId, userId == requestedUserId);
            return StatusCode(user.Code, user);
        }

        [HttpPost("BlockUser")]
        public async Task<IActionResult> BlockUser([FromQuery] Guid blockedUserId)
        {
            var blockerUserId = Guid.Parse(User.Claims.First(x => x.Type == ClaimTypes.NameIdentifier.ToString()).Value);
            var user = await accountService.BlockUser(blockerUserId, blockedUserId);
            return StatusCode(user.Code, user);
        }

        [HttpPost("UnblockUser")]
        public async Task<IActionResult> UnblockUser([FromQuery] Guid blockedUserId)
        {
            var blockerUserId = Guid.Parse(User.Claims.First(x => x.Type == ClaimTypes.NameIdentifier.ToString()).Value);
            var user = await accountService.UnblockUser(blockerUserId, blockedUserId);
            return StatusCode(user.Code, user);
        }

        [HttpPost("ReportUserPublicMessage")]
        public async Task<IActionResult> ReportUserPublicMessage([FromQuery] Guid messageId)
        {
            var user = await accountService.ReportUserPublicMessage(messageId);
            return StatusCode(user.Code, user);
        }

        [HttpPost("ReportUser")]
        public async Task<IActionResult> ReportUser([FromQuery] Guid userId)
        {
            var user = await accountService.ReportUser(userId);
            return StatusCode(user.Code, user);
        }

        [HttpPut("{id:guid}")]
        public async Task<IActionResult> UpdateUser([FromRoute] Guid id, [FromBody] UserDTO userDTO)
        {
            id = Guid.Parse(User.Claims.First(x => x.Type == ClaimTypes.NameIdentifier.ToString()).Value);
            var user = await accountService.UpdateUser(id, userDTO);
            return StatusCode(user.Code, user);
        }

        [HttpDelete("{id:guid}")]
        public async Task<IActionResult> RemoveUser([FromRoute] Guid id)
        {
            id = Guid.Parse(User.Claims.First(x => x.Type == ClaimTypes.NameIdentifier.ToString()).Value);
            var user = await accountService.RemoveUser(id);
            return StatusCode(user.Code, user);
        }

        [HttpPost("AddExtraMinutes")]
        public async Task<IActionResult> AddExtraMinutes([FromBody] AddExtraMinutesDTO addExtraMinutesDTO)
        {
            addExtraMinutesDTO.UserId = Guid.Parse(User.Claims.First(x => x.Type == ClaimTypes.NameIdentifier.ToString()).Value);
            var user = await accountService.AddExtraMinutes(addExtraMinutesDTO);
            return StatusCode(user.Code, user);
        }


        [HttpPost("")]
        [AllowAnonymous]
        public async Task<IActionResult> CreateUser([FromBody] UserDTO userDTO)
        {
            var user = await accountService.CreateUser(userDTO);
            return StatusCode(user.Code, user);
        }

        [HttpPost("RequestResetPassword")]
        [AllowAnonymous]
        public async Task<IActionResult> RequestResetPassword([FromBody] string email)
        {
            var user = await accountService.RequestResetPassword(email);
            return StatusCode(user.Code, user);
        }

        [HttpPost("ResetPassword")]
        [AllowAnonymous]
        public async Task<IActionResult> ResetPassword([FromBody] UserEmailDTO userEmailDTO)
        {
            var user = await accountService.ResetPassword(userEmailDTO);
            return StatusCode(user.Code, user);
        }

        [HttpPost("ChangeEmail")]
        public async Task<IActionResult> ChangeEmail([FromBody] ChangeEmailDTO model)
        {
            var userId = Guid.Parse(User.Claims.First(x => x.Type == ClaimTypes.NameIdentifier.ToString()).Value);

            var result = await accountService.ChangeEmail(userId, model.NewEmail!, model.CurrentPassword!);
            return StatusCode(result.Code, result);
        }

        [HttpPost("ChangePassword")]
        public async Task<IActionResult> ChangePassword([FromBody] ChangePasswordDTO model)
        {
            var userId = Guid.Parse(User.Claims.First(x => x.Type == ClaimTypes.NameIdentifier.ToString()).Value);

            var result = await accountService.ChangePassword(userId, model.OldPassword!, model.NewPassword!);
            return StatusCode(result.Code, result);
        }

        [HttpGet("GetFirstMessageToday")]
        public async Task<IActionResult> GetFirstMessageToday()
        {
            var userId = Guid.Parse(User.Claims.First(x => x.Type == ClaimTypes.NameIdentifier.ToString()).Value);
            var message = await accountService.GetFirstMessageToday(userId);
            return StatusCode(message.Code, message);
        }

    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.API\Controllers\BaseController.cs ===
﻿using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace Snarf.API.Controllers
{
    [Authorize]
    [ApiController]
    [Route("api/[controller]")]
    public abstract class BaseController : ControllerBase
    {
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.API\Controllers\PartyController.cs ===
﻿using Microsoft.AspNetCore.Mvc;
using Snarf.DTO;
using Snarf.Infrastructure.Service;
using System.Security.Claims;

namespace Snarf.API.Controllers
{
    public class PartyController(IPartyService partyService) : BaseController
    {
        [HttpPost("")]
        public async Task<IActionResult> Create([FromBody] PartyDTO partyCreateDTO)
        {
            var whoIsCallingId = User.FindFirstValue(ClaimTypes.NameIdentifier);
            partyCreateDTO.UserId = whoIsCallingId;

            var party = await partyService.Create(partyCreateDTO);
            return StatusCode(party.Code, party);
        }

        [HttpPut("{id:guid}")]
        public async Task<IActionResult> UpdateParty([FromRoute] Guid id, [FromBody] PartyDTO updateDTO)
        {
            var party = await partyService.Update(id, updateDTO);
            return StatusCode(party.Code, party);
        }

        [HttpGet("all{userId:guid}")]
        public async Task<IActionResult> GetAllParties([FromRoute] Guid userId)
        {
            userId = Guid.Parse(User.Claims.First(x => x.Type == ClaimTypes.NameIdentifier.ToString()).Value);

            var parties = await partyService.GetAll(userId);
            return StatusCode(parties.Code, parties);
        }

        [HttpGet("{id:guid}/all-users/{userId:guid}")]
        public async Task<IActionResult> GetAllParticipants([FromRoute] Guid id, [FromRoute] Guid userId)
        {
            userId = Guid.Parse(User.Claims.First(x => x.Type == ClaimTypes.NameIdentifier.ToString()).Value);

            var parties = await partyService.GetAllParticipants(id, userId);
            return StatusCode(parties.Code, parties);
        }

        [HttpGet("{id:guid}/details/{userId:guid}")]
        public async Task<IActionResult> GetPartyDetails([FromRoute] Guid id, [FromRoute] Guid userId)
        {
            userId = Guid.Parse(User.Claims.First(x => x.Type == ClaimTypes.NameIdentifier.ToString()).Value);
            var party = await partyService.GetById(id, userId);
            return StatusCode(party.Code, party);
        }

        [HttpDelete("{id:guid}/delete/{userId:guid}")]
        public async Task<IActionResult> Delete([FromRoute] Guid id, [FromRoute] Guid userId)
        {
            userId = Guid.Parse(User.Claims.First(x => x.Type == ClaimTypes.NameIdentifier.ToString()).Value);
            var party = await partyService.Delete(id, userId);
            return StatusCode(party.Code, party);
        }

        [HttpPut("{id:guid}/invite-users")]
        public async Task<IActionResult> InviteUsersToParty([FromRoute] Guid id, [FromBody] List<string> userIds)
        {
            var whoIsCallingId = User.FindFirstValue(ClaimTypes.NameIdentifier);
            var result = await partyService.InviteUsers(id, userIds, whoIsCallingId!);
            return StatusCode(result.Code, result);
        }

        [HttpPut("{id:guid}/request-participation")]
        public async Task<IActionResult> RequestParticipation([FromRoute] Guid id)
        {
            var whoIsCallingId = User.FindFirstValue(ClaimTypes.NameIdentifier);

            var result = await partyService.RequestParticipation(id, whoIsCallingId!);
            return StatusCode(result.Code, result);
        }

        [HttpPost("{id:guid}/confirm/{targetUserId:guid}")]
        public async Task<IActionResult> ConfirmParty([FromRoute] Guid id, [FromRoute] Guid targetUserId)
        {
            var whoIsCallingId = User.FindFirstValue(ClaimTypes.NameIdentifier);

            var result = await partyService.ConfirmUser(id, whoIsCallingId!, targetUserId.ToString());
            return StatusCode(result.Code, result);
        }

        [HttpPost("{id:guid}/decline/{targetUserId:guid}")]
        public async Task<IActionResult> DeclineUser([FromRoute] Guid id, [FromRoute] Guid targetUserId)
        {
            var whoIsCallingId = User.FindFirstValue(ClaimTypes.NameIdentifier);

            var result = await partyService.DeclineUser(id, whoIsCallingId!, targetUserId.ToString());
            return StatusCode(result.Code, result);
        }
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.API\Controllers\PlaceController.cs ===
﻿using Microsoft.AspNetCore.Mvc;
using Snarf.DTO;
using Snarf.Infrastructure.Service;
using System.Security.Claims;

namespace Snarf.API.Controllers
{
    public class PlaceController(IPlaceService placeService) : BaseController
    {
        [HttpPost("")]
        public async Task<IActionResult> Create([FromBody] PlaceDTO createDTO)
        {
            var whoIsCallingId = User.FindFirstValue(ClaimTypes.NameIdentifier);
            createDTO.UserId = whoIsCallingId;
            var result = await placeService.Create(createDTO);
            return StatusCode(result.Code, result);
        }

        [HttpPut("{id:guid}")]
        public async Task<IActionResult> Update([FromRoute] Guid id, [FromBody] PlaceDTO updateDTO)
        {
            var whoIsCallingId = User.FindFirstValue(ClaimTypes.NameIdentifier);
            var result = await placeService.Update(id, updateDTO, Guid.Parse(whoIsCallingId));
            return StatusCode(result.Code, result);
        }

        [HttpDelete("{id:guid}")]
        public async Task<IActionResult> Delete([FromRoute] Guid id)
        {
            var whoIsCallingId = User.FindFirstValue(ClaimTypes.NameIdentifier);
            var result = await placeService.Delete(id, Guid.Parse(whoIsCallingId));
            return StatusCode(result.Code, result);
        }

        [HttpGet("{id:guid}")]
        public async Task<IActionResult> GetById([FromRoute] Guid id)
        {
            var result = await placeService.GetById(id);
            return StatusCode(result.Code, result);
        }

        [HttpGet("all")]
        public async Task<IActionResult> GetAll()
        {
            var result = await placeService.GetAll();
            return StatusCode(result.Code, result);
        }

        [HttpPut("{id:guid}/signal-to-remove")]
        public async Task<IActionResult> SignalToRemove([FromRoute] Guid id)
        {
            var whoIsCallingId = User.FindFirstValue(ClaimTypes.NameIdentifier);
            var result = await placeService.SignalToRemove(id, Guid.Parse(whoIsCallingId));
            return StatusCode(result.Code, result);
        }

        [HttpGet("{id:guid}/visitors-and-stats")]
        public async Task<IActionResult> GetVisitorsAndStats([FromRoute] Guid id)
        {
            var result = await placeService.GetVisitorsAndStats(id);
            return StatusCode(result.Code, result);
        }
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.API\Controllers\SnarfHub.cs ===
﻿using FirebaseAdmin.Messaging;
using Microsoft.AspNetCore.SignalR;
using Microsoft.EntityFrameworkCore;
using Serilog;
using Snarf.Domain.Entities;
using Snarf.DTO;
using Snarf.Infrastructure.Repository;
using Snarf.Service;
using Snarf.Utils;
using System.Collections.Concurrent;
using System.Text.Json;

namespace Snarf.API.Controllers
{
    public class SnarfHub(
        IUserRepository _userRepository,
        IPublicChatMessageRepository _publicChatMessageRepository,
        IPartyChatMessageRepository _partyChatMessageRepository,
        IPrivateChatMessageRepository _privateChatMessageRepository,
        IBlockedUserRepository _blockedUserRepository,
        IVideoCallLogRepository _videoCallLogRepository,
        IVideoCallPurchaseRepository _videoCallPurchaseRepository,
        IFavoriteChatRepository _favoriteChatRepository,
        IPlaceChatMessageRepository _placeChatMessageRepository,
        IPlaceRepository _placeRepository,
        IPlaceVisitLogRepository _placeVisitLogRepository) : Hub
    {
        private static ConcurrentDictionary<string, List<string>> _userConnections = new();

        public async Task SendMessage(string jsonMessage)
        {
            var message = SignalRMessage.Deserialize(jsonMessage);

            switch (message.Type)
            {
                case nameof(SignalREventType.PlaceChatSendMessage):
                    await HandlePlaceChatSendMessage(message.Data);
                    break;

                case nameof(SignalREventType.PlaceChatDeleteMessage):
                    await HandlePlaceChatDeleteMessage(message.Data);
                    break;

                case nameof(SignalREventType.PlaceChatGetPreviousMessages):
                    await HandlePlaceChatGetPreviousMessages(message.Data);
                    break;

                case nameof(SignalREventType.MapUpdateLocation):
                    await HandleMapUpdateLocation(message.Data);
                    break;

                case nameof(SignalREventType.PartyChatSendMessage):
                    await HandlePartyChatSendMessage(message.Data);
                    break;

                case nameof(SignalREventType.PartyChatSendImage):
                    await HandlePartyChatSendImage(message.Data);
                    break;

                case nameof(SignalREventType.PartyChatDeleteMessage):
                    await HandlePartyChatDeleteMessage(message.Data);
                    break;

                case nameof(SignalREventType.PartyChatGetPreviousMessages):
                    await HandlePartyChatGetPreviousMessages(message.Data);
                    break;

                case nameof(SignalREventType.PublicChatSendMessage):
                    await HandlePublicChatSendMessage(message.Data);
                    break;

                case nameof(SignalREventType.PublicChatDeleteMessage):
                    await HandlePublicChatDeleteMessage(message.Data);
                    break;

                case nameof(SignalREventType.PublicChatGetPreviousMessages):
                    await HandlePublicChatGetPreviousMessages();
                    break;

                case nameof(SignalREventType.PrivateChatSendMessage):
                    await HandlePrivateChatSendMessage(message.Data);
                    break;

                case nameof(SignalREventType.PrivateChatGetRecentChats):
                    await HandlePrivateChatGetRecentChats();
                    break;

                case nameof(SignalREventType.PrivateChatGetPreviousMessages):
                    await HandlePrivateChatGetPreviousMessages(message.Data);
                    break;

                case nameof(SignalREventType.PrivateChatMarkMessagesAsRead):
                    await HandlePrivateChatMarkMessagesAsRead(message.Data);
                    break;

                case nameof(SignalREventType.PrivateChatDeleteMessage):
                    await HandlePrivateChatDeleteMessage(message.Data);
                    break;

                case nameof(SignalREventType.PrivateChatDeleteChat):
                    await HandlePrivateChatDeleteChat(message.Data);
                    break;

                case nameof(SignalREventType.PrivateChatSendImage):
                    await HandlePrivateChatSendImage(message.Data);
                    break;

                case nameof(SignalREventType.PrivateChatSendAudio):
                    await HandlePrivateChatSendAudio(message.Data);
                    break;

                case nameof(SignalREventType.PrivateChatSendVideo):
                    await HandlePrivateChatSendVideo(message.Data);
                    break;

                case nameof(SignalREventType.PrivateChatGetFavorites):
                    await HandlePrivateChatGetFavorites();
                    break;

                case nameof(SignalREventType.PrivateChatAddFavorite):
                    await HandlePrivateChatAddFavorite(message.Data);
                    break;

                case nameof(SignalREventType.PrivateChatRemoveFavorite):
                    await HandlePrivateChatRemoveFavorite(message.Data);
                    break;

                case nameof(SignalREventType.PrivateChatReactToMessage):
                    await HandlePrivateChatReactToMessage(message.Data);
                    break;

                case nameof(SignalREventType.PrivateChatReplyToMessage):
                    await HandlePrivateChatReplyToMessage(message.Data);
                    break;

                case nameof(SignalREventType.VideoCallInitiate):
                    await HandleVideoCallInitiate(message.Data);
                    break;

                case nameof(SignalREventType.VideoCallAccept):
                    await HandleVideoCallAccept(message.Data);
                    break;

                case nameof(SignalREventType.VideoCallReject):
                    await HandleVideoCallReject(message.Data);
                    break;

                case nameof(SignalREventType.VideoCallEnd):
                    await HandleVideoCallEnd(message.Data);
                    break;

                default:
                    Log.Warning($"Evento desconhecido recebido: {message.Type}");
                    break;
            }
        }

        #region Métodos Principais

        private async Task HandleMapUpdateLocation(JsonElement data)
        {
            var userId = GetUserId();
            var location = JsonSerializer.Deserialize<LocationModel>(data.ToString());
            var user = await _userRepository.GetTrackedEntities()
                .Include(x => x.Photos)
                .Where(x => x.Id == userId)
                .FirstOrDefaultAsync();

            if (user == null) return;

            user.LastActivity = DateTime.Now;
            user.LastLatitude = location.Latitude;
            user.LastLongitude = location.Longitude;
            user.FcmToken = location.FcmToken;
            await _userRepository.SaveChangesAsync();

            double lat = location.Latitude;
            double lon = location.Longitude;
            double latDegreeRadius = 0.009;
            double lonDegreeRadius = 0.009;
            var places = await _placeRepository.GetEntities()
                .Where(p =>
                    p.Latitude >= lat - latDegreeRadius &&
                    p.Latitude <= lat + latDegreeRadius &&
                    p.Longitude >= lon - lonDegreeRadius &&
                    p.Longitude <= lon + lonDegreeRadius)
                .ToListAsync();
            var ongoingVisits = await _placeVisitLogRepository.GetTrackedEntities()
                .Where(v => v.UserId == userId && v.ExitTime == null)
                .ToListAsync();

            foreach (var place in places)
            {
                double distance = DistanceInMeters(location.Latitude, location.Longitude, place.Latitude, place.Longitude);

                var visitLog = ongoingVisits.FirstOrDefault(v => v.PlaceId == place.Id);

                if (distance <= 50)
                {
                    if (visitLog == null)
                    {
                        visitLog = new PlaceVisitLog
                        {
                            UserId = userId,
                            PlaceId = place.Id,
                            EntryTime = DateTime.Now
                        };

                        _placeVisitLogRepository.Insert(visitLog);
                        await _placeVisitLogRepository.SaveChangesAsync();

                        var fakeData = new
                        {
                            Message = $"{user.Name} chegou em {place.Title}"
                        };

                        var jsonString = JsonSerializer.Serialize(fakeData);
                        var jsonElement = JsonDocument.Parse(jsonString).RootElement;

                        await HandlePublicChatSendMessage(jsonElement);
                    }
                }
                else
                {
                    if (visitLog != null)
                    {
                        visitLog.ExitTime = DateTime.Now;
                        visitLog.TotalDurationInMinutes =
                            (visitLog.ExitTime.Value - visitLog.EntryTime).TotalMinutes;

                        await _placeVisitLogRepository.SaveChangesAsync();
                    }
                }
            }

            var jsonResponse2 = SignalRMessage.Serialize(SignalREventType.MapReceiveLocation, new
            {
                userId,
                Latitude = location.Latitude,
                Longitude = location.Longitude,
                user.Name,
                userImage = user.GetFirstPhoto,
                videoCall = location.VideoCall
            });
            await Clients.Others.SendAsync("ReceiveMessage", jsonResponse2);
        }

        private async Task HandlePlaceChatSendMessage(JsonElement data)
        {
            var userId = GetUserId();
            var text = data.GetProperty("Message").GetString();
            var placeId = data.GetProperty("PlaceId").GetString();
            if (string.IsNullOrWhiteSpace(text)) return;
            var user = await _userRepository.GetTrackedEntities().FirstOrDefaultAsync(x => x.Id == userId);
            if (user == null) return;
            var message = new PlaceChatMessage
            {
                SenderId = userId,
                Message = text,
                PlaceId = Guid.Parse(placeId)
            };
            await _placeChatMessageRepository.InsertAsync(message);
            await _placeChatMessageRepository.SaveChangesAsync();
            var blockedUsers = await _blockedUserRepository
                .GetEntities()
                .Where(b => b.Blocked.Id == userId)
                .Select(b => b.Blocker.Id)
                .ToListAsync();
            var blockedConnectionIds = new List<string>();
            foreach (var blockedUserId in blockedUsers)
            {
                if (_userConnections.TryGetValue(blockedUserId, out var connections))
                {
                    blockedConnectionIds.AddRange(connections);
                }
            }
            var jsonResponse = SignalRMessage.Serialize(SignalREventType.PlaceChatReceiveMessage, new
            {
                message.Id,
                CreatedAt = DateTime.Now,
                UserId = userId,
                UserName = user.Name,
                UserImage = user.GetFirstPhoto,
                Latitude = user.LastLatitude,
                Longitude = user.LastLongitude,
                Message = text
            });
            await Clients.AllExcept(blockedConnectionIds).SendAsync("ReceiveMessage", jsonResponse);
        }

        private async Task HandlePlaceChatDeleteMessage(JsonElement data)
        {
            var userId = GetUserId();
            var messageIdStr = data.GetProperty("MessageId").GetString();
            if (string.IsNullOrWhiteSpace(messageIdStr)) return;
            if (!Guid.TryParse(messageIdStr, out Guid messageId)) return;
            var message = await _placeChatMessageRepository
                .GetTrackedEntities()
                .FirstOrDefaultAsync(m => m.Id == messageId) ?? throw new Exception("Mensagem não encontrada.");
            if (message.SenderId != userId) throw new Exception("Você não pode excluir mensagens de outro usuário.");
            message.Message = "Mensagem excluída";
            await _placeChatMessageRepository.SaveChangesAsync();
            var jsonResponse = SignalRMessage.Serialize(SignalREventType.PlaceChatReceiveMessageDeleted, new
            {
                MessageId = message.Id,
                Message = "Mensagem excluída"
            });
            await Clients.All.SendAsync("ReceiveMessage", jsonResponse);
        }

        private async Task HandlePlaceChatGetPreviousMessages(JsonElement data)
        {
            var placeId = data.GetProperty("PlaceId").GetString();
            var userId = GetUserId();
            var previousMessages = await _placeChatMessageRepository
                .GetEntities()
                .Include(x => x.Sender).ThenInclude(x => x.Photos)
                .Where(x => x.PlaceId == Guid.Parse(placeId) && !x.Sender.BlockedBy.Select(y => y.Blocker.Id).Contains(userId))
                .OrderByDescending(m => m.CreatedAt)
                .Take(1000)
                .OrderBy(m => m.CreatedAt)
                .Select(x => new
                {
                    x.Id,
                    CreatedAt = x.CreatedAt.ToUniversalTime(),
                    UserId = x.Sender.Id,
                    UserName = x.Sender.Name,
                    UserImage = x.Sender.GetFirstPhoto,
                    Latitude = x.Sender.LastLatitude,
                    Longitude = x.Sender.LastLongitude,
                    x.Message
                })
                .ToListAsync();
            foreach (var message in previousMessages)
            {
                var jsonResponse = SignalRMessage.Serialize(SignalREventType.PlaceChatReceiveMessage, message);
                await Clients.Caller.SendAsync("ReceiveMessage", jsonResponse);
            }
        }

        private async Task HandlePartyChatSendMessage(JsonElement data)
        {
            var userId = GetUserId();
            var text = data.GetProperty("Message").GetString();
            var partyId = data.GetProperty("PartyId").GetString();
            if (string.IsNullOrWhiteSpace(text)) return;

            var user = await _userRepository
                .GetEntities()
                .Include(x => x.Photos)
                .FirstOrDefaultAsync(x => x.Id == userId);

            if (user == null) return;

            var message = new PartyChatMessage
            {
                SenderId = userId,
                Message = text,
                PartyId = Guid.Parse(partyId!)
            };

            await _partyChatMessageRepository.InsertAsync(message);
            await _partyChatMessageRepository.SaveChangesAsync();

            var blockedUsers = await _blockedUserRepository
                .GetEntities()
                .Where(b => b.Blocked.Id == userId)
                .Select(b => b.Blocker.Id)
                .ToListAsync();

            var blockedConnectionIds = new List<string>();

            foreach (var blockedUserId in blockedUsers)
            {
                if (_userConnections.TryGetValue(blockedUserId, out var connections))
                {
                    blockedConnectionIds.AddRange(connections);
                }
            }

            var jsonResponse = SignalRMessage.Serialize(SignalREventType.PartyChatReceiveMessage, new
            {
                message.Id,
                CreatedAt = DateTime.Now,
                UserId = userId,
                UserName = user.Name,
                UserImage = user.GetFirstPhoto,
                Latitude = user.LastLatitude,
                Longitude = user.LastLongitude,
                Message = text
            });

            await Clients.AllExcept(blockedConnectionIds).SendAsync("ReceiveMessage", jsonResponse);
        }

        private async Task HandlePartyChatSendImage(JsonElement data)
        {
            var userId = GetUserId();
            var base64Image = data.GetProperty("Image").GetString();
            var fileName = data.GetProperty("FileName").GetString();
            var partyId = data.GetProperty("PartyId").GetString();

            if (string.IsNullOrWhiteSpace(base64Image))
                return;

            var user = await _userRepository
                .GetTrackedEntities()
                .Include(x => x.Photos)
                .FirstOrDefaultAsync(x => x.Id == userId);

            if (user == null)
                return;

            var imageBytes = Convert.FromBase64String(base64Image);
            using var stream = new MemoryStream(imageBytes);

            var s3Service = new S3Service();
            var imageUrl = await s3Service.UploadFileAsync(
                $"party_chat_images/{fileName}_{Guid.NewGuid()}.jpg",
                stream,
                "image/jpeg"
            );

            var message = new PartyChatMessage
            {
                SenderId = userId,
                Message = imageUrl,
                PartyId = Guid.Parse(partyId)
            };

            await _partyChatMessageRepository.InsertAsync(message);
            await _partyChatMessageRepository.SaveChangesAsync();

            var jsonResponse = SignalRMessage.Serialize(SignalREventType.PartyChatReceiveMessage, new
            {
                message.Id,
                CreatedAt = DateTime.Now,
                UserId = userId,
                UserName = user.Name,
                UserImage = user.GetFirstPhoto,
                Latitude = user.LastLatitude,
                Longitude = user.LastLongitude,
                Message = imageUrl,
                IsImage = true
            });

            await Clients.All.SendAsync("ReceiveMessage", jsonResponse);
        }

        private async Task HandlePartyChatDeleteMessage(JsonElement data)
        {
            var userId = GetUserId();
            var messageIdStr = data.GetProperty("MessageId").GetString();

            if (string.IsNullOrWhiteSpace(messageIdStr))
                return;

            if (!Guid.TryParse(messageIdStr, out Guid messageId))
                return;

            var message = await _partyChatMessageRepository
                .GetTrackedEntities()
                .FirstOrDefaultAsync(m => m.Id == messageId);

            if (message == null)
                throw new Exception("Mensagem não encontrada.");

            if (message.SenderId != userId)
                throw new Exception("Você não pode excluir mensagens de outro usuário.");

            if (message.Message.StartsWith("https://"))
            {
                var s3Service = new S3Service();
                await s3Service.DeleteFileAsync(message.Message);
            }

            message.Message = "Mensagem excluída";
            await _partyChatMessageRepository.SaveChangesAsync();

            var jsonResponse = SignalRMessage.Serialize(SignalREventType.PartyChatReceiveMessageDeleted, new
            {
                MessageId = message.Id,
                Message = "Mensagem excluída"
            });

            await Clients.All.SendAsync("ReceiveMessage", jsonResponse);
        }

        private async Task HandlePartyChatGetPreviousMessages(JsonElement data)
        {
            var partyId = data.GetProperty("PartyId").GetString();
            var userId = GetUserId();
            var previousMessages = await _partyChatMessageRepository
                .GetEntities()
                .Include(x => x.Sender).ThenInclude(x => x.Photos)
                .Where(x => !x.Sender.BlockedBy.Select(x => x.Blocker.Id).Contains(userId))
                .OrderByDescending(m => m.CreatedAt)
                .Take(1000)
                .OrderBy(m => m.CreatedAt)
                .Select(x => new
                {
                    x.Id,
                    CreatedAt = x.CreatedAt.ToUniversalTime(),
                    UserId = x.Sender.Id,
                    UserName = x.Sender.Name,
                    UserImage = x.Sender.GetFirstPhoto,
                    Latitude = x.Sender.LastLatitude,
                    Longitude = x.Sender.LastLongitude,
                    x.Message
                })
                .ToListAsync();

            foreach (var message in previousMessages)
            {
                var jsonResponse = SignalRMessage.Serialize(SignalREventType.PartyChatReceiveMessage, message);
                await Clients.Caller.SendAsync("ReceiveMessage", jsonResponse);
            }
        }

        private async Task HandlePublicChatSendMessage(JsonElement data)
        {
            var userId = GetUserId();
            var text = data.GetProperty("Message").GetString();
            if (string.IsNullOrWhiteSpace(text)) return;

            var user = await _userRepository
                .GetTrackedEntities()
                .Include(x => x.Photos)
                .FirstOrDefaultAsync(x => x.Id == userId);

            if (user == null) return;

            var message = new PublicChatMessage
            {
                SenderId = userId,
                Message = text
            };

            await _publicChatMessageRepository.InsertAsync(message);
            await _publicChatMessageRepository.SaveChangesAsync();

            var blockedUsers = await _blockedUserRepository
                .GetEntities()
                .Where(b => b.Blocked.Id == userId)
                .Select(b => b.Blocker.Id)
                .ToListAsync();

            var blockedConnectionIds = new List<string>();

            foreach (var blockedUserId in blockedUsers)
            {
                if (_userConnections.TryGetValue(blockedUserId, out var connections))
                {
                    blockedConnectionIds.AddRange(connections);
                }
            }

            var jsonResponse = SignalRMessage.Serialize(SignalREventType.PublicChatReceiveMessage, new
            {
                message.Id,
                CreatedAt = DateTime.Now,
                UserId = userId,
                UserName = user.Name,
                UserImage = user.GetFirstPhoto,
                Latitude = user.LastLatitude,
                Longitude = user.LastLongitude,
                Message = text
            });

            await Clients.AllExcept(blockedConnectionIds).SendAsync("ReceiveMessage", jsonResponse);
        }

        private async Task HandlePublicChatDeleteMessage(JsonElement data)
        {
            var userId = GetUserId();
            var messageId = data.GetProperty("MessageId").GetString();

            var message = await _publicChatMessageRepository
                .GetTrackedEntities()
                .FirstOrDefaultAsync(m => m.Id == Guid.Parse(messageId))
                ?? throw new Exception("Mensagem não encontrada.");

            if (message.SenderId != userId)
                throw new Exception("Você não pode excluir mensagens de outro usuário.");

            message.Message = "Mensagem excluída";

            await _publicChatMessageRepository.SaveChangesAsync();
            Log.Information($"Mensagem {message.Id} do usuário {userId} marcada como excluída.");

            var jsonResponse = SignalRMessage.Serialize(SignalREventType.PublicChatReceiveMessageDeleted, new
            {
                MessageId = message.Id,
                Message = "Mensagem excluída"
            });

            await Clients.All.SendAsync("ReceiveMessage", jsonResponse);
        }

        private async Task HandlePublicChatGetPreviousMessages()
        {
            var userId = GetUserId();
            var previousMessages = await _publicChatMessageRepository
                .GetEntities()
                .Include(x => x.Sender).ThenInclude(x => x.Photos)
                .Where(x => !x.Sender.BlockedBy.Select(x => x.Blocker.Id).Contains(userId))
                .OrderByDescending(m => m.CreatedAt)
                .Take(1000)
                .OrderBy(m => m.CreatedAt)
                .Select(x => new
                {
                    x.Id,
                    CreatedAt = x.CreatedAt.ToUniversalTime(),
                    UserId = x.Sender.Id,
                    UserName = x.Sender.Name,
                    UserImage = x.Sender.GetFirstPhoto,
                    Latitude = x.Sender.LastLatitude,
                    Longitude = x.Sender.LastLongitude,
                    x.Message
                })
                .ToListAsync();

            foreach (var message in previousMessages)
            {
                var jsonResponse = SignalRMessage.Serialize(SignalREventType.PublicChatReceiveMessage, message);
                await Clients.Caller.SendAsync("ReceiveMessage", jsonResponse);
            }
        }

        private async Task HandlePrivateChatSendMessage(JsonElement data)
        {
            var senderUserId = GetUserId();
            var receiverUserId = data.GetProperty("ReceiverUserId").GetString();
            var messageText = data.GetProperty("Message").GetString();

            if (string.IsNullOrWhiteSpace(messageText)) return;

            var sender = await _userRepository.GetTrackedEntities()
                .FirstOrDefaultAsync(x => x.Id == senderUserId);
            var receiver = await _userRepository.GetTrackedEntities()
                .FirstOrDefaultAsync(x => x.Id == receiverUserId);

            if (sender == null || receiver == null)
            {
                throw new Exception("Usuário não encontrado");
            }

            var chatMessage = new PrivateChatMessage
            {
                Sender = sender,
                Receiver = receiver,
                Message = messageText,
                IsRead = false
            };
            chatMessage.SetCreatedAt(DateTime.Now);

            await _privateChatMessageRepository.InsertAsync(chatMessage);
            await _privateChatMessageRepository.SaveChangesAsync();

            var jsonResponse = SignalRMessage.Serialize(SignalREventType.PrivateChatReceiveMessage, new
            {
                CreatedAt = chatMessage.CreatedAt,
                MessageId = chatMessage.Id,
                UserId = senderUserId,
                UserName = sender.Name,
                Message = messageText
            });
            await Clients.User(senderUserId).SendAsync("ReceiveMessage", jsonResponse);
            await Clients.User(receiverUserId).SendAsync("ReceiveMessage", jsonResponse);

            if (!string.IsNullOrWhiteSpace(receiver.FcmToken))
            {
                var notification = new FirebaseAdmin.Messaging.Notification
                {
                    Title = "Mensagem Recebida",
                    Body = $"Você recebeu uma mensagem privada!"
                };

                var message = new Message
                {
                    Token = receiver.FcmToken,
                    Notification = notification,
                };

                try
                {
                    string response = await FirebaseMessaging.DefaultInstance.SendAsync(message);
                    Log.Information($"Notificação enviada com sucesso: {response}");
                }
                catch (Exception ex)
                {
                    Log.Error($"Erro ao enviar notificação: {ex.Message}");
                }
            }
        }

        private async Task HandlePrivateChatGetRecentChats()
        {
            var userId = GetUserId();
            var messages = await _privateChatMessageRepository.GetEntities()
                .Include(x => x.Sender).ThenInclude(x => x.Photos)
                .Include(x => x.Receiver).ThenInclude(x => x.Photos)
                .Where(m => m.Sender.Id == userId || m.Receiver.Id == userId)
                .Select(m => new
                {
                    SenderId = m.Sender.Id,
                    SenderName = m.Sender.Name,
                    SenderImage = m.Sender.GetFirstPhoto,
                    SenderLastActivity = m.Sender.LastActivity,

                    ReceiverId = m.Receiver.Id,
                    ReceiverName = m.Receiver.Name,
                    ReceiverImage = m.Receiver.GetFirstPhoto,
                    ReceiverLastActivity = m.Receiver.LastActivity,

                    m.Message,
                    m.CreatedAt,
                    m.IsRead,
                })
                .ToListAsync();

            var recentChats = messages
                .GroupBy(m => m.ReceiverId == userId ? m.SenderId : m.ReceiverId)
                .Select(group => new
                {
                    UserId = group.Key,
                    UserName = group.First().ReceiverId == userId ? group.First().SenderName : group.First().ReceiverName,
                    UserImage = group.First().ReceiverId == userId ? group.First().SenderImage : group.First().ReceiverImage,
                    LastActivity = group.First().ReceiverId == userId ? group.First().SenderLastActivity : group.First().ReceiverLastActivity,
                    LastMessage = group.OrderByDescending(m => m.CreatedAt).First().Message,
                    LastMessageDate = group.Max(m => m.CreatedAt),
                    UnreadCount = group.Count(m => m.ReceiverId == userId && !m.IsRead)
                })
                .OrderByDescending(c => c.LastMessageDate)
                .ToList();

            var jsonResponse = SignalRMessage.Serialize(SignalREventType.PrivateChatReceiveRecentChats, recentChats);
            await Clients.Caller.SendAsync("ReceiveMessage", jsonResponse);
        }

        private async Task HandlePrivateChatGetPreviousMessages(JsonElement data)
        {
            var userId = GetUserId();
            var receiverUserId = data.GetProperty("ReceiverUserId").GetString();

            var previousMessages = await _privateChatMessageRepository.GetEntities()
                .Where(m => (m.Sender.Id == userId && m.Receiver.Id == receiverUserId) ||
                            (m.Sender.Id == receiverUserId && m.Receiver.Id == userId))
                .Select(x => new
                {
                    x.Id,
                    CreatedAt = x.CreatedAt.ToUniversalTime(),
                    SenderId = x.Sender.Id,
                    ReceiverId = x.Receiver.Id,
                    x.Message,
                    x.Reactions,
                    x.ReplyToMessageId
                })
                .OrderByDescending(m => m.CreatedAt)
                .Take(1000)
                .OrderBy(m => m.CreatedAt)
                .ToListAsync();

            var jsonResponse = SignalRMessage.Serialize(SignalREventType.PrivateChatReceivePreviousMessages, previousMessages);
            await Clients.Caller.SendAsync("ReceiveMessage", jsonResponse);
        }

        private async Task HandlePrivateChatDeleteMessage(JsonElement data)
        {
            var messageId = data.GetProperty("MessageId").GetString();
            var userId = GetUserId();

            var message = await _privateChatMessageRepository
                .GetTrackedEntities()
                .Include(x => x.Receiver)
                .Include(x => x.Sender)
                .FirstOrDefaultAsync(m => m.Id.ToString() == messageId);

            if (message == null)
            {
                Log.Warning($"Mensagem {messageId} não encontrada para exclusão pelo usuário {userId}");
                throw new Exception("Mensagem não encontrada");
            }

            if (message.Sender.Id != userId && message.Receiver.Id != userId)
            {
                Log.Warning($"Usuário {userId} tentou excluir mensagem {messageId} sem permissão");
                throw new UnauthorizedAccessException("Você não tem permissão para excluir esta mensagem");
            }

            if (message.Message.StartsWith("https://"))
            {
                var s3Service = new S3Service();
                await s3Service.DeleteFileAsync(message.Message);
            }

            message.Message = "Mensagem excluída";
            await _privateChatMessageRepository.SaveChangesAsync();
            Log.Information($"Usuário {userId} excluiu a mensagem {messageId}");

            var jsonResponse = SignalRMessage.Serialize(SignalREventType.PrivateChatReceiveMessageDeleted, new
            {
                MessageId = messageId,
            });
            await Clients.User(message.Sender.Id).SendAsync("ReceiveMessage", jsonResponse);
            await Clients.User(message.Receiver.Id).SendAsync("ReceiveMessage", jsonResponse);
        }

        private async Task HandlePrivateChatDeleteChat(JsonElement data)
        {
            var receiverUserId = data.GetProperty("ReceiverUserId").GetString();
            var userId = GetUserId();
            var messages = await _privateChatMessageRepository.GetTrackedEntities()
                .Include(x => x.Sender)
                .Include(x => x.Receiver)
                .Where(m => (m.Sender.Id == userId && m.Receiver.Id == receiverUserId) ||
                            (m.Sender.Id == receiverUserId && m.Receiver.Id == userId))
                .ToListAsync();

            foreach (var message in messages)
            {
                var jsonResponse = SignalRMessage.Serialize(SignalREventType.PrivateChatReceiveMessageDeleted, new
                {
                    MessageId = message.Id,
                });
                await Clients.User(message.Sender.Id).SendAsync("ReceiveMessage", jsonResponse);
                await Clients.User(message.Receiver.Id).SendAsync("ReceiveMessage", jsonResponse);

                if (message.Message.StartsWith("https://"))
                {
                    var s3Service = new S3Service();
                    await s3Service.DeleteFileAsync(message.Message);
                }
                _privateChatMessageRepository.Delete(message);
            }
            await _privateChatMessageRepository.SaveChangesAsync();
            Log.Information($"Usuário {userId} excluiu o chat com {receiverUserId}");
        }

        private async Task HandlePrivateChatSendImage(JsonElement data)
        {
            var receiverUserId = data.GetProperty("ReceiverUserId").GetString();
            var imageBase64 = data.GetProperty("Image").GetString();
            var fileName = data.GetProperty("FileName").GetString();
            var senderUserId = GetUserId();

            Log.Information($"Usuário {senderUserId} enviou uma imagem para {receiverUserId}.");

            var imageBytes = Convert.FromBase64String(imageBase64);
            using var imageStream = new MemoryStream(imageBytes);
            var s3Service = new S3Service();
            var imageUrl = await s3Service.UploadFileAsync($"images/{fileName}{Guid.NewGuid()}{Guid.NewGuid()}", imageStream, "image/jpeg");

            var sender = await _userRepository.GetTrackedEntities().FirstOrDefaultAsync(x => x.Id == senderUserId);
            var receiver = await _userRepository.GetTrackedEntities().FirstOrDefaultAsync(x => x.Id == receiverUserId);

            if (sender == null || receiver == null)
            {
                throw new Exception("Usuário não encontrado");
            }

            var chatMessage = new PrivateChatMessage
            {
                Sender = sender,
                Receiver = receiver,
                Message = imageUrl,
                IsRead = false
            };
            chatMessage.SetCreatedAt(DateTime.Now);

            await _privateChatMessageRepository.InsertAsync(chatMessage);
            await _privateChatMessageRepository.SaveChangesAsync();

            var jsonResponse = SignalRMessage.Serialize(SignalREventType.PrivateChatReceiveMessage, new
            {
                MessageId = chatMessage.Id,
                UserId = senderUserId,
                UserName = sender.Name,
                Message = imageUrl
            });
            await Clients.User(senderUserId).SendAsync("ReceiveMessage", jsonResponse);
            await Clients.User(receiverUserId!).SendAsync("ReceiveMessage", jsonResponse);
        }

        private async Task HandlePrivateChatMarkMessagesAsRead(JsonElement data)
        {
            var senderUserId = data.GetProperty("SenderUserId").GetString();
            var receiverUserId = GetUserId();
            var messages = await _privateChatMessageRepository.GetTrackedEntities()
                .Where(m => m.Sender.Id == senderUserId && m.Receiver.Id == receiverUserId && !m.IsRead)
                .ToListAsync();

            Log.Information($"Usuário {receiverUserId} leu {messages.Count} de {senderUserId}");

            foreach (var message in messages)
            {
                message.IsRead = true;
            }

            await _privateChatMessageRepository.SaveChangesAsync();
        }

        private async Task HandlePrivateChatSendAudio(JsonElement data)
        {
            var receiverUserId = data.GetProperty("ReceiverUserId").GetString();
            var audioBase64 = data.GetProperty("Audio").GetString();
            var fileName = data.GetProperty("FileName").GetString();
            var senderUserId = GetUserId();

            var sender = await _userRepository.GetTrackedEntities().FirstOrDefaultAsync(x => x.Id == senderUserId);
            var receiver = await _userRepository.GetTrackedEntities().FirstOrDefaultAsync(x => x.Id == receiverUserId);

            if (sender == null || receiver == null)
                throw new Exception("Usuário não encontrado");

            var audioBytes = Convert.FromBase64String(audioBase64!);
            using var audioStream = new MemoryStream(audioBytes);
            var s3Service = new S3Service();
            var audioUrl = await s3Service.UploadFileAsync(
                $"audios/{fileName}{Guid.NewGuid()}",
                audioStream,
                "audio/mpeg"
            );

            var chatMessage = new PrivateChatMessage
            {
                Sender = sender,
                Receiver = receiver,
                Message = audioUrl,
                IsRead = false
            };
            chatMessage.SetCreatedAt(DateTime.Now);

            await _privateChatMessageRepository.InsertAsync(chatMessage);
            await _privateChatMessageRepository.SaveChangesAsync();

            var jsonResponse = SignalRMessage.Serialize(SignalREventType.PrivateChatReceiveMessage, new
            {
                MessageId = chatMessage.Id,
                UserId = senderUserId,
                UserName = sender.Name,
                Message = audioUrl
            });

            await Clients.User(senderUserId).SendAsync("ReceiveMessage", jsonResponse);
            await Clients.User(receiverUserId).SendAsync("ReceiveMessage", jsonResponse);
        }

        private async Task HandlePrivateChatSendVideo(JsonElement data)
        {
            var receiverUserId = data.GetProperty("ReceiverUserId").GetString();
            var videoBase64 = data.GetProperty("Video").GetString();
            var fileName = data.GetProperty("FileName").GetString();
            var senderUserId = GetUserId();

            var sender = await _userRepository.GetTrackedEntities().FirstOrDefaultAsync(x => x.Id == senderUserId);
            var receiver = await _userRepository.GetTrackedEntities().FirstOrDefaultAsync(x => x.Id == receiverUserId);

            if (sender == null || receiver == null)
                throw new Exception("Usuário não encontrado");

            var videoBytes = Convert.FromBase64String(videoBase64);
            using var videoStream = new MemoryStream(videoBytes);
            var s3Service = new S3Service();
            var videoUrl = await s3Service.UploadFileAsync(
                $"videos/{fileName}{Guid.NewGuid()}",
                videoStream,
                "video/mp4"
            );

            var chatMessage = new PrivateChatMessage
            {
                Sender = sender,
                Receiver = receiver,
                Message = videoUrl,
                IsRead = false
            };
            chatMessage.SetCreatedAt(DateTime.Now);

            await _privateChatMessageRepository.InsertAsync(chatMessage);
            await _privateChatMessageRepository.SaveChangesAsync();

            var jsonResponse = SignalRMessage.Serialize(SignalREventType.PrivateChatReceiveMessage, new
            {
                MessageId = chatMessage.Id,
                UserId = senderUserId,
                UserName = sender.Name,
                Message = videoUrl
            });

            await Clients.User(senderUserId).SendAsync("ReceiveMessage", jsonResponse);
            await Clients.User(receiverUserId).SendAsync("ReceiveMessage", jsonResponse);
        }

        private async Task HandlePrivateChatGetFavorites()
        {
            var userId = GetUserId();
            var favorites = await _favoriteChatRepository.GetEntities()
                .Where(f => f.User.Id == userId)
                .Select(f => new { f.ChatUser.Id })
                .ToListAsync();
            var jsonResponse = SignalRMessage.Serialize(SignalREventType.PrivateChatReceiveFavorites, favorites);
            await Clients.Caller.SendAsync("ReceiveMessage", jsonResponse);
        }

        private async Task HandlePrivateChatAddFavorite(JsonElement data)
        {
            var userId = GetUserId();
            var chatUserId = data.GetProperty("ChatUserId").GetString();

            var user = await _userRepository.GetTrackedEntities().FirstOrDefaultAsync(x => x.Id == userId);
            var chatUser = await _userRepository.GetTrackedEntities().FirstOrDefaultAsync(x => x.Id == chatUserId);

            var favorite = new FavoriteChat
            {
                User = user!,
                ChatUser = chatUser!,
            };

            await _favoriteChatRepository.InsertAsync(favorite);
            await _favoriteChatRepository.SaveChangesAsync();

            Log.Information($"Usuário {userId} favoritou o chat com {chatUserId}");
        }

        private async Task HandlePrivateChatRemoveFavorite(JsonElement data)
        {
            var userId = GetUserId();
            var chatUserId = data.GetProperty("ChatUserId").GetString();

            var favorite = await _favoriteChatRepository.GetTrackedEntities()
                .FirstOrDefaultAsync(f => f.User.Id == userId && f.ChatUser.Id == chatUserId);

            if (favorite != null)
            {
                _favoriteChatRepository.Delete(favorite);
                await _favoriteChatRepository.SaveChangesAsync();
                Log.Information($"Usuário {userId} removeu o favorito do chat com {chatUserId}");
            }
        }

        private async Task HandlePrivateChatReactToMessage(JsonElement data)
        {
            var userId = GetUserId();
            var messageId = data.GetProperty("MessageId").GetString();
            var reaction = data.GetProperty("Reaction").GetString();

            var guid = Guid.Parse(messageId);
            var messageObj = await _privateChatMessageRepository
                .GetTrackedEntities()
                .Include(m => m.Sender)
                .Include(m => m.Receiver)
                .FirstOrDefaultAsync(m => m.Id == guid) ??
                throw new Exception("Mensagem não encontrada para reagir.");

            messageObj.Reactions ??= [];

            if (string.IsNullOrEmpty(reaction))
            {
                messageObj.Reactions.Remove(userId);
            }
            else
            {
                messageObj.Reactions[userId] = reaction;
            }

            await _privateChatMessageRepository.SaveChangesAsync();

            var jsonResponse = SignalRMessage.Serialize(
                SignalREventType.PrivateChatReceiveReaction,
                new
                {
                    MessageId = messageObj.Id,
                    Reaction = reaction,
                    ReactorUserId = userId
                }
            );

            await Clients.User(messageObj.Sender.Id).SendAsync("ReceiveMessage", jsonResponse);
            await Clients.User(messageObj.Receiver.Id).SendAsync("ReceiveMessage", jsonResponse);
        }

        private async Task HandlePrivateChatReplyToMessage(JsonElement data)
        {
            var senderUserId = GetUserId();
            var receiverUserId = data.GetProperty("ReceiverUserId").GetString();
            var originalMessageId = data.GetProperty("OriginalMessageId").GetString();
            var newMessageText = data.GetProperty("Message").GetString();

            var sender = await _userRepository.GetTrackedEntities()
                .FirstOrDefaultAsync(x => x.Id == senderUserId);
            var receiver = await _userRepository.GetTrackedEntities()
                .FirstOrDefaultAsync(x => x.Id == receiverUserId);

            if (sender == null || receiver == null)
                throw new Exception("Usuário não encontrado.");

            var chatMessage = new PrivateChatMessage
            {
                Sender = sender,
                Receiver = receiver,
                Message = newMessageText!,
                IsRead = false,
                ReplyToMessageId = Guid.Parse(originalMessageId!)
            };
            chatMessage.SetCreatedAt(DateTime.Now);

            await _privateChatMessageRepository.InsertAsync(chatMessage);
            await _privateChatMessageRepository.SaveChangesAsync();

            var jsonResponse = SignalRMessage.Serialize(
                SignalREventType.PrivateChatReceiveReply,
                new
                {
                    CreatedAt = chatMessage.CreatedAt,
                    MessageId = chatMessage.Id,
                    UserId = senderUserId,
                    UserName = sender.Name,
                    Message = newMessageText,
                    OriginalMessageId = originalMessageId
                }
            );

            await Clients.User(senderUserId).SendAsync("ReceiveMessage", jsonResponse);
            await Clients.User(receiverUserId).SendAsync("ReceiveMessage", jsonResponse);
        }

        private async Task HandleVideoCallInitiate(JsonElement data)
        {
            var callerUserId = GetUserId();
            var targetUserId = data.GetProperty("TargetUserId").GetString();

            if (await IsMonthlyLimitReached(targetUserId) || await IsMonthlyLimitReached(callerUserId))
            {
                var rejectedMessage = SignalRMessage.Serialize(
                    SignalREventType.VideoCallReject,
                    new
                    {
                        reason = "O limite de 360 minutos foi atingido no mês."
                    }
                );
                await Clients.User(callerUserId).SendAsync("ReceiveMessage", rejectedMessage);
                await Clients.User(targetUserId).SendAsync("ReceiveMessage", rejectedMessage);
                return;
            }

            if (!_userConnections.ContainsKey(targetUserId))
            {
                var response = SignalRMessage.Serialize(
                    SignalREventType.VideoCallReject,
                    new { reason = "User offline" }
                );
                await Clients.User(callerUserId).SendAsync("ReceiveMessage", response);
                return;
            }

            var roomId = Guid.NewGuid().ToString("N");

            var callerName = await _userRepository.GetEntities()
                .Where(x => x.Id == callerUserId)
                .Select(x => x.Name)
                .FirstOrDefaultAsync();

            var incomingCallMessage = SignalRMessage.Serialize(
                SignalREventType.VideoCallIncoming,
                new
                {
                    roomId,
                    callerUserId,
                    callerName
                }
            );
            await Clients.User(targetUserId).SendAsync("ReceiveMessage", incomingCallMessage);

            var callInitiatedMessage = SignalRMessage.Serialize(
                SignalREventType.VideoCallInitiate,
                new { roomId, targetUserId }
            );
            await Clients.User(callerUserId).SendAsync("ReceiveMessage", callInitiatedMessage);
        }

        private async Task HandleVideoCallAccept(JsonElement data)
        {
            var targetUserId = GetUserId();
            var callerUserId = data.GetProperty("CallerUserId").GetString();
            var roomId = data.GetProperty("RoomId").GetString();

            var caller = await _userRepository.GetTrackedEntities()
                .FirstOrDefaultAsync(x => x.Id == callerUserId);
            var callee = await _userRepository.GetTrackedEntities()
                .FirstOrDefaultAsync(x => x.Id == targetUserId);

            var callLog = new VideoCallLog
            {
                RoomId = roomId!,
                Caller = caller!,
                Callee = callee!,
                StartTime = DateTime.Now
            };
            await _videoCallLogRepository.InsertAsync(callLog);
            await _videoCallLogRepository.SaveChangesAsync();

            var acceptedMessage = SignalRMessage.Serialize(
                SignalREventType.VideoCallAccept,
                new
                {
                    roomId,
                    targetUserId
                }
            );
            await Clients.User(callerUserId).SendAsync("ReceiveMessage", acceptedMessage);
        }

        private async Task HandleVideoCallReject(JsonElement data)
        {
            var targetUserId = GetUserId();
            var callerUserId = data.GetProperty("CallerUserId").GetString();
            var roomId = data.GetProperty("RoomId").GetString();

            var rejectedMessage = SignalRMessage.Serialize(
                SignalREventType.VideoCallReject,
                new
                {
                    roomId,
                    targetUserId
                }
            );
            await Clients.User(callerUserId).SendAsync("ReceiveMessage", rejectedMessage);
        }

        private async Task HandleVideoCallEnd(JsonElement data)
        {
            var userId = GetUserId();
            var roomId = data.GetProperty("RoomId").GetString();

            var endMessage = SignalRMessage.Serialize(
                SignalREventType.VideoCallEnd,
                new
                {
                    roomId,
                    EndedByUserId = userId
                }
            );
            await Clients.All.SendAsync("ReceiveMessage", endMessage);
            Log.Information($"Usuário {userId} encerrou a chamada {roomId}");

            var callLog = await _videoCallLogRepository.GetTrackedEntities()
                .Include(x => x.Caller)
                .Include(x => x.Callee)
                .FirstOrDefaultAsync(x => x.RoomId == roomId);

            if (callLog != null && callLog.EndTime == null)
            {
                callLog.EndTime = DateTime.Now;
                callLog.DurationMinutes = (int)(callLog.EndTime.Value - callLog.StartTime).TotalMinutes;
                await _videoCallLogRepository.SaveChangesAsync();
            }
        }

        #endregion

        #region Conexões e Helpers

        public override async Task OnConnectedAsync()
        {
            var userId = GetUserId();
            Log.Information($"Usuário {userId} conectado");

            if (_userConnections.TryGetValue(userId, out var connections))
            {
                connections.Add(Context.ConnectionId);
            }
            else
            {
                _userConnections[userId] = new List<string> { Context.ConnectionId };
            }

            await base.OnConnectedAsync();
        }

        public override async Task OnDisconnectedAsync(Exception? exception)
        {
            var userId = GetUserId();
            Log.Information($"Usuário {userId} desconectado");

            if (_userConnections.TryGetValue(userId, out var connections))
            {
                connections.Remove(Context.ConnectionId);
                if (connections.Count == 0)
                {
                    _userConnections.TryRemove(userId, out _);

                    var ongoingVisits = await _placeVisitLogRepository
                        .GetTrackedEntities()
                        .Where(v => v.UserId == userId && v.ExitTime == null)
                        .ToListAsync();

                    foreach (var visit in ongoingVisits)
                    {
                        visit.ExitTime = DateTime.Now;
                        visit.TotalDurationInMinutes =
                            (visit.ExitTime.Value - visit.EntryTime).TotalMinutes;
                    }
                    await _placeVisitLogRepository.SaveChangesAsync();

                    var ongoingCalls = await _videoCallLogRepository.GetEntities()
                        .Include(x => x.Caller)
                        .Include(x => x.Callee)
                        .Where(x =>
                            x.EndTime == null &&
                            (x.Caller.Id == userId || x.Callee.Id == userId)
                        ).ToListAsync();

                    foreach (var call in ongoingCalls)
                    {
                        call.EndTime = DateTime.Now;
                        call.DurationMinutes = (int)(call.EndTime.Value - call.StartTime).TotalMinutes;
                        await _videoCallLogRepository.SaveChangesAsync();

                        var endMessage = SignalRMessage.Serialize(
                            SignalREventType.VideoCallEnd,
                            new
                            {
                                RoomId = call.RoomId,
                                EndedByUserId = userId
                            }
                        );
                        await Clients.All.SendAsync("ReceiveMessage", endMessage);

                        Log.Information($"Chamada {call.RoomId} encerrada para o usuário {userId} no OnDisconnectedAsync.");
                    }
                }
            }

            var jsonResponse = SignalRMessage.Serialize(SignalREventType.UserDisconnected, new { userId });
            await Clients.Others.SendAsync("ReceiveMessage", jsonResponse);

            await base.OnDisconnectedAsync(exception);
        }


        private async Task<bool> IsMonthlyLimitReached(string userId)
        {
            var startOfMonth = new DateTime(DateTime.UtcNow.Year, DateTime.UtcNow.Month, 1);

            var usedMinutes = await _videoCallLogRepository.GetEntities()
                .Where(x =>
                    (x.Caller.Id == userId || x.Callee.Id == userId) &&
                    x.StartTime >= startOfMonth &&
                    x.EndTime != null)
                .SumAsync(x => x.DurationMinutes);

            var purchasedMinutes = await _videoCallPurchaseRepository.GetEntities()
                .Where(p => p.UserId == userId && p.PurchaseDate >= startOfMonth)
                .SumAsync(p => p.Minutes);

            var totalLimit = 360 + purchasedMinutes;

            return usedMinutes >= totalLimit;
        }

        private double DistanceInMeters(double lat1, double lon1, double lat2, double lon2)
        {
            const double R = 6371000;

            double dLat = ToRadians(lat2 - lat1);
            double dLon = ToRadians(lon2 - lon1);

            double a =
                Math.Sin(dLat / 2) * Math.Sin(dLat / 2) +
                Math.Cos(ToRadians(lat1)) * Math.Cos(ToRadians(lat2)) *
                Math.Sin(dLon / 2) * Math.Sin(dLon / 2);

            double c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));
            double distance = R * c;
            return distance;
        }

        private double ToRadians(double angle)
        {
            return Math.PI * angle / 180.0;
        }

        private string GetUserId()
        {
            return Context.User?.GetUserId() ?? throw new ArgumentNullException("O token não possui ID de usuário");
        }

        private class LocationModel
        {
            public double Latitude { get; set; }
            public double Longitude { get; set; }
            public string FcmToken { get; set; }
            public bool VideoCall { get; set; }
        }

        #endregion
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DataAccess\BaseRepository.cs ===
﻿using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;

namespace Snarf.DataAccess
{
    public abstract class BaseRepository<TType, TContext>
            where TType : class
            where TContext : DbContext
    {
        protected readonly TContext _dbContext;
        protected BaseRepository(TContext context) => _dbContext = context;
        protected TContext GetContext() => _dbContext;
        public virtual IQueryable<TType> GetEntities() => GetContext().Set<TType>()
                                                                      .AsNoTracking()
                                                                      .AsQueryable();
        public virtual IQueryable<TType> GetTrackedEntities() => GetContext().Set<TType>()
                                                                             .AsQueryable();
        public virtual async Task<IEnumerable<TType>> GetList() => await GetEntities().ToListAsync();
        public virtual void Insert(TType entity) => GetContext().Set<TType>()
                                                                .Add(entity);
        public virtual void InsertRange(IEnumerable<TType> entity) => GetContext().Set<TType>()
                                                                                  .AddRange(entity);
        public virtual async Task InsertAsync(TType entity) => await GetContext().Set<TType>()
                                                                                 .AddAsync(entity);
        public virtual void Update(TType entity) => GetContext().Set<TType>()
                                                                .Update(entity);
        public virtual void UpdateRange(TType[] entity) => GetContext().Set<TType>()
                                                                       .UpdateRange(entity);
        public virtual void Delete(TType entity) => GetContext().Set<TType>()
                                                                .Remove(entity);
        public virtual void DeleteRange(TType[] entity) => GetContext().Set<TType>()
                                                                .RemoveRange(entity);
        public virtual bool SaveChanges() => GetContext().SaveChanges() > 0;
        public virtual void Detach(TType entity) => GetContext().Entry(entity).State = EntityState.Detached;
        public virtual void Attach(TType entity) => GetContext().Set<TType>()
                                                                .Attach(entity);
        public virtual void AttachRange(IEnumerable<TType> entity) => GetContext().Set<TType>()
                                                                                  .AttachRange(entity);

        public virtual IEnumerable<EntityEntry> GetChanges()
        {
            return GetContext().ChangeTracker.Entries();
        }

        public virtual void SeeChanges()
        {
            var change = GetContext().ChangeTracker.Entries();
        }

        public virtual void ClearChanges() => GetContext().ChangeTracker.Clear();

        public virtual async Task<bool> SaveChangesAsync() => await GetContext().SaveChangesAsync() > 0;
        public virtual async Task<List<TType>> GetListAsync() => await GetEntities().ToListAsync();
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DataAccess\BlockedUserRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Repository;
using Snarf.Persistence;

namespace Snarf.DataAccess
{
    public class BlockedUserRepository(SnarfContext context) : BaseRepository<BlockedUser, SnarfContext>(context), IBlockedUserRepository;
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DataAccess\FavoriteChatRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Repository;
using Snarf.Persistence;

namespace Snarf.DataAccess
{
    public class FavoriteChatRepository(SnarfContext context) : BaseRepository<FavoriteChat, SnarfContext>(context), IFavoriteChatRepository;
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DataAccess\PartyChatMessageRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Repository;
using Snarf.Persistence;

namespace Snarf.DataAccess
{
    public class PartyChatMessageRepository(SnarfContext context) : BaseRepository<PartyChatMessage, SnarfContext>(context), IPartyChatMessageRepository;
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DataAccess\PartyRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Repository;
using Snarf.Persistence;

namespace Snarf.DataAccess
{
    public class PartyRepository(SnarfContext context) : BaseRepository<Party, SnarfContext>(context), IPartyRepository;
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DataAccess\PlaceChatMessageRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Repository;
using Snarf.Persistence;

namespace Snarf.DataAccess
{
    public class PlaceChatMessageRepository(SnarfContext context) : BaseRepository<PlaceChatMessage, SnarfContext>(context), IPlaceChatMessageRepository;
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DataAccess\PlaceRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Repository;
using Snarf.Persistence;

namespace Snarf.DataAccess
{
    public class PlaceRepository(SnarfContext context) : BaseRepository<Place, SnarfContext>(context), IPlaceRepository;
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DataAccess\PlaceVisitLogRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Repository;
using Snarf.Persistence;

namespace Snarf.DataAccess
{
    public class PlaceVisitLogRepository(SnarfContext context) : BaseRepository<PlaceVisitLog, SnarfContext>(context), IPlaceVisitLogRepository;
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DataAccess\PrivateChatMessageRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Repository;
using Snarf.Persistence;

namespace Snarf.DataAccess
{
    public class PrivateChatMessageRepository(SnarfContext context) : BaseRepository<PrivateChatMessage, SnarfContext>(context), IPrivateChatMessageRepository;
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DataAccess\PublicChatMessageRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Repository;
using Snarf.Persistence;

namespace Snarf.DataAccess
{
    public class PublicChatMessageRepository(SnarfContext context) : BaseRepository<PublicChatMessage, SnarfContext>(context), IPublicChatMessageRepository;
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DataAccess\UserRepository.cs ===
﻿using Snarf.Domain.Base;
using Snarf.Infrastructure.Repository;
using Snarf.Persistence;

namespace Snarf.DataAccess
{
    public class UserRepository(SnarfContext context) : BaseRepository<User, SnarfContext>(context), IUserRepository;
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DataAccess\VideoCallLogRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Repository;
using Snarf.Persistence;

namespace Snarf.DataAccess
{
    public class VideoCallLogRepository(SnarfContext context) : BaseRepository<VideoCallLog, SnarfContext>(context), IVideoCallLogRepository;
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DataAccess\VideoCallPurchaseRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Repository;
using Snarf.Persistence;

namespace Snarf.DataAccess
{
    public class VideoCallPurchaseRepository(SnarfContext context) : BaseRepository<VideoCallPurchase, SnarfContext>(context), IVideoCallPurchaseRepository;
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Base\BaseEntity.cs ===
﻿using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace Snarf.Domain.Base
{
    public abstract class BaseEntity
    {
        protected BaseEntity()
        {
            SetCreatedAt();
        }

        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public Guid Id { get; set; }
        public DateTime CreatedAt { get; private set; }
        public DateTime UpdatedAt { get; private set; }

        private void SetCreatedAt()
        {
            CreatedAt = DateTime.UtcNow;
            SetUpdatedAt();
        }

        public void SetCreatedAt(DateTime dateTime)
        {
            CreatedAt = dateTime;
        }

        public void SetUpdatedAt()
        {
            UpdatedAt = DateTime.UtcNow;
        }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Base\User.cs ===
﻿using Microsoft.AspNetCore.Identity;
using Snarf.Domain.Entities;
using Snarf.Domain.Enum;
using Snarf.Domain.Enum.UserDetails;

namespace Snarf.Domain.Base
{
    public class User : IdentityUser
    {
        public required string Name { get; set; }
        public required RoleName Role { get; set; }

        public DateTime? LastActivity { get; set; }
        public double? LastLatitude { get; set; }
        public double? LastLongitude { get; set; }
        public string? FcmToken { get; set; }

        // LOCATION

        public string? Description { get; set; }
        public double? BirthLatitude { get; set; }
        public double? BirthLongitude { get; set; }

        public LocationAvailability? LocationAvailability { get; set; }


        // STATS
        public int? Age { get; set; }
        public bool ShowAge { get; set; }

        public decimal? HeightInCm { get; set; }
        public bool ShowHeightInCm { get; set; }

        public decimal? WeightInKg { get; set; }
        public bool ShowWeightInKg { get; set; }

        public BodyType? BodyType { get; set; }
        public bool ShowBodyType { get; set; }

        public bool? IsCircumcised { get; set; }
        public bool ShowIsCircumcised { get; set; }

        public decimal? SizeInCm { get; set; }
        public bool ShowSizeInCm { get; set; }


        // SEXUALITY
        public SexualSpectrum? Spectrum { get; set; }
        public bool ShowSpectrum { get; set; }

        public SexualAttitude? Attitude { get; set; }
        public bool ShowAttitude { get; set; }

        public List<ExpressionStyle> Expressions { get; set; } = [];
        public bool ShowExpressions { get; set; }


        // SCENE
        public HostingStatus? HostingStatus { get; set; }
        public bool ShowHostingStatus { get; set; }

        public PublicPlace? PublicPlace { get; set; }
        public bool ShowPublicPlace { get; set; }

        public List<ExpressionStyle> LookingFor { get; set; } = [];
        public bool ShowLookingFor { get; set; }

        public List<Kink> Kinks { get; set; } = [];
        public bool ShowKinks { get; set; }

        public List<Fetish> Fetishes { get; set; } = [];
        public bool ShowFetishes { get; set; }

        public List<Actions> Actions { get; set; } = [];
        public bool ShowActions { get; set; }

        public List<Interaction> Interactions { get; set; } = [];
        public bool ShowInteractions { get; set; }


        // HEALTH
        public Practice? Practice { get; set; }
        public bool ShowPractice { get; set; }

        public HivStatus? HivStatus { get; set; }
        public bool ShowHivStatus { get; set; }

        public DateTime? HivTestedDate { get; set; }
        public bool ShowHivTestedDate { get; set; }

        public DateTime? StiTestedDate { get; set; }
        public bool ShowStiTestedDate { get; set; }

        public List<ImmunizationStatus> Immunizations { get; set; } = [];
        public bool ShowImmunizations { get; set; }

        public List<DrugAbuse> DrugAbuse { get; set; } = [];
        public bool ShowDrugAbuse { get; set; }

        public List<Carrying> Carrying { get; set; } = [];
        public bool ShowCarrying { get; set; }


        // PHOTOS
        public string GetFirstPhoto => Photos.FirstOrDefault(x => x.Order == 1)?.Url ?? string.Empty;
        public IList<UserPhoto> Photos { get; set; } = [];


        // RELATIONSHIPS
        public virtual IList<BlockedUser> BlockedUsers { get; set; } = [];
        public virtual IList<BlockedUser> BlockedBy { get; set; } = [];
        public virtual IList<FavoriteChat> FavoriteChats { get; set; } = [];
        public virtual IList<FavoriteChat> FavoritedBy { get; set; } = [];

        public virtual IList<Party> Invitations { get; set; } = [];
        public virtual IList<Party> ConfirmedParties { get; set; } = [];
        public virtual IList<Party> OwnedParties { get; set; } = [];
        public virtual IList<VideoCallPurchase> VideoCallPurchases { get; set; } = [];
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Entities\BlockedUser.cs ===
﻿using Snarf.Domain.Base;

namespace Snarf.Domain.Entities
{
    public class BlockedUser : BaseEntity
    {
        public required User Blocker { get; set; }
        public required User Blocked { get; set; }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Entities\FavoriteChat.cs ===
﻿using Snarf.Domain.Base;

namespace Snarf.Domain.Entities
{
    public class FavoriteChat : BaseEntity
    {
        public required User User { get; set; }
        public required User ChatUser { get; set; }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Entities\Party.cs ===
﻿using Snarf.Domain.Base;
using Snarf.Domain.Enum;
using System.ComponentModel.DataAnnotations.Schema;

namespace Snarf.Domain.Entities
{
    public class Party : BaseEntity
    {
        public required string Title { get; set; }
        public string? Description { get; set; }
        public PartyType Type { get; set; }
        public DateTime StartDate { get; set; }
        public int Duration { get; set; }
        public required string Location { get; set; }
        public required string Instructions { get; set; }
        public string? CoverImageUrl { get; set; }
        public double? Latitude { get; set; }
        public double? Longitude { get; set; }

        public required string OwnerId { get; set; }
        public required User Owner { get; set; }

        public virtual IList<User> InvitedUsers { get; set; } = [];
        public virtual IList<User> ConfirmedUsers { get; set; } = [];

        public virtual IList<PartyChatMessage> Messages { get; set; } = [];

        public string? InvitedByHostJson { get; set; }
        [NotMapped]
        public Dictionary<string, bool> InvitedByHostMap
        {
            get
            {
                if (string.IsNullOrEmpty(InvitedByHostJson))
                    return new Dictionary<string, bool>();
                return System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, bool>>(InvitedByHostJson)
                       ?? new Dictionary<string, bool>();
            }
            set
            {
                InvitedByHostJson = System.Text.Json.JsonSerializer.Serialize(value);
            }
        }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Entities\PartyChatMessage.cs ===
﻿using Snarf.Domain.Base;

namespace Snarf.Domain.Entities
{
    public class PartyChatMessage : BaseEntity
    {
        public required string SenderId { get; set; }
        public virtual User? Sender { get; set; }
        public required string Message { get; set; }
        public required Guid PartyId { get; set; }
        public virtual Party? Party { get; set; }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Entities\Place.cs ===
﻿using Snarf.Domain.Base;
using Snarf.Domain.Enum;

namespace Snarf.Domain.Entities
{
    public class Place : BaseEntity
    {
        public required string Title { get; set; }
        public required string Description { get; set; }
        public required double Latitude { get; set; }
        public required double Longitude { get; set; }
        public required string OwnerId { get; set; }
        public virtual User? Owner { get; set; }
        public required string CoverImageUrl { get; set; }
        public required PlaceType Type { get; set; }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Entities\PlaceChatMessage.cs ===
﻿using Snarf.Domain.Base;

namespace Snarf.Domain.Entities
{
    public class PlaceChatMessage : BaseEntity
    {
        public string SenderId { get; set; }
        public virtual User? Sender { get; set; }
        public Guid PlaceId { get; set; }
        public virtual Place? Place { get; set; }
        public required string Message { get; set; }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Entities\PlaceVisitLog.cs ===
﻿using Snarf.Domain.Base;

namespace Snarf.Domain.Entities
{
    public class PlaceVisitLog : BaseEntity
    {
        public required string UserId { get; set; }
        public required Guid PlaceId { get; set; }
        public DateTime EntryTime { get; set; }
        public DateTime? ExitTime { get; set; }

        public double? TotalDurationInMinutes { get; set; }

        public virtual User? User { get; set; }
        public virtual Place? Place { get; set; }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Entities\PrivateChatMessage.cs ===
﻿using Snarf.Domain.Base;

namespace Snarf.Domain.Entities
{
    public class PrivateChatMessage : BaseEntity
    {
        public required User Sender { get; set; }
        public required User Receiver { get; set; }
        public required string Message { get; set; }
        public required bool IsRead { get; set; }

        public Dictionary<string, string>? Reactions { get; set; } = new();
        public Guid? ReplyToMessageId { get; set; }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Entities\PublicChatMessage.cs ===
﻿using Snarf.Domain.Base;

namespace Snarf.Domain.Entities
{
    public class PublicChatMessage : BaseEntity
    {
        public required string SenderId { get; set; }
        public virtual User? Sender { get; set; }
        public required string Message { get; set; }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Entities\UserPhoto.cs ===
﻿using Snarf.Domain.Base;

namespace Snarf.Domain.Entities
{
    public class UserPhoto : BaseEntity
    {
        public string Url { get; set; } = null!;
        public int Order { get; set; }
        public string UserId { get; set; } = null!;
        public User User { get; set; } = null!;
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Entities\VideoCallLog.cs ===
﻿using Snarf.Domain.Base;

namespace Snarf.Domain.Entities
{
    public class VideoCallLog : BaseEntity
    {
        public required string RoomId { get; set; }
        public virtual required User Caller { get; set; }
        public virtual required User Callee { get; set; }
        public required DateTime StartTime { get; set; }
        public DateTime? EndTime { get; set; }
        public int DurationMinutes { get; set; }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Entities\VideoCallPurchase.cs ===
﻿using Snarf.Domain.Base;

namespace Snarf.Domain.Entities
{
    public class VideoCallPurchase : BaseEntity
    {
        public string UserId { get; set; } = null!;
        public User User { get; set; } = null!;

        public int Minutes { get; set; }

        public DateTime PurchaseDate { get; set; }

        public string? SubscriptionId { get; set; }
        public string? Token { get; set; }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\PartyType.cs ===
﻿using System.ComponentModel;

namespace Snarf.Domain.Enum
{
    public enum PartyType
    {
        [Description("Orgia")]
        Orgy,
        [Description("Bomba e Despejo")]
        PumpDump,
        [Description("Masturbação Coletiva")]
        CollectiveMasturbation,
        [Description("Grupo de Bukkake")]
        BukkakeGroup,
        [Description("Grupo Fetiche")]
        FetishGroup,
        [Description("Evento Especial")]
        SpecialEvent
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\PlaceType.cs ===
﻿namespace Snarf.Domain.Enum
{
    public enum PlaceType
    {
        Gym,
        Bathroom,
        BarOrClub,
        CafeOrRestaurant,
        ShowerOrSauna,
        RecurringEvent,
        ArcadeOrTheater,
        HotelOrResort,
        Other,
        TruckStop,
        Park,
        NudismBeach,
        Sauna
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\RoleName.cs ===
﻿namespace Snarf.Domain.Enum
{
    public enum RoleName
    {
        User,
        Admin
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\UserDetails\Actions.cs ===
﻿namespace Snarf.Domain.Enum.UserDetails
{
    public enum Actions
    {
        BallPlay,
        Cuddle,
        Fingering,
        Fisting,
        Fucking,
        Frotting,
        JerkOff,
        Rimming,
        Massage,
        Makeout,
        Oral,
        OralReceiving,
        OralGiving,
        OralSwallow
    }

}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\UserDetails\BodyType.cs ===
﻿namespace Snarf.Domain.Enum.UserDetails
{
    public enum BodyType
    {
        Slim,
        Fit,
        Muscular,
        Average,
        Stocky,
        Chubby,
        Large
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\UserDetails\Carrying.cs ===
﻿namespace Snarf.Domain.Enum.UserDetails
{
    public enum Carrying
    {
        Condoms,
        Lube,
        Naloxone,
        DrugTestStrips,
        Discuss
    }

}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\UserDetails\DrugAbuse.cs ===
﻿namespace Snarf.Domain.Enum.UserDetails
{
    public enum DrugAbuse
    {
        Alcohol,
        Cannabis,
        Tobacco,
        Poppers,
        PnP,
        Other,
        Discuss
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\UserDetails\ExpressionStyle.cs ===
﻿namespace Snarf.Domain.Enum.UserDetails
{
    public enum ExpressionStyle
    {
        Bear,
        Biker,
        Bro,
        CleanCut,
        Corporate,
        Daddy,
        Discreet,
        Femme,
        Gaymer,
        Nerd,
        Goth,
        BoyNextDoor,
        Jock,
        Leather,
        Nudist,
        Otter,
        Poz,
        Punk,
        Pup,
        Rugged,
        Skater,
        Son,
        Sporty,
        Surfer,
        Swinger,
        Trans,
        Trendy,
        Trucker,
        Twink,
        InclusivePlus
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\UserDetails\Fetish.cs ===
﻿namespace Snarf.Domain.Enum.UserDetails
{
    public enum Fetish
    {
        BodyArmpits,
        BodyAss,
        BodyBodyHair,
        BodyBulges,
        BodyCocksHard,
        BodyCocksSoft,
        BodyCocksHung,
        BodyCum,
        BodyFacialHair,
        BodyFeet,
        BodyHands,
        BodyHappyTrail,
        BodyLongHair,
        BodyMuscles,
        BodyMusk,
        BodyNipples,
        BodyPecs,
        BodyPiercings,
        BodyPubesNatural,
        BodyPubesShaved,
        BodyPubesTrimmed,
        BodyScars,
        BodySpit,
        BodyTatoos,
        ClothingBaseballCaps,
        ClothingBoots,
        ClothingDenim,
        ClothingLeather,
        ClothingLingerie,
        ClothingMasks,
        ClothingOnsies,
        ClothingRubber,
        ClothingSagging,
        ClothingSinglets,
        ClothingSocks,
        ClothingSpandexLycra,
        ClothingSpeedos,
        ClothingSportsUniforms,
        ClothingSportsGear,
        ClothingSuits,
        ClothingUniforms,
        ClothingUnderwear,
        ClothingUnderwearBoxers,
        ClothingUnderwearBoxerBriefs,
        ClothingUnderwearBriefs,
        ClothingUnderwearJockstraps,
        ClothingUnderwearMesh,
        ClothingUnderwearNylons,
        ClothingUnderwearPanties,
        ClothingUnderwearUsed,
        ClothingUnderwearTightyWhities
    }

}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\UserDetails\HivStatus.cs ===
﻿namespace Snarf.Domain.Enum.UserDetails
{
    public enum HivStatus
    {
        Negative,
        Prep,
        Positive,
        Undetectable,
        Unknown,
        Private
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\UserDetails\HostingStatus.cs ===
﻿namespace Snarf.Domain.Enum.UserDetails
{
    public enum HostingStatus
    {
        Host,
        Travel
    }


}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\UserDetails\ImmunizationStatus.cs ===
﻿namespace Snarf.Domain.Enum.UserDetails
{
    public enum ImmunizationStatus
    {
        Covid1,
        Monkeypox1,
        DoxyPep,
        Condoms
    }

}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\UserDetails\Interaction.cs ===
﻿namespace Snarf.Domain.Enum.UserDetails
{
    public enum Interaction
    {
        Anonymous,
        Blindfolded,
        Bukkake,
        CumAndGo,
        DirtyTalk,
        DoorOpen,
        DropPants,
        Edging,
        EyeContact,
        Flip,
        Gloryhole,
        Gooning,
        NoRecip,
        MildToWild,
        Mutual,
        PumpAndDump,
        Rough,
        Understall,
        Vanilla,
        WatchOnly,
        Worship
    }

}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\UserDetails\Kink.cs ===
﻿namespace Snarf.Domain.Enum.UserDetails
{
    public enum Kink
    {
        Bdsm,
        Bondage,
        Chastity,
        Cmnm,
        CumPlay,
        Edging,
        Enimas,
        Exhibitionism,
        Facials,
        Fisting,
        Freeballing,
        Fleshlights,
        GagsTape,
        GasMasks,
        Gloryholes,
        Groups,
        Humiliation,
        MirrorPlay,
        PigPlay,
        Porn,
        SexToys,
        SexDolls,
        Shaving,
        Sounding,
        Spanking,
        Voyeurism,
        Watersports,
        Wedgies,
        Whipping,
        AgePlay,
        Classrooms,
        CostumePlay,
        DeliveryGuy,
        DoctorPatient,
        FirstTime,
        Furry,
        HandyMan,
        PublicLockerRooms,
        PublicNudity,
        PublicRestrooms,
        PublicShowers,
        PupPlay,
        SlaveMaster,
        SleepPlay,
        SlumberParty,
        Superhero
    }

}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\UserDetails\LocationAvailability.cs ===
﻿namespace Snarf.Domain.Enum.UserDetails
{
    public enum LocationAvailability
    {
        None,
        HasPlace,
        CanHostGroup,
        GloryHole,
        HotelRoom,
        InCar,
        LookingLivePlay
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\UserDetails\Practice.cs ===
﻿namespace Snarf.Domain.Enum.UserDetails
{
    public enum Practice
    {
        Bareback,
        BarebackPrep,
        Safe,
        SaferOnly,
        SafeOrBareback,
        LetsTalk
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\UserDetails\PublicPlace.cs ===
﻿namespace Snarf.Domain.Enum.UserDetails
{
    public enum PublicPlace
    {
        Arcade,
        Bar,
        Bathhouse,
        Beach,
        Car,
        Event,
        Gym,
        Outdoor,
        Park,
        Restroom,
        Sauna,
        Truckstop
    }

}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\UserDetails\SexualAttitude.cs ===
﻿namespace Snarf.Domain.Enum.UserDetails
{
    public enum SexualAttitude
    {
        NoPenetration,
        SubmissiveBottom,
        Bottom,
        GreedyBottom,
        VersatileBottom,
        Versatile,
        VersatileTop,
        TopBottom,
        Top,
        DominantTop
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Enum\UserDetails\SexualSpectrum.cs ===
﻿namespace Snarf.Domain.Enum.UserDetails
{
    public enum SexualSpectrum
    {
        Straight,
        StraightCurious,
        BiCurious,
        Bisexual,
        Gay
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Domain\Shared\BasicEntity.cs ===
﻿using Snarf.Domain.Base;

namespace Snarf.Domain.Shared
{
    public abstract class BasicEntity : BaseEntity
    {
        public required string Name { get; set; }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DTO\AddExtraMinutesDTO.cs ===
using System.ComponentModel.DataAnnotations;

namespace Snarf.DTO
{
    public class AddExtraMinutesDTO
    {
        public Guid UserId { get; set; }
        [Required]
        public required string SubscriptionId { get; set; }
        [Required]
        public required string Token { get; set; }
        [Required]
        public required int Minutes { get; set; }
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DTO\ChangeEmailDTO.cs ===
using System.ComponentModel.DataAnnotations;

namespace Snarf.DTO
{
    public class ChangeEmailDTO
    {
        [Required]
        public required string NewEmail { get; set; }
        [Required]
        public required string CurrentPassword { get; set; }
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DTO\ChangePasswordDTO.cs ===
using System.ComponentModel.DataAnnotations;

namespace Snarf.DTO
{
    public class ChangePasswordDTO
    {
        [Required]
        public required string OldPassword { get; set; }
        [Required]
        public required string NewPassword { get; set; }
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DTO\PartyDTO.cs ===
﻿using Snarf.Domain.Enum;
using System.ComponentModel.DataAnnotations;

namespace Snarf.DTO
{
    public class PartyDTO
    {
        [Required]
        public required string Title { get; set; }
        [Required]
        public required string Description { get; set; }
        [Required]
        public required DateTime StartDate { get; set; }
        [Required]
        public required int Duration { get; set; }
        [Required]
        public required PartyType Type { get; set; }
        [Required]
        public required string Location { get; set; }
        [Required]
        public required string Instructions { get; set; }
        [Required]
        public required string CoverImage { get; set; }
        [Required]
        public required double LastLatitude { get; set; }
        [Required]
        public required double LastLongitude { get; set; }
        public string? UserId { get; set; }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DTO\PlaceDTO.cs ===
﻿using Snarf.Domain.Enum;
using System.ComponentModel.DataAnnotations;

namespace Snarf.DTO
{
    public class PlaceDTO
    {
        [Required]
        public required string Title { get; set; }
        [Required]
        public required string Description { get; set; }
        [Required]
        public required double Latitude { get; set; }
        [Required]
        public required double Longitude { get; set; }
        [Required]
        public required string CoverImage { get; set; }
        [Required]
        public required PlaceType Type { get; set; }
        public string? UserId { get; set; }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DTO\SignalREventType.cs ===
﻿namespace Snarf.DTO
{
    public enum SignalREventType
    {
        UserConnected,
        UserDisconnected,

        MapUpdateLocation,
        MapReceiveLocation,

        PublicChatSendMessage,
        PublicChatReceiveMessage,
        PublicChatDeleteMessage,
        PublicChatReceiveMessageDeleted,
        PublicChatGetPreviousMessages,

        PrivateChatSendMessage,
        PrivateChatReceiveMessage,
        PrivateChatGetRecentChats,
        PrivateChatReceiveRecentChats,
        PrivateChatGetPreviousMessages,
        PrivateChatReceivePreviousMessages,
        PrivateChatMarkMessagesAsRead,
        PrivateChatDeleteMessage,
        PrivateChatDeleteChat,
        PrivateChatSendImage,
        PrivateChatSendVideo,
        PrivateChatSendAudio,
        PrivateChatReceiveMessageDeleted,

        PrivateChatGetFavorites,
        PrivateChatReceiveFavorites,
        PrivateChatAddFavorite,
        PrivateChatRemoveFavorite,

        PrivateChatReactToMessage,
        PrivateChatReceiveReaction,
        PrivateChatReplyToMessage,
        PrivateChatReceiveReply,

        VideoCallInitiate,
        VideoCallIncoming,
        VideoCallAccept,
        VideoCallReject,
        VideoCallCanceled,
        VideoCallEnd,

        PartyChatSendMessage,
        PartyChatReceiveMessage,
        PartyChatDeleteMessage,
        PartyChatReceiveMessageDeleted,
        PartyChatGetPreviousMessages,
        PartyChatSendImage,

        PlaceChatSendMessage,
        PlaceChatDeleteMessage,
        PlaceChatGetPreviousMessages,
        PlaceChatReceiveMessage,
        PlaceChatReceiveMessageDeleted
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DTO\SignalRMessage.cs ===
﻿using System.Text.Json;

namespace Snarf.DTO
{
    public class SignalRMessage
    {
        public string Type { get; set; }
        public JsonElement Data { get; set; }

        public static string Serialize<T>(SignalREventType type, T data)
        {
            return JsonSerializer.Serialize(new
            {
                Type = type.ToString(),
                Data = data
            });
        }

        public static SignalRMessage Deserialize(string json)
        {
            return JsonSerializer.Deserialize<SignalRMessage>(json)!;
        }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DTO\UserDTO.cs ===
using Snarf.Domain.Enum;
using Snarf.Domain.Enum.UserDetails;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;

namespace Snarf.DTO
{
    public class UserDTO
    {
        [Required]
        [EmailAddress]
        public required string Email { get; set; }

        [Required]
        public required string Name { get; set; }

        public string? Password { get; set; }

        public List<string>? Images { get; set; }
        public string? Description { get; set; }

        public double? BirthLatitude { get; set; }
        public double? BirthLongitude { get; set; }
        public LocationAvailability? LocationAvailability { get; set; }

        // STATS
        public int? Age { get; set; }
        public bool? ShowAge { get; set; }

        public decimal? Height { get; set; }
        public bool? ShowHeightInCm { get; set; }

        public decimal? Weight { get; set; }
        public bool? ShowWeightInKg { get; set; }

        public BodyType? BodyType { get; set; }
        public bool? ShowBodyType { get; set; }

        public bool? IsCircumcised { get; set; }
        public bool? ShowIsCircumcised { get; set; }

        public decimal? CircumferenceCm { get; set; }
        public bool? ShowSizeInCm { get; set; }

        // SEXUALITY
        public SexualSpectrum? Spectrum { get; set; }
        public bool? ShowSpectrum { get; set; }

        public SexualAttitude? Attitude { get; set; }
        public bool? ShowAttitude { get; set; }

        public List<ExpressionStyle>? Expressions { get; set; }
        public bool? ShowExpressions { get; set; }

        // SCENE
        public HostingStatus? HostingStatus { get; set; }
        public bool? ShowHostingStatus { get; set; }

        public PublicPlace? PublicPlace { get; set; }
        public bool? ShowPublicPlace { get; set; }

        public List<ExpressionStyle>? LookingFor { get; set; }
        public bool? ShowLookingFor { get; set; }

        public List<Kink>? Kinks { get; set; }
        public bool? ShowKinks { get; set; }

        public List<Fetish>? Fetishes { get; set; }
        public bool? ShowFetishes { get; set; }

        public List<Actions>? Actions { get; set; }
        public bool? ShowActions { get; set; }

        public List<Interaction>? Interactions { get; set; }
        public bool? ShowInteractions { get; set; }

        // HEALTH
        public Practice? Practice { get; set; }
        public bool? ShowPractice { get; set; }

        public HivStatus? HivStatus { get; set; }
        public bool? ShowHivStatus { get; set; }

        public DateTime? HivTestedDate { get; set; }
        public bool? ShowHivTestedDate { get; set; }

        public DateTime? StiTestedDate { get; set; }
        public bool? ShowStiTestedDate { get; set; }

        public List<ImmunizationStatus>? Immunizations { get; set; }
        public bool? ShowImmunizations { get; set; }

        public List<DrugAbuse>? DrugAbuse { get; set; }
        public bool? ShowDrugAbuse { get; set; }

        public List<Carrying>? Carrying { get; set; }
        public bool? ShowCarrying { get; set; }
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DTO\UserEmailDTO.cs ===
using System.ComponentModel.DataAnnotations;

namespace Snarf.DTO
{
    public class UserEmailDTO
    {
        [Required]
        [EmailAddress]
        public required string Email { get; set; }
        [Required]
        public required string Code { get; set; }
        [Required]
        public required string Password { get; set; }
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DTO\UserLoginDTO.cs ===
using System.ComponentModel.DataAnnotations;

namespace Snarf.DTO
{
    public class UserLoginDTO
    {
        [Required]
        [EmailAddress]
        public required string Email { get; set; }
        [Required]
        public required string Password { get; set; }
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DTO\Base\BasicDTO.cs ===
using System.ComponentModel.DataAnnotations;

namespace Snarf.DTO.Base
{
    public class BasicDTO
    {
        [Required]
        public required string Name { get; set; }
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.DTO\Base\ResponseDTO.cs ===
﻿using Serilog;
using System.Diagnostics;

namespace Snarf.DTO.Base
{
    public class ResponseDTO
    {
        public int Code { get; set; } = 200;
        public string Message { get; set; } = "Operação concluída!";
        public DateTime Date { get; } = DateTime.UtcNow;
        public object? Object { get; set; }
        public object? Error { get; set; }
        public Stopwatch Elapsed { get; } = Stopwatch.StartNew();

        public void SetError(Exception ex)
        {
            Code = 500;
            Message = "Ocorreu um erro inesperado!";
            Error = new { message = ex.Message, innerMessage = ex.InnerException?.Message, stackTrace = ex.StackTrace };
            Log.Error(ex, Message);
        }

        public void SetBadInput(string message)
        {
            Code = 400;
            Message = $"Verifique os registros enviados! Detalhes: {message}";
            Log.Warning(Message);
        }

        public void SetUnauthorized(string message)
        {
            Code = 401;
            Message = message;
            Log.Warning(Message);
        }

        public void SetForbidden(string message)
        {
            Code = 403;
            Message = message;
            Log.Warning(Message);
        }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Base\IBaseRepository.cs ===
﻿using Microsoft.EntityFrameworkCore.ChangeTracking;

namespace Snarf.Infrastructure.Base
{
    public interface IBaseRepository<T>
    {
        IQueryable<T> GetEntities();
        IQueryable<T> GetTrackedEntities();
        Task<IEnumerable<T>> GetList();
        void Insert(T entity);
        void InsertRange(IEnumerable<T> entity);
        Task InsertAsync(T entity);
        void Update(T entity);
        void UpdateRange(T[] entity);
        void Delete(T entity);
        void DeleteRange(T[] entity);
        bool SaveChanges();
        IEnumerable<EntityEntry> GetChanges();
        void SeeChanges();
        void ClearChanges();
        Task<bool> SaveChangesAsync();
        Task<List<T>> GetListAsync();
        void Attach(T entity);
        void Detach(T entity);
        void AttachRange(IEnumerable<T> entity);
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Base\IBaseService.cs ===
﻿using Snarf.DTO.Base;

namespace Snarf.Infrastructure.Base
{
    public interface IBaseService<T>
    {
        Task<ResponseDTO> Create(T objectDTO);
        Task<ResponseDTO> Update(Guid id, T objectDTO);
        Task<ResponseDTO> Remove(Guid id);
        Task<ResponseDTO> GetList();
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Repository\IBlockedUserRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Base;

namespace Snarf.Infrastructure.Repository
{
    public interface IBlockedUserRepository : IBaseRepository<BlockedUser>
    {
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Repository\IFavoriteChatRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Base;

namespace Snarf.Infrastructure.Repository
{
    public interface IFavoriteChatRepository : IBaseRepository<FavoriteChat>
    {
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Repository\IPartyChatMessageRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Base;

namespace Snarf.Infrastructure.Repository
{
    public interface IPartyChatMessageRepository : IBaseRepository<PartyChatMessage>
    {
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Repository\IPartyRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Base;

namespace Snarf.Infrastructure.Repository
{
    public interface IPartyRepository : IBaseRepository<Party>
    {
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Repository\IPlaceChatMessageRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Base;

namespace Snarf.Infrastructure.Repository
{
    public interface IPlaceChatMessageRepository : IBaseRepository<PlaceChatMessage>
    {
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Repository\IPlaceRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Base;

namespace Snarf.Infrastructure.Repository
{
    public interface IPlaceRepository : IBaseRepository<Place>
    {
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Repository\IPlaceVisitLogRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Base;

namespace Snarf.Infrastructure.Repository
{
    public interface IPlaceVisitLogRepository : IBaseRepository<PlaceVisitLog>
    {
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Repository\IPrivateChatMessageRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Base;

namespace Snarf.Infrastructure.Repository
{
    public interface IPrivateChatMessageRepository : IBaseRepository<PrivateChatMessage>
    {
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Repository\IPublicChatMessageRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Base;

namespace Snarf.Infrastructure.Repository
{
    public interface IPublicChatMessageRepository : IBaseRepository<PublicChatMessage>
    {
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Repository\IUserRepository.cs ===
﻿using Snarf.Domain.Base;
using Snarf.Infrastructure.Base;

namespace Snarf.Infrastructure.Repository
{
    public interface IUserRepository : IBaseRepository<User>
    {
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Repository\IVideoCallLogRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Base;

namespace Snarf.Infrastructure.Repository
{
    public interface IVideoCallLogRepository : IBaseRepository<VideoCallLog>
    {
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Repository\IVideoCallPurchaseRepository.cs ===
﻿using Snarf.Domain.Entities;
using Snarf.Infrastructure.Base;

namespace Snarf.Infrastructure.Repository
{
    public interface IVideoCallPurchaseRepository : IBaseRepository<VideoCallPurchase>
    {
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Service\IAccountService.cs ===
using Snarf.DTO;
using Snarf.DTO.Base;

namespace Snarf.Infrastructure.Service
{
    public interface IAccountService
    {
        Task<ResponseDTO> Login(UserLoginDTO userLoginDTO);
        Task<ResponseDTO> CreateUser(UserDTO userDTO);
        Task<ResponseDTO> ResetPassword(UserEmailDTO userEmailDTO);
        Task<ResponseDTO> RequestResetPassword(string email);
        Task<ResponseDTO> GetUserInfo(Guid id, bool showSensitiveInfo);
        Task<ResponseDTO> UpdateUser(Guid id, UserDTO userDTO);
        Task<ResponseDTO> RemoveUser(Guid id);
        Task<ResponseDTO> AddExtraMinutes(AddExtraMinutesDTO addExtraMinutesDTO);
        Task<ResponseDTO> BlockUser(Guid blockerUserId, Guid blockedUserId);
        Task<ResponseDTO> UnblockUser(Guid blockerUserId, Guid blockedUserId);
        Task<ResponseDTO> ReportUserPublicMessage(Guid messageId);
        Task<ResponseDTO> ReportUser(Guid userId);
        Task<ResponseDTO> ChangeEmail(Guid userId, string newEmail, string currentPassword);
        Task<ResponseDTO> ChangePassword(Guid userId, string oldPassword, string newPassword);
        Task<ResponseDTO> GetFirstMessageToday(Guid userid);
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Service\IEmailService.cs ===
namespace Snarf.Infrastructure.Service
{
    public interface IEmailService
    {
        string BuildReportedMessageText(string message, DateTime messageDate, string userName, string userEmail);
        string BuildReportedUser(string userName, string userEmail);
        string BuildResetPasswordText(string email, string code);
        string BuildRemovePlaceText(string placeTitle, Guid placeId, string ownerName, string ownerEmail);
        Task SendEmail(string title, string body, string recipient);
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Service\IPartyService.cs ===
﻿using Snarf.DTO;
using Snarf.DTO.Base;
using Snarf.Infrastructure.Base;

namespace Snarf.Infrastructure.Service
{
    public interface IPartyService : IBaseService<PartyDTO>
    {
        Task<ResponseDTO> InviteUsers(Guid id, List<string> userIds, string whoIsCallingId);
        Task<ResponseDTO> GetAll(Guid userId);
        Task<ResponseDTO> RequestParticipation(Guid partyId, string userId);
        Task<ResponseDTO> ConfirmUser(Guid partyId, string whoIsCallingId, string targetUserId);
        Task<ResponseDTO> DeclineUser(Guid partyId, string whoIsCallingId, string targetUserId);
        Task<ResponseDTO> GetAllParticipants(Guid id, Guid userId);
        Task<ResponseDTO> GetById(Guid id, Guid userId);
        Task<ResponseDTO> Delete(Guid id, Guid userId);
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Service\IPlaceService.cs ===
﻿using Snarf.DTO;
using Snarf.DTO.Base;
using Snarf.Infrastructure.Base;

namespace Snarf.Infrastructure.Service
{
    public interface IPlaceService : IBaseService<PlaceDTO>
    {
        Task<ResponseDTO> Update(Guid id, PlaceDTO updateDTO, Guid userId);
        Task<ResponseDTO> Delete(Guid id, Guid userId);
        Task<ResponseDTO> GetById(Guid id);
        Task<ResponseDTO> GetVisitorsAndStats(Guid id);
        Task<ResponseDTO> GetAll();
        Task<ResponseDTO> SignalToRemove(Guid id, Guid userId);
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Infrastructure\Service\ITokenService.cs ===
using Snarf.Domain.Base;

namespace Snarf.Infrastructure.Service
{
    public interface ITokenService
    {
        Task<string> CreateToken(User userDTO);
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Persistence\SnarfWebContext.cs ===
﻿using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore;
using Snarf.Domain.Base;
using Snarf.Domain.Entities;

namespace Snarf.Persistence
{
    public class SnarfContext(DbContextOptions<SnarfContext> options) : IdentityDbContext<User>(options)
    {
        public DbSet<PrivateChatMessage> PrivateChatMessages { get; set; }
        public DbSet<PublicChatMessage> PublicChatMessages { get; set; }
        public DbSet<FavoriteChat> FavoriteChats { get; set; }
        public DbSet<BlockedUser> BlockedUsers { get; set; }
        public DbSet<VideoCallPurchase> VideoCallPurchases { get; set; }
        public DbSet<VideoCallLog> VideoCallLogs { get; set; }
        public DbSet<Party> Parties { get; set; }
        public DbSet<PartyChatMessage> PartyChatMessages { get; set; }
        public DbSet<Place> Places { get; set; }
        public DbSet<PlaceChatMessage> PlaceChatMessages { get; set; }
        public DbSet<PlaceVisitLog> PlaceVisitLogs { get; set; }
        public DbSet<UserPhoto> UserPhotos { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.Entity<User>()
                .HasMany(u => u.Photos)
                 .WithOne(p => p.User)
                 .HasForeignKey(p => p.UserId);

            modelBuilder.Entity<UserPhoto>(x =>
            {
                x.HasIndex(x => new { x.UserId, x.Order }).IsUnique();
            });

            modelBuilder.Entity<BlockedUser>()
                .HasOne(b => b.Blocker)
                .WithMany(u => u.BlockedUsers);

            modelBuilder.Entity<BlockedUser>()
                .HasOne(b => b.Blocked)
                .WithMany(u => u.BlockedBy);

            modelBuilder.Entity<FavoriteChat>()
                .HasOne(b => b.User)
                .WithMany(u => u.FavoriteChats);

            modelBuilder.Entity<FavoriteChat>()
                .HasOne(b => b.ChatUser)
                .WithMany(u => u.FavoritedBy);

            modelBuilder.Entity<VideoCallPurchase>()
                .HasOne(x => x.User)
                .WithMany(u => u.VideoCallPurchases)
                .HasForeignKey(x => x.UserId);

            modelBuilder.Entity<Party>()
                .HasOne(p => p.Owner)
                .WithMany(u => u.OwnedParties)
                .HasForeignKey(p => p.OwnerId);

            modelBuilder.Entity<Party>()
                .HasMany(p => p.InvitedUsers)
                .WithMany(u => u.Invitations)
                .UsingEntity<Dictionary<string, object>>(
                    "PartyInvitedUsers",
                    j => j.HasOne<User>().WithMany().HasForeignKey("UserId"),
                    j => j.HasOne<Party>().WithMany().HasForeignKey("PartyId")
                );

            modelBuilder.Entity<Party>()
                .HasMany(p => p.ConfirmedUsers)
                .WithMany(u => u.ConfirmedParties)
                .UsingEntity<Dictionary<string, object>>(
                    "PartyConfirmedUsers",
                    j => j.HasOne<User>().WithMany().HasForeignKey("UserId"),
                    j => j.HasOne<Party>().WithMany().HasForeignKey("PartyId")
                );
        }
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Service\AccountService.cs ===
using Hangfire;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using Serilog;
using Snarf.Domain.Base;
using Snarf.Domain.Entities;
using Snarf.Domain.Enum;
using Snarf.Domain.Enum.UserDetails;
using Snarf.DTO;
using Snarf.DTO.Base;
using Snarf.Infrastructure.Repository;
using Snarf.Infrastructure.Service;

namespace Snarf.Service
{
    public class AccountService(UserManager<User> userManager,
                                SignInManager<User> signInManager,
                                IEmailService emailService,
                                IUserRepository userRepository,
                                ITokenService tokenService,
                                IPrivateChatMessageRepository privateChatMessageRepository,
                                IPublicChatMessageRepository publicChatMessageRepository,
                                IBlockedUserRepository blockUserRepository,
                                IVideoCallLogRepository videoCallLogRepository,
                                IVideoCallPurchaseRepository videoCallPurchaseRepository,
                                S3Service s3Service) : IAccountService
    {
        private async Task<SignInResult> CheckUserPassword(User user, UserLoginDTO userLoginDTO)
        {
            try
            {
                return await signInManager.CheckPasswordSignInAsync(user, userLoginDTO.Password, false);
            }
            catch (Exception ex)
            {
                throw new Exception($"Erro ao verificar senha do usuário. Erro: {ex.Message}");
            }
        }

        private async Task<User?> GetUserByEmail(string email)
        {
            try
            {
                return await userRepository.GetEntities().FirstOrDefaultAsync(x => x.NormalizedEmail == email.ToUpper());
            }
            catch (Exception ex)
            {
                throw new Exception($"Erro ao obter o usuário. Erro: {ex.Message}");
            }
        }

        public async Task<ResponseDTO> Login(UserLoginDTO userDTO)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var user = await GetUserByEmail(userDTO.Email);

                if (user == null)
                {
                    responseDTO.SetUnauthorized("Não autenticado! Verifique o email e a senha inserida!");
                    return responseDTO;
                }

                var password = await CheckUserPassword(user, userDTO);
                if (!password.Succeeded)
                {
                    responseDTO.SetUnauthorized("Não autenticado! Verifique o email e a senha inserida!");
                    return responseDTO;
                }

                responseDTO.Object = new
                {
                    userName = user.UserName,
                    role = user.Role.ToString(),
                    name = user.Name,
                    email = user.Email,
                    token = await tokenService.CreateToken(user)
                };
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }

            return responseDTO;
        }

        public async Task<ResponseDTO> GetUserInfo(Guid id, bool showSensitiveInfo)
        {
            var responseDTO = new ResponseDTO();
            try
            {
                var startOfMonth = new DateTime(DateTime.UtcNow.Year, DateTime.UtcNow.Month, 1);

                var usedMinutes = 0;
                var purchasedMinutes = 0;
                var totalMonthlyLimit = 360;
                var isVideoCallLimitReached = false;

                if (showSensitiveInfo)
                {
                    usedMinutes = await videoCallLogRepository.GetEntities()
                        .Where(x =>
                            (x.Caller.Id == id.ToString() || x.Callee.Id == id.ToString()) &&
                            x.StartTime >= startOfMonth &&
                            x.EndTime != null)
                        .SumAsync(x => x.DurationMinutes);

                    purchasedMinutes = await videoCallPurchaseRepository.GetEntities()
                        .Where(p => p.UserId == id.ToString() && p.PurchaseDate >= startOfMonth)
                        .SumAsync(p => p.Minutes);

                    totalMonthlyLimit = 360 + purchasedMinutes;
                    isVideoCallLimitReached = usedMinutes >= totalMonthlyLimit;
                }

                var data = await userRepository.GetEntities()
                    .Include(x => x.Photos)
                    .Select(x => new
                    {
                        x.Id,
                        x.Email,
                        x.Name,
                        LastActivity = x.LastActivity.GetValueOrDefault().ToUniversalTime(),
                        x.LastLatitude,
                        x.LastLongitude,
                        x.GetFirstPhoto,

                        Description = showSensitiveInfo ? x.Description : null,
                        BirthLatitude = showSensitiveInfo ? x.BirthLatitude : null,
                        BirthLongitude = showSensitiveInfo ? x.BirthLongitude : null,
                        LocationAvailability = showSensitiveInfo ? x.LocationAvailability : null,

                        Age = (showSensitiveInfo || x.ShowAge) ? x.Age : null,
                        HeightInCm = (showSensitiveInfo || x.ShowHeightInCm) ? x.HeightInCm : null,
                        WeightInKg = (showSensitiveInfo || x.ShowWeightInKg) ? x.WeightInKg : null,
                        BodyType = (showSensitiveInfo || x.ShowBodyType) ? x.BodyType : null,
                        IsCircumcised = (showSensitiveInfo || x.ShowIsCircumcised) ? x.IsCircumcised : null,
                        SizeInCm = (showSensitiveInfo || x.ShowSizeInCm) ? x.SizeInCm : null,

                        Spectrum = (showSensitiveInfo || x.ShowSpectrum) ? x.Spectrum : null,
                        Attitude = (showSensitiveInfo || x.ShowAttitude) ? x.Attitude : null,
                        Expressions = (showSensitiveInfo || x.ShowExpressions) ? x.Expressions : null,

                        HostingStatus = (showSensitiveInfo || x.ShowHostingStatus) ? x.HostingStatus : null,
                        PublicPlace = (showSensitiveInfo || x.ShowPublicPlace) ? x.PublicPlace : null,
                        LookingFor = (showSensitiveInfo || x.ShowLookingFor) ? x.LookingFor : null,
                        Kinks = (showSensitiveInfo || x.ShowKinks) ? x.Kinks : null,
                        Fetishes = (showSensitiveInfo || x.ShowFetishes) ? x.Fetishes : null,
                        Actions = (showSensitiveInfo || x.ShowActions) ? x.Actions : null,
                        Interactions = (showSensitiveInfo || x.ShowInteractions) ? x.Interactions : null,

                        Practice = (showSensitiveInfo || x.ShowPractice) ? x.Practice : null,
                        HivStatus = (showSensitiveInfo || x.ShowHivStatus) ? x.HivStatus : null,
                        HivTestedDate = (showSensitiveInfo || x.ShowHivTestedDate) ? x.HivTestedDate : null,
                        StiTestedDate = (showSensitiveInfo || x.ShowStiTestedDate) ? x.StiTestedDate : null,
                        Immunizations = (showSensitiveInfo || x.ShowImmunizations) ? x.Immunizations : null,
                        DrugAbuse = (showSensitiveInfo || x.ShowDrugAbuse) ? x.DrugAbuse : null,
                        Carrying = (showSensitiveInfo || x.ShowCarrying) ? x.Carrying : null,

                        BlockedUsers = showSensitiveInfo
                                                ? x.BlockedUsers
                                                     .Select(b => new { b.Blocked.Id, b.Blocked.Name, b.Blocked.GetFirstPhoto })
                                                     .ToList()
                                                : null,
                        BlockedByCount = showSensitiveInfo ? x.BlockedBy.Count : 0,
                        FavoriteChats = showSensitiveInfo
                                                ? x.FavoriteChats
                                                     .Select(f => new { f.ChatUser.Name, f.ChatUser.GetFirstPhoto })
                                                     .ToList()
                                                : null,
                        FavoritedByCount = showSensitiveInfo ? x.FavoritedBy.Count : 0,

                        ExtraVideoCallMinutes = showSensitiveInfo ? purchasedMinutes : 0,
                        UsedVideoCallMinutes = showSensitiveInfo ? usedMinutes : 0,
                        MonthlyVideoCallLimit = showSensitiveInfo ? totalMonthlyLimit : 0,
                        IsVideoCallLimitReached = showSensitiveInfo ? isVideoCallLimitReached : false
                    })
                    .FirstOrDefaultAsync(x => x.Id == id.ToString());

                if (data == null)
                {
                    responseDTO.SetBadInput($"Usuário não encontrado com este id: {id}!");
                    return responseDTO;
                }

                responseDTO.Object = data;
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }

            return responseDTO;
        }

        public async Task<ResponseDTO> CreateUser(UserDTO userDTO)
        {
            var responseDTO = new ResponseDTO();
            try
            {
                if (string.IsNullOrEmpty(userDTO.Password))
                {
                    responseDTO.SetBadInput("A senha é obrigatória para criar um usuário");
                    return responseDTO;
                }

                if (await userManager.FindByEmailAsync(userDTO.Email) != null)
                {
                    responseDTO.SetBadInput($"Já existe um usuário cadastrado com este email: {userDTO.Email}!");
                    return responseDTO;
                }

                var userEntity = new User
                {
                    Name = userDTO.Name,
                    Email = userDTO.Email,
                    NormalizedEmail = userDTO.Email.ToUpper(),
                    NormalizedUserName = userDTO.Email.ToUpper(),
                    Role = RoleName.User,

                    Description = userDTO.Description,
                    BirthLatitude = userDTO.BirthLatitude,
                    BirthLongitude = userDTO.BirthLongitude,
                    LocationAvailability = userDTO.LocationAvailability,

                    Age = userDTO.Age,
                    ShowAge = userDTO.ShowAge ?? false,
                    HeightInCm = userDTO.Height,
                    ShowHeightInCm = userDTO.ShowHeightInCm ?? false,
                    WeightInKg = userDTO.Weight,
                    ShowWeightInKg = userDTO.ShowWeightInKg ?? false,
                    BodyType = userDTO.BodyType,
                    ShowBodyType = userDTO.ShowBodyType ?? false,

                    IsCircumcised = userDTO.IsCircumcised,
                    ShowIsCircumcised = userDTO.ShowIsCircumcised ?? false,
                    SizeInCm = userDTO.CircumferenceCm,
                    ShowSizeInCm = userDTO.ShowSizeInCm ?? false,

                    Spectrum = userDTO.Spectrum,
                    ShowSpectrum = userDTO.ShowSpectrum ?? false,
                    Attitude = userDTO.Attitude,
                    ShowAttitude = userDTO.ShowAttitude ?? false,
                    Expressions = userDTO.Expressions ?? new List<ExpressionStyle>(),
                    ShowExpressions = userDTO.ShowExpressions ?? false,

                    HostingStatus = userDTO.HostingStatus,
                    ShowHostingStatus = userDTO.ShowHostingStatus ?? false,
                    PublicPlace = userDTO.PublicPlace,
                    ShowPublicPlace = userDTO.ShowPublicPlace ?? false,
                    LookingFor = userDTO.LookingFor ?? new List<ExpressionStyle>(),
                    ShowLookingFor = userDTO.ShowLookingFor ?? false,

                    Kinks = userDTO.Kinks ?? new List<Kink>(),
                    ShowKinks = userDTO.ShowKinks ?? false,
                    Fetishes = userDTO.Fetishes ?? new List<Fetish>(),
                    ShowFetishes = userDTO.ShowFetishes ?? false,
                    Actions = userDTO.Actions ?? new List<Actions>(),
                    ShowActions = userDTO.ShowActions ?? false,
                    Interactions = userDTO.Interactions ?? new List<Interaction>(),
                    ShowInteractions = userDTO.ShowInteractions ?? false,

                    Practice = userDTO.Practice,
                    ShowPractice = userDTO.ShowPractice ?? false,
                    HivStatus = userDTO.HivStatus,
                    ShowHivStatus = userDTO.ShowHivStatus ?? false,
                    HivTestedDate = userDTO.HivTestedDate,
                    ShowHivTestedDate = userDTO.ShowHivTestedDate ?? false,
                    StiTestedDate = userDTO.StiTestedDate,
                    ShowStiTestedDate = userDTO.ShowStiTestedDate ?? false,

                    Immunizations = userDTO.Immunizations ?? new List<ImmunizationStatus>(),
                    ShowImmunizations = userDTO.ShowImmunizations ?? false,
                    DrugAbuse = userDTO.DrugAbuse ?? new List<DrugAbuse>(),
                    ShowDrugAbuse = userDTO.ShowDrugAbuse ?? false,
                    Carrying = userDTO.Carrying ?? new List<Carrying>(),
                    ShowCarrying = userDTO.ShowCarrying ?? false
                };

                userEntity.PasswordHash = userManager.PasswordHasher.HashPassword(userEntity, userDTO.Password);

                if (userDTO.Images != null && userDTO.Images.Any())
                {
                    int ordem = 1;
                    foreach (var base64 in userDTO.Images.Take(4))
                    {
                        var bytes = Convert.FromBase64String(base64);
                        using var stream = new MemoryStream(bytes);
                        var url = await s3Service.UploadFileAsync(
                            $"userImages/{Guid.NewGuid()}",
                            stream,
                            "image/jpeg"
                        );

                        userEntity.Photos.Add(new UserPhoto
                        {
                            Id = Guid.NewGuid(),
                            Url = url,
                            Order = ordem++
                        });
                    }
                }

                await userRepository.InsertAsync(userEntity);
                await userRepository.SaveChangesAsync();
                await userManager.UpdateSecurityStampAsync(userEntity);

                responseDTO.Object = userDTO;
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }

            return responseDTO;
        }

        public async Task<ResponseDTO> UpdateUser(Guid id, UserDTO userDTO)
        {
            var responseDTO = new ResponseDTO();
            try
            {
                var userEntity = await userRepository
                    .GetTrackedEntities()
                    .Include(u => u.Photos)
                    .FirstOrDefaultAsync(x => x.Id == id.ToString());

                if (userEntity == null)
                {
                    responseDTO.SetBadInput($"Usuário não encontrado com este id: {id}!");
                    return responseDTO;
                }

                userEntity.Name = userDTO.Name;
                if (!string.IsNullOrEmpty(userDTO.Password))
                {
                    userEntity.PasswordHash = userManager.PasswordHasher.HashPassword(userEntity, userDTO.Password);
                    await userManager.UpdateSecurityStampAsync(userEntity);
                }

                userEntity.Description = userDTO.Description;
                userEntity.BirthLatitude = userDTO.BirthLatitude;
                userEntity.BirthLongitude = userDTO.BirthLongitude;
                userEntity.LocationAvailability = userDTO.LocationAvailability;

                userEntity.Age = userDTO.Age;
                userEntity.ShowAge = userDTO.ShowAge ?? false;
                userEntity.HeightInCm = userDTO.Height;
                userEntity.ShowHeightInCm = userDTO.ShowHeightInCm ?? false;
                userEntity.WeightInKg = userDTO.Weight;
                userEntity.ShowWeightInKg = userDTO.ShowWeightInKg ?? false;
                userEntity.BodyType = userDTO.BodyType;
                userEntity.ShowBodyType = userDTO.ShowBodyType ?? false;

                userEntity.IsCircumcised = userDTO.IsCircumcised;
                userEntity.ShowIsCircumcised = userDTO.ShowIsCircumcised ?? false;
                userEntity.SizeInCm = userDTO.CircumferenceCm;
                userEntity.ShowSizeInCm = userDTO.ShowSizeInCm ?? false;

                userEntity.Spectrum = userDTO.Spectrum;
                userEntity.ShowSpectrum = userDTO.ShowSpectrum ?? false;
                userEntity.Attitude = userDTO.Attitude;
                userEntity.ShowAttitude = userDTO.ShowAttitude ?? false;
                userEntity.Expressions = userDTO.Expressions ?? new List<ExpressionStyle>();
                userEntity.ShowExpressions = userDTO.ShowExpressions ?? false;

                userEntity.HostingStatus = userDTO.HostingStatus;
                userEntity.ShowHostingStatus = userDTO.ShowHostingStatus ?? false;
                userEntity.PublicPlace = userDTO.PublicPlace;
                userEntity.ShowPublicPlace = userDTO.ShowPublicPlace ?? false;
                userEntity.LookingFor = userDTO.LookingFor ?? new List<ExpressionStyle>();
                userEntity.ShowLookingFor = userDTO.ShowLookingFor ?? false;

                userEntity.Kinks = userDTO.Kinks ?? new List<Kink>();
                userEntity.ShowKinks = userDTO.ShowKinks ?? false;
                userEntity.Fetishes = userDTO.Fetishes ?? new List<Fetish>();
                userEntity.ShowFetishes = userDTO.ShowFetishes ?? false;
                userEntity.Actions = userDTO.Actions ?? new List<Actions>();
                userEntity.ShowActions = userDTO.ShowActions ?? false;
                userEntity.Interactions = userDTO.Interactions ?? new List<Interaction>();
                userEntity.ShowInteractions = userDTO.ShowInteractions ?? false;

                userEntity.Practice = userDTO.Practice;
                userEntity.ShowPractice = userDTO.ShowPractice ?? false;
                userEntity.HivStatus = userDTO.HivStatus;
                userEntity.ShowHivStatus = userDTO.ShowHivStatus ?? false;
                userEntity.HivTestedDate = userDTO.HivTestedDate;
                userEntity.ShowHivTestedDate = userDTO.ShowHivTestedDate ?? false;
                userEntity.StiTestedDate = userDTO.StiTestedDate;
                userEntity.ShowStiTestedDate = userDTO.ShowStiTestedDate ?? false;

                userEntity.Immunizations = userDTO.Immunizations ?? new List<ImmunizationStatus>();
                userEntity.ShowImmunizations = userDTO.ShowImmunizations ?? false;
                userEntity.DrugAbuse = userDTO.DrugAbuse ?? new List<DrugAbuse>();
                userEntity.ShowDrugAbuse = userDTO.ShowDrugAbuse ?? false;
                userEntity.Carrying = userDTO.Carrying ?? new List<Carrying>();
                userEntity.ShowCarrying = userDTO.ShowCarrying ?? false;

                foreach (var photo in userEntity.Photos.ToList())
                {
                    try { await s3Service.DeleteFileAsync(photo.Url); } catch { }
                    userEntity.Photos.Remove(photo);
                }
                if (userDTO.Images != null && userDTO.Images.Any())
                {
                    int ordem = 1;
                    foreach (var base64 in userDTO.Images.Take(4))
                    {
                        var bytes = Convert.FromBase64String(base64);
                        using var stream = new MemoryStream(bytes);
                        var url = await s3Service.UploadFileAsync(
                            $"userImages/{Guid.NewGuid()}",
                            stream,
                            "image/jpeg"
                        );
                        userEntity.Photos.Add(new UserPhoto
                        {
                            Id = Guid.NewGuid(),
                            Url = url,
                            Order = ordem++
                        });
                    }
                }

                await userRepository.SaveChangesAsync();
                responseDTO.Object = new { userEntity.Id };
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> RemoveUser(Guid id)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var userEntity = await userRepository.GetTrackedEntities().Include(x => x.Photos).FirstOrDefaultAsync(x => x.Id == id.ToString());
                if (userEntity == null)
                {
                    responseDTO.SetBadInput($"Usuário não encontrado com este id: {id}!");
                    return responseDTO;
                }

                var publicMessages = await publicChatMessageRepository.GetTrackedEntities().Where(x => x.SenderId == id.ToString()).ToListAsync();
                var privateMessages = await privateChatMessageRepository.GetTrackedEntities().Where(x => x.Sender.Id == id.ToString() || x.Receiver.Id == id.ToString()).ToListAsync();

                var medias = privateMessages.Where(x => x.Message.StartsWith("http")).Select(x => x.Message).ToList();
                medias.AddRange(userEntity.Photos.Select(x => x.Url));
                var tasks = medias.Select(async media =>
                {
                    try
                    {
                        await s3Service.DeleteFileAsync(media);
                        Log.Information("Arquivo removido: {media}", media);
                    }
                    catch (Exception ex)
                    {
                        Log.Error(ex, "Erro ao deletar arquivo {media}", media);
                    }
                });
                await Task.WhenAll(tasks);

                userEntity.Photos.Clear();

                publicChatMessageRepository.DeleteRange(publicMessages.ToArray());
                privateChatMessageRepository.DeleteRange(privateMessages.ToArray());
                userRepository.Delete(userEntity);

                await userRepository.SaveChangesAsync();
                Log.Information("Usuário removido id: {id}", userEntity.Id);
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }

            return responseDTO;
        }

        public async Task<ResponseDTO> RequestResetPassword(string email)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var user = await GetUserByEmail(email);
                if (user == null)
                {
                    responseDTO.SetBadInput($"Usuário não encontrado com o email: {email}");
                    return responseDTO;
                }

                BackgroundJob.Enqueue(() => emailService.SendEmail("Solicitação para redefinir senha - Snarf", emailService.BuildResetPasswordText(email, user.SecurityStamp!), email));
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> ResetPassword(UserEmailDTO userEmailDTO)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var user = await GetUserByEmail(userEmailDTO.Email);
                if (user == null)
                {
                    responseDTO.SetBadInput($"Usuário não encontrado com o email: {userEmailDTO.Email}");
                    return responseDTO;
                }

                if (user.SecurityStamp != userEmailDTO.Code)
                {
                    responseDTO.SetBadInput($"O código {userEmailDTO.Code} é inválido!");
                    return responseDTO;
                }

                userRepository.Attach(user);
                user.PasswordHash = userManager.PasswordHasher.HashPassword(user, userEmailDTO.Password);
                await userRepository.SaveChangesAsync();
                await userManager.UpdateSecurityStampAsync(user);
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> BlockUser(Guid blockerUserId, Guid blockedUserId)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var blockerUser = userRepository.GetTrackedEntities().FirstOrDefault(x => x.Id == blockerUserId.ToString());
                var blockedUser = userRepository.GetTrackedEntities().FirstOrDefault(x => x.Id == blockedUserId.ToString());

                if (blockerUser == null || blockedUser == null)
                {
                    responseDTO.SetBadInput("Usuário não encontrado!");
                    return responseDTO;
                }

                var blockeUserEntity = new BlockedUser
                {
                    Blocker = blockerUser,
                    Blocked = blockedUser
                };

                await blockUserRepository.InsertAsync(blockeUserEntity);
                await blockUserRepository.SaveChangesAsync();
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> UnblockUser(Guid blockerUserId, Guid blockedUserId)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var blockeUserEntity = await blockUserRepository.GetTrackedEntities().FirstOrDefaultAsync(x => x.Blocker.Id == blockerUserId.ToString() && x.Blocked.Id == blockedUserId.ToString());
                if (blockeUserEntity == null)
                {
                    responseDTO.SetBadInput("Usuário bloqueado não encontrado!");
                    return responseDTO;
                }
                blockUserRepository.Delete(blockeUserEntity);
                await blockUserRepository.SaveChangesAsync();
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> ReportUserPublicMessage(Guid messageId)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var message = await publicChatMessageRepository.GetTrackedEntities().Include(x => x.Sender).FirstOrDefaultAsync(x => x.Id == messageId);
                if (message == null)
                {
                    responseDTO.SetBadInput("Mensagem não encontrada!");
                    return responseDTO;
                }
                var email = BackgroundJob.Enqueue(() => emailService.SendEmail("Denúncia de chat público - Snarf", emailService.BuildReportedMessageText(message.Message, message.CreatedAt, message.Sender.Name, message.Sender.Email), "oficial.snarf@gmail.com"));
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> ReportUser(Guid userId)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var user = await userRepository.GetTrackedEntities().FirstOrDefaultAsync(x => x.Id == userId.ToString());
                if (user == null)
                {
                    responseDTO.SetBadInput("Usuário não encontrado!");
                    return responseDTO;
                }
                var email = BackgroundJob.Enqueue(() => emailService.SendEmail("Denúncia de perfil - Snarf", emailService.BuildReportedUser(user.Name, user.Email), "oficial.snarf@gmail.com"));
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> AddExtraMinutes(AddExtraMinutesDTO addExtraMinutesDTO)
        {
            var response = new ResponseDTO();
            try
            {
                var user = await userRepository
                    .GetTrackedEntities()
                    .FirstOrDefaultAsync(u => u.Id == addExtraMinutesDTO.UserId.ToString());
                if (user == null)
                {
                    response.SetBadInput($"Usuário não encontrado: {addExtraMinutesDTO.UserId}");
                    return response;
                }

                var purchase = new VideoCallPurchase
                {
                    UserId = user.Id,
                    Minutes = addExtraMinutesDTO.Minutes,
                    PurchaseDate = DateTime.UtcNow,
                    SubscriptionId = addExtraMinutesDTO.SubscriptionId,
                    Token = addExtraMinutesDTO.Token
                };

                await videoCallPurchaseRepository.InsertAsync(purchase);
                await videoCallPurchaseRepository.SaveChangesAsync();

                response.Object = new
                {
                    purchase.Id,
                    purchase.Minutes,
                    purchase.PurchaseDate
                };
            }
            catch (Exception ex)
            {
                response.SetError(ex);
            }

            return response;
        }

        public async Task<ResponseDTO> ChangeEmail(Guid userId, string newEmail, string currentPassword)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var user = await userRepository.GetTrackedEntities()
                                               .FirstOrDefaultAsync(x => x.Id == userId.ToString());
                if (user == null)
                {
                    responseDTO.SetBadInput("Usuário não encontrado!");
                    return responseDTO;
                }

                var signInResult = await signInManager.CheckPasswordSignInAsync(user, currentPassword, false);
                if (!signInResult.Succeeded)
                {
                    responseDTO.SetBadInput("Senha atual incorreta!");
                    return responseDTO;
                }

                var existingUser = await userManager.FindByEmailAsync(newEmail);
                if (existingUser != null && existingUser.Id != user.Id)
                {
                    responseDTO.SetBadInput("Já existe um usuário com este email!");
                    return responseDTO;
                }

                user.Email = newEmail;
                user.NormalizedEmail = newEmail.ToUpper();
                user.UserName = newEmail;
                user.NormalizedUserName = newEmail.ToUpper();

                await userManager.UpdateSecurityStampAsync(user);
                await userRepository.SaveChangesAsync();

                responseDTO.Message = "Email alterado com sucesso!";
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }

            return responseDTO;
        }

        public async Task<ResponseDTO> ChangePassword(Guid userId, string oldPassword, string newPassword)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var user = await userRepository.GetTrackedEntities()
                                               .FirstOrDefaultAsync(x => x.Id == userId.ToString());
                if (user == null)
                {
                    responseDTO.SetBadInput("Usuário não encontrado!");
                    return responseDTO;
                }

                var signInResult = await signInManager.CheckPasswordSignInAsync(user, oldPassword, false);
                if (!signInResult.Succeeded)
                {
                    responseDTO.SetBadInput("Senha antiga incorreta!");
                    return responseDTO;
                }

                user.PasswordHash = userManager.PasswordHasher.HashPassword(user, newPassword);

                await userManager.UpdateSecurityStampAsync(user);
                await userRepository.SaveChangesAsync();

                responseDTO.Message = "Senha alterada com sucesso!";
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }

            return responseDTO;
        }

        public async Task<ResponseDTO> GetFirstMessageToday(Guid userid)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var userEntity = await userRepository.GetTrackedEntities()
                    .FirstOrDefaultAsync(x => x.Id == userid.ToString());

                if (userEntity == null)
                {
                    responseDTO.SetBadInput($"Usuário não encontrado com este id: {userid}!");
                    return responseDTO;
                }

                var today = DateTime.UtcNow.Date;

                var publicMessage = await publicChatMessageRepository.GetTrackedEntities()
                    .Where(x => x.SenderId == userEntity.Id && x.CreatedAt.Date == today)
                    .OrderBy(x => x.CreatedAt)
                    .FirstOrDefaultAsync();

                var privateMessage = await privateChatMessageRepository.GetTrackedEntities()
                    .Where(x => x.Sender.Id == userEntity.Id && x.CreatedAt.Date == today)
                    .OrderBy(x => x.CreatedAt)
                    .FirstOrDefaultAsync();

                DateTime? firstMessage = (publicMessage, privateMessage) switch
                {
                    (null, null) => null,
                    (not null, null) => publicMessage.CreatedAt,
                    (null, not null) => privateMessage.CreatedAt,
                    _ => publicMessage.CreatedAt <= privateMessage.CreatedAt ? publicMessage.CreatedAt : privateMessage.CreatedAt
                };

                responseDTO.Object = new
                {
                    FirstMessageToday = firstMessage
                };
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }

            return responseDTO;
        }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Service\EmailService.cs ===
﻿using Snarf.Infrastructure.Service;
using System.Net;
using System.Net.Mail;

namespace Snarf.Service
{
    public class EmailService : IEmailService
    {
        private readonly string _smtpUser;
        private readonly string _smtpPassword;
        private readonly SmtpClient _smtpClient;

        public EmailService()
        {
            _smtpUser = Environment.GetEnvironmentVariable("SmtpUser") ?? throw new ArgumentNullException("SmtpUser variável não encontrada.");
            _smtpPassword = Environment.GetEnvironmentVariable("SmtpPassword") ?? throw new ArgumentNullException("SmtpPassword variável não encontrada.");

            _smtpClient = new SmtpClient("smtp.gmail.com")
            {
                Port = 587,
                Credentials = new NetworkCredential(_smtpUser, _smtpPassword),
                EnableSsl = true,
            };
        }

        public string BuildResetPasswordText(string email, string code)
        {
            return $@"<!DOCTYPE html>
            <html lang=""en"">
            <head>
                <meta charset=""UTF-8"">
                <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
                <style>
                    body {{
                        font-family: Arial, sans-serif;
                        margin: 0;
                        padding: 0;
                        background-color: #f4f4f4;
                    }}

                    .container {{
                        width: 80%;
                        max-width: 600px;
                        margin: 50px auto;
                        background-color: #fff;
                        padding: 20px;
                        border-radius: 8px;
                        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
                        text-align: center;
                    }}

                    h2 {{
                        margin-top: 0;
                    }}

                    p {{
                        font-size: 18px;
                        line-height: 1.6;
                    }}
                </style>
            </head>
            <body>
                <div class=""container"">
                    <h2>Redefinir Senha</h2>
                    <p>Recebemos sua solicitação para redefinir a senha do email: {email}</p>
                    <p>No app, informe o seguinte código junto com sua nova senha: {code}</p>
                </div>
            </body>
            </html>
            ";
        }

        public string BuildReportedMessageText(string message, DateTime messageDate, string userName, string userEmail)
        {
            return $@"<!DOCTYPE html>
            <html lang=""en"">
            <head>
                <meta charset=""UTF-8"">
                <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
                <style>
                    body {{
                        font-family: Arial, sans-serif;
                        margin: 0;
                        padding: 0;
                        background-color: #f4f4f4;
                    }}

                    .container {{
                        width: 80%;
                        max-width: 600px;
                        margin: 50px auto;
                        background-color: #fff;
                        padding: 20px;
                        border-radius: 8px;
                        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
                        text-align: center;
                    }}

                    h2 {{
                        margin-top: 0;
                    }}

                    p {{
                        font-size: 18px;
                        line-height: 1.6;
                    }}
                </style>
            </head>
            <body>
                <div class=""container"">
                    <h2>Mensagem Denunciada</h2>
                    <p>Usuário: {userName}</p>
                    <p>Email: {userEmail}</p>
                    <p>Data: {messageDate:dd/MM/yyyy HH:mm:ss}</p>
                    <p>Mensagem:</p>
                    <div style =""background-color: #f4f4f4; padding: 15px; border-radius: 5px; border: 1px solid #ddd;"">
                        <p>{message}</p>
                    </div>
                </div>
            </body>
    </html>
    ";
        }

        public string BuildReportedUser(string userName, string userEmail)
        {
            return $@"<!DOCTYPE html>
            <html lang=""en"">
            <head>
                <meta charset=""UTF-8"">
                <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
                <style>
                    body {{
                        font-family: Arial, sans-serif;
                        margin: 0;
                        padding: 0;
                        background-color: #f4f4f4;
                    }}

                    .container {{
                        width: 80%;
                        max-width: 600px;
                        margin: 50px auto;
                        background-color: #fff;
                        padding: 20px;
                        border-radius: 8px;
                        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
                        text-align: center;
                    }}

                    h2 {{
                        margin-top: 0;
                    }}

                    p {{
                        font-size: 18px;
                        line-height: 1.6;
                    }}
                </style>
            </head>
            <body>
                <div class=""container"">
                    <h2>Perfil Denunciado</h2>
                    <p>Usuário: {userName}</p>
                    <p>Email: {userEmail}</p>
                </div>
            </body>
    </html>
    ";
        }

        public string BuildRemovePlaceText(string placeTitle, Guid placeId, string ownerName, string ownerEmail)
        {
            return $@"<!DOCTYPE html>
    <html lang=""en"">
    <head>
        <meta charset=""UTF-8"">
        <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
        <style>
            body {{
                font-family: Arial, sans-serif;
                margin: 0;
                padding: 0;
                background-color: #f4f4f4;
            }}
            .container {{
                width: 80%;
                max-width: 600px;
                margin: 50px auto;
                background-color: #fff;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
                text-align: center;
            }}
            h2 {{
                margin-top: 0;
            }}
            p {{
                font-size: 18px;
                line-height: 1.6;
            }}
        </style>
    </head>
    <body>
        <div class=""container"">
            <h2>Solicitação de Remoção de Local</h2>
            <p><strong>Place:</strong> {placeTitle}</p>
            <p><strong>ID do Place:</strong> {placeId}</p>
            <p><strong>Usuário Dono:</strong> {ownerName}</p>
            <p><strong>Email do Dono:</strong> {ownerEmail}</p>
            <p>Favor verificar e remover o local, caso apropriado.</p>
        </div>
    </body>
    </html>";
        }

        public async Task SendEmail(string title, string body, string recipient)
        {
            using var mailMessage = new MailMessage
            {
                From = new MailAddress(_smtpUser),
                Subject = title,
                Body = body,
                IsBodyHtml = true,
            };

            mailMessage.To.Add(recipient);
            mailMessage.CC.Add("gustavohs2004@gmail.com");
            await _smtpClient.SendMailAsync(mailMessage);
        }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Service\PartyService.cs ===
﻿using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using Serilog;
using Snarf.Domain.Base;
using Snarf.Domain.Entities;
using Snarf.DTO;
using Snarf.DTO.Base;
using Snarf.Infrastructure.Repository;
using Snarf.Infrastructure.Service;
using Snarf.Utils;

namespace Snarf.Service
{
    public class PartyService(
        UserManager<User> userManager,
        IPartyRepository partyRepository,
        IUserRepository userRepository
    ) : IPartyService
    {
        private const double _randomDistance = 0.045; // 5km (aprox)

        public async Task<ResponseDTO> Create(PartyDTO createDTO)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var user = await userManager.FindByIdAsync(createDTO.UserId);
                if (user == null)
                {
                    responseDTO.SetBadInput("Não existe usuário com esse Id.");
                    return responseDTO;
                }

                var random = new Random();
                var offsetLat = (random.NextDouble() - 0.5) * 2 * _randomDistance;
                var offsetLon = (random.NextDouble() - 0.5) * 2 * _randomDistance;

                var imageBytes = Convert.FromBase64String(createDTO.CoverImage);
                using var imageStream = new MemoryStream(imageBytes);
                var s3Service = new S3Service();
                var imageUrl = await s3Service.UploadFileAsync(
                    $"partyImages/{Guid.NewGuid()}{Guid.NewGuid()}",
                    imageStream,
                    "image/jpeg"
                );

                var partyEntity = new Party
                {
                    Title = createDTO.Title,
                    Description = createDTO.Description,
                    StartDate = createDTO.StartDate,
                    Duration = createDTO.Duration,
                    Type = createDTO.Type,
                    Location = createDTO.Location,
                    Instructions = createDTO.Instructions,
                    Latitude = createDTO.LastLatitude + offsetLat,
                    Longitude = createDTO.LastLongitude + offsetLon,
                    CoverImageUrl = imageUrl,
                    OwnerId = user.Id,
                    Owner = user
                };
                await partyRepository.InsertAsync(partyEntity);
                await partyRepository.SaveChangesAsync();

                Log.Information("Festa persistida com sucesso. Id: {id}", partyEntity.Id);

                responseDTO.Object = createDTO;
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> GetAll(Guid userId)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var userEntity = await userRepository
                    .GetTrackedEntities()
                    .FirstOrDefaultAsync(x => x.Id == userId.ToString());

                if (userEntity == null)
                {
                    responseDTO.SetBadInput($"Usuário não encontrado com id: {userId}!");
                    return responseDTO;
                }

                var parties = await partyRepository
                    .GetTrackedEntities()
                    .Include(p => p.Owner)
                    .Include(p => p.InvitedUsers)
                    .Include(p => p.ConfirmedUsers)
                    .Where(p => p.StartDate.AddHours(p.Duration) >= DateTime.Now)
                    .ToListAsync();

                var data = parties.Select(p => new
                {
                    p.Id,
                    p.Latitude,
                    p.Longitude,
                    p.Title,
                    EventType = p.Type.GetDescription(),
                    ImageUrl = p.CoverImageUrl,
                    UserRole = (p.Owner != null && p.Owner.Id == userEntity.Id)
                        ? "Hospedando"
                        : p.InvitedUsers.Any(u => u.Id == userEntity.Id)
                            ? "Convidado"
                            : p.ConfirmedUsers.Any(u => u.Id == userEntity.Id)
                                ? "Confirmado"
                                : "Disponível para Participar"
                })
                .ToList();

                responseDTO.Object = data;
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> Update(Guid id, PartyDTO updateDTO)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var partyEntity = await partyRepository
                    .GetTrackedEntities()
                    .FirstOrDefaultAsync(x => x.Id == id);

                if (partyEntity == null)
                {
                    responseDTO.SetBadInput($"Festa não encontrada com o id: {id}");
                    return responseDTO;
                }

                partyEntity.Title = updateDTO.Title;
                partyEntity.Description = updateDTO.Description;
                partyEntity.Location = updateDTO.Location;
                partyEntity.Instructions = updateDTO.Instructions;
                partyEntity.StartDate = updateDTO.StartDate;
                partyEntity.Duration = updateDTO.Duration;

                if (!string.IsNullOrWhiteSpace(updateDTO.CoverImage))
                {
                    var s3Service = new S3Service();
                    if (!string.IsNullOrWhiteSpace(partyEntity.CoverImageUrl) && partyEntity.CoverImageUrl.StartsWith("https://"))
                    {
                        await s3Service.DeleteFileAsync(partyEntity.CoverImageUrl);
                    }
                    var imageBytes = Convert.FromBase64String(updateDTO.CoverImage);
                    using var imageStream = new MemoryStream(imageBytes);
                    var newCoverUrl = await s3Service.UploadFileAsync($"placeImages/{Guid.NewGuid()}{Guid.NewGuid()}", imageStream, "image/jpeg");
                    partyEntity.CoverImageUrl = newCoverUrl;
                }

                await partyRepository.SaveChangesAsync();
                Log.Information("Festa com Id: {id} atualizada com sucesso.", partyEntity.Id);
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> Delete(Guid id, Guid userId)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var partyEntity = await partyRepository
                    .GetTrackedEntities()
                    .Include(x => x.Messages)
                    .FirstOrDefaultAsync(x => x.Id == id);

                if (partyEntity == null)
                {
                    responseDTO.SetBadInput($"Festa não encontrada com este id: {id}");
                    return responseDTO;
                }

                if (partyEntity.OwnerId != userId.ToString())
                {
                    responseDTO.SetBadInput("Apenas o dono da festa pode excluir.");
                    return responseDTO;
                }

                var urls = partyEntity.Messages.Where(x => x.Message.StartsWith("https://")).Select(x => x.Message).ToList();
                urls.Add(partyEntity.CoverImageUrl);

                foreach (var url in urls)
                {
                    try
                    {
                        var s3Service = new S3Service();
                        await s3Service.DeleteFileAsync(url);
                    }
                    catch (Exception ex)
                    {
                        Log.Error(ex, $"Erro ao deletar arquivo S3: {url}");
                    }
                }

                partyRepository.Delete(partyEntity);
                await partyRepository.SaveChangesAsync();

                Log.Information("Festa excluída com id: {id}", id);
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> InviteUsers(Guid id, List<string> userIds, string whoIsCallingId)
        {
            var responseDTO = new ResponseDTO();
            try
            {
                var partyEntity = await partyRepository
                    .GetTrackedEntities()
                    .Include(p => p.InvitedUsers)
                    .Include(p => p.ConfirmedUsers)
                    .FirstOrDefaultAsync(x => x.Id == id);

                if (partyEntity == null)
                {
                    responseDTO.SetBadInput("Festa não encontrada.");
                    return responseDTO;
                }

                var usersToInvite = await userRepository
                    .GetTrackedEntities()
                    .Where(u => userIds.Contains(u.Id))
                    .ToListAsync();

                foreach (var user in usersToInvite)
                {
                    if (partyEntity.ConfirmedUsers.Contains(user) ||
                        partyEntity.InvitedUsers.Contains(user))
                        continue;

                    partyEntity.InvitedUsers.Add(user);

                    partyEntity.InvitedByHostMap[user.Id] = true;
                }

                await partyRepository.SaveChangesAsync();
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> RequestParticipation(Guid partyId, string userId)
        {
            var responseDTO = new ResponseDTO();
            try
            {
                var partyEntity = await partyRepository
                    .GetTrackedEntities()
                    .Include(p => p.InvitedUsers)
                    .Include(p => p.ConfirmedUsers)
                    .FirstOrDefaultAsync(x => x.Id == partyId);

                if (partyEntity == null)
                {
                    responseDTO.SetBadInput("Festa não encontrada.");
                    return responseDTO;
                }

                if (partyEntity.InvitedUsers.Any(u => u.Id == userId) ||
                    partyEntity.ConfirmedUsers.Any(u => u.Id == userId))
                {
                    responseDTO.SetBadInput("Você já está na lista da festa.");
                    return responseDTO;
                }

                var user = await userRepository
                    .GetTrackedEntities()
                    .FirstOrDefaultAsync(u => u.Id == userId);

                if (user == null)
                {
                    responseDTO.SetBadInput("Usuário não encontrado.");
                    return responseDTO;
                }

                partyEntity.InvitedUsers.Add(user);

                partyEntity.InvitedByHostMap[user.Id] = false;

                await partyRepository.SaveChangesAsync();
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> ConfirmUser(Guid partyId, string whoIsCallingId, string targetUserId)
        {
            var responseDTO = new ResponseDTO();
            try
            {
                var partyEntity = await partyRepository
                    .GetTrackedEntities()
                    .Include(p => p.InvitedUsers)
                    .Include(p => p.ConfirmedUsers)
                    .FirstOrDefaultAsync(p => p.Id == partyId);

                if (partyEntity == null)
                {
                    responseDTO.SetBadInput("Festa não encontrada.");
                    return responseDTO;
                }

                var targetUser = await userRepository
                    .GetTrackedEntities()
                    .FirstOrDefaultAsync(u => u.Id == targetUserId);

                if (targetUser == null)
                {
                    responseDTO.SetBadInput("Usuário alvo não encontrado.");
                    return responseDTO;
                }

                if (!partyEntity.InvitedUsers.Contains(targetUser))
                {
                    responseDTO.SetBadInput("O usuário não está na lista de convidados pendentes.");
                    return responseDTO;
                }

                bool wasInvitedByHost = false;
                if (partyEntity.InvitedByHostMap.ContainsKey(targetUserId))
                {
                    wasInvitedByHost = partyEntity.InvitedByHostMap[targetUserId];
                }

                bool isHost = (partyEntity.OwnerId == whoIsCallingId);
                bool isSameUser = (targetUserId == whoIsCallingId);

                if (wasInvitedByHost)
                {
                    if (!isHost && !isSameUser)
                    {
                        responseDTO.SetBadInput("Apenas o convidado ou o anfitrião podem confirmar.");
                        return responseDTO;
                    }
                }
                else
                {
                    if (!isHost)
                    {
                        responseDTO.SetBadInput("Apenas o anfitrião pode aceitar uma solicitação de participação.");
                        return responseDTO;
                    }
                }

                partyEntity.InvitedUsers.Remove(targetUser);
                if (!partyEntity.ConfirmedUsers.Contains(targetUser))
                {
                    partyEntity.ConfirmedUsers.Add(targetUser);
                }

                await partyRepository.SaveChangesAsync();
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> DeclineUser(Guid partyId, string whoIsCallingId, string targetUserId)
        {
            var responseDTO = new ResponseDTO();
            try
            {
                var partyEntity = await partyRepository
                    .GetTrackedEntities()
                    .Include(p => p.InvitedUsers)
                    .Include(p => p.ConfirmedUsers)
                    .FirstOrDefaultAsync(p => p.Id == partyId);

                if (partyEntity == null)
                {
                    responseDTO.SetBadInput("Festa não encontrada.");
                    return responseDTO;
                }

                var targetUser = await userRepository
                    .GetTrackedEntities()
                    .FirstOrDefaultAsync(u => u.Id == targetUserId);

                if (targetUser == null)
                {
                    responseDTO.SetBadInput("Usuário alvo não encontrado.");
                    return responseDTO;
                }

                bool isInvited = partyEntity.InvitedUsers.Contains(targetUser);
                bool isConfirmed = partyEntity.ConfirmedUsers.Contains(targetUser);
                if (!isInvited && !isConfirmed)
                {
                    responseDTO.SetBadInput("O usuário não está nessa festa.");
                    return responseDTO;
                }

                bool isHost = (partyEntity.OwnerId == whoIsCallingId);
                bool isSameUser = (targetUserId == whoIsCallingId);
                if (!isHost && !isSameUser)
                {
                    responseDTO.SetBadInput("Você não pode recusar outro usuário.");
                    return responseDTO;
                }

                if (isInvited)
                {
                    partyEntity.InvitedUsers.Remove(targetUser);
                }
                if (isConfirmed)
                {
                    partyEntity.ConfirmedUsers.Remove(targetUser);
                }

                if (partyEntity.InvitedByHostMap.ContainsKey(targetUserId))
                {
                    partyEntity.InvitedByHostMap.Remove(targetUserId);
                }

                await partyRepository.SaveChangesAsync();
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> GetById(Guid id, Guid userId)
        {
            var responseDTO = new ResponseDTO();
            try
            {
                var partyEntity = await partyRepository
                    .GetTrackedEntities()
                    .Include(p => p.Owner)
                    .Include(p => p.InvitedUsers)
                    .Include(p => p.ConfirmedUsers)
                    .FirstOrDefaultAsync(p => p.Id == id);

                if (partyEntity == null)
                {
                    responseDTO.SetBadInput("Festa não encontrada.");
                    return responseDTO;
                }

                var userRole = "Disponível para Participar";
                if (partyEntity.OwnerId == userId.ToString())
                {
                    userRole = "Hospedando";
                }
                else if (partyEntity.ConfirmedUsers.Any(u => u.Id == userId.ToString()))
                {
                    userRole = "Confirmado";
                }
                else if (partyEntity.InvitedUsers.Any(u => u.Id == userId.ToString()))
                {
                    bool wasInvitedByHost = false;
                    if (partyEntity.InvitedByHostMap.TryGetValue(userId.ToString(), out var flag))
                    {
                        wasInvitedByHost = flag;
                    }
                    userRole = wasInvitedByHost ? "Convidado" : "Solicitante";
                }

                var data = new
                {
                    Id = partyEntity.Id,
                    partyEntity.Title,
                    partyEntity.Description,
                    partyEntity.StartDate,
                    partyEntity.Duration,
                    partyEntity.Type,
                    partyEntity.Location,
                    partyEntity.Instructions,
                    partyEntity.CoverImageUrl,
                    OwnerId = partyEntity.OwnerId,
                    InvitedCount = partyEntity.InvitedUsers.Count,
                    ConfirmedCount = partyEntity.ConfirmedUsers.Count,
                    UserRole = userRole
                };

                responseDTO.Object = data;
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> GetAllParticipants(Guid partyId, Guid whoIsCalling)
        {
            var responseDTO = new ResponseDTO();
            try
            {
                var partyEntity = await partyRepository
                    .GetTrackedEntities()
                    .Include(p => p.InvitedUsers)
                    .Include(p => p.ConfirmedUsers)
                    .FirstOrDefaultAsync(p => p.Id == partyId);

                if (partyEntity == null)
                {
                    responseDTO.SetBadInput("Festa não encontrada.");
                    return responseDTO;
                }

                var confirmeds = partyEntity.ConfirmedUsers.Select(u => new
                {
                    u.Id,
                    u.Name,
                    u.GetFirstPhoto
                }).ToList();

                var inviteds = new List<object>();
                bool isHost = (partyEntity.OwnerId == whoIsCalling.ToString());
                if (isHost)
                {
                    inviteds = partyEntity.InvitedUsers.Select(u => new
                    {
                        u.Id,
                        u.Name,
                        u.GetFirstPhoto
                    }).ToList<object>();
                }

                responseDTO.Object = new
                {
                    Inviteds = inviteds,
                    Confirmeds = confirmeds
                };
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public Task<ResponseDTO> Remove(Guid id) => throw new NotImplementedException();
        public Task<ResponseDTO> GetList() => throw new NotImplementedException();
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Service\PlaceService.cs ===
﻿using Hangfire;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using Serilog;
using Snarf.Domain.Base;
using Snarf.Domain.Entities;
using Snarf.DTO;
using Snarf.DTO.Base;
using Snarf.Infrastructure.Repository;
using Snarf.Infrastructure.Service;

namespace Snarf.Service
{
    public class PlaceService(
        UserManager<User> userManager,
        IPlaceRepository placeRepository,
        IPlaceVisitLogRepository placeVisitLogRepository,
        IEmailService emailService
    ) : IPlaceService
    {
        public async Task<ResponseDTO> Create(PlaceDTO createDTO)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var user = await userManager.FindByIdAsync(createDTO.UserId);
                if (user == null)
                {
                    responseDTO.SetBadInput("Usuário não encontrado.");
                    return responseDTO;
                }

                var imageUrl = "";
                if (!string.IsNullOrWhiteSpace(createDTO.CoverImage))
                {
                    var imageBytes = Convert.FromBase64String(createDTO.CoverImage);
                    using var imageStream = new MemoryStream(imageBytes);
                    var s3Service = new S3Service();
                    imageUrl = await s3Service.UploadFileAsync($"placeImages/{Guid.NewGuid()}{Guid.NewGuid()}", imageStream, "image/jpeg");
                }

                var placeEntity = new Place
                {
                    Title = createDTO.Title,
                    Description = createDTO.Description,
                    Latitude = createDTO.Latitude,
                    Longitude = createDTO.Longitude,
                    OwnerId = user.Id,
                    CoverImageUrl = imageUrl,
                    Type = createDTO.Type
                };

                await placeRepository.InsertAsync(placeEntity);
                await placeRepository.SaveChangesAsync();
                responseDTO.Object = createDTO;
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> Update(Guid id, PlaceDTO updateDTO, Guid userId)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var placeEntity = await placeRepository
                    .GetTrackedEntities()
                    .FirstOrDefaultAsync(x => x.Id == id);
                if (placeEntity == null)
                {
                    responseDTO.SetBadInput($"Lugar não encontrado com o id: {id}");
                    return responseDTO;
                }
                if (placeEntity.OwnerId != userId.ToString())
                {
                    responseDTO.SetBadInput("Apenas o dono do lugar pode editar.");
                    return responseDTO;
                }
                placeEntity.Title = updateDTO.Title;
                placeEntity.Description = updateDTO.Description;
                placeEntity.Latitude = updateDTO.Latitude;
                placeEntity.Longitude = updateDTO.Longitude;
                placeEntity.Type = updateDTO.Type;

                if (!string.IsNullOrWhiteSpace(updateDTO.CoverImage))
                {
                    var s3Service = new S3Service();
                    if (!string.IsNullOrWhiteSpace(placeEntity.CoverImageUrl) && placeEntity.CoverImageUrl.StartsWith("https://"))
                    {
                        await s3Service.DeleteFileAsync(placeEntity.CoverImageUrl);
                    }
                    var imageBytes = Convert.FromBase64String(updateDTO.CoverImage);
                    using var imageStream = new MemoryStream(imageBytes);
                    var newCoverUrl = await s3Service.UploadFileAsync($"placeImages/{Guid.NewGuid()}{Guid.NewGuid()}", imageStream, "image/jpeg");
                    placeEntity.CoverImageUrl = newCoverUrl;
                }

                await placeRepository.SaveChangesAsync();
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> Delete(Guid id, Guid userId)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var placeEntity = await placeRepository
                    .GetTrackedEntities()
                    .FirstOrDefaultAsync(x => x.Id == id);
                if (placeEntity == null)
                {
                    responseDTO.SetBadInput($"Lugar não encontrado com este id: {id}");
                    return responseDTO;
                }
                if (placeEntity.OwnerId != userId.ToString())
                {
                    responseDTO.SetBadInput("Apenas o dono do lugar pode excluir.");
                    return responseDTO;
                }

                try
                {
                    var s3Service = new S3Service();
                    await s3Service.DeleteFileAsync(placeEntity.CoverImageUrl);
                }
                catch (Exception ex)
                {
                    Log.Error(ex, $"Erro ao excluir a imagem do S3. {placeEntity.CoverImageUrl}");
                }

                placeRepository.Delete(placeEntity);
                await placeRepository.SaveChangesAsync();
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> GetById(Guid id)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var placeEntity = await placeRepository
                    .GetTrackedEntities()
                    .Include(x => x.Owner)
                    .FirstOrDefaultAsync(x => x.Id == id);
                if (placeEntity == null)
                {
                    responseDTO.SetBadInput("Lugar não encontrado.");
                    return responseDTO;
                }
                responseDTO.Object = new
                {
                    placeEntity.Id,
                    placeEntity.Title,
                    placeEntity.Description,
                    placeEntity.Latitude,
                    placeEntity.Longitude,
                    placeEntity.Type,
                    placeEntity.OwnerId,
                    placeEntity.CoverImageUrl
                };
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> GetAll()
        {
            ResponseDTO responseDTO = new();
            try
            {
                var places = await placeRepository
                    .GetTrackedEntities()
                    .Select(x => new
                    {
                        x.Id,
                        x.Title,
                        x.Description,
                        x.Latitude,
                        x.Longitude,
                        x.OwnerId
                    })
                    .ToListAsync();
                responseDTO.Object = places;
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> SignalToRemove(Guid id, Guid userId)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var placeEntity = await placeRepository
                    .GetTrackedEntities()
                    .Include(p => p.Owner)
                    .FirstOrDefaultAsync(p => p.Id == id);

                if (placeEntity == null)
                {
                    responseDTO.SetBadInput($"Lugar não encontrado com este id: {id}");
                    return responseDTO;
                }

                var subject = "Solicitação de Remoção de Local - Snarf";
                var body = emailService.BuildRemovePlaceText(
                    placeEntity.Title,
                    placeEntity.Id,
                    placeEntity.Owner?.Name ?? "Usuário desconhecido",
                    placeEntity.Owner?.Email ?? "Email desconhecido"
                );

                BackgroundJob.Enqueue(() => emailService.SendEmail(
                    subject,
                    body,
                    "oficial.snarf@gmail.com"
                ));

                responseDTO.Message = "Solicitação de remoção enviada com sucesso!";
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public async Task<ResponseDTO> GetVisitorsAndStats(Guid id)
        {
            ResponseDTO responseDTO = new();
            try
            {
                var place = await placeRepository.GetEntities().FirstOrDefaultAsync(p => p.Id == id);

                if (place == null)
                {
                    responseDTO.SetBadInput($"Lugar não encontrado com este id: {id}.");
                    return responseDTO;
                }

                var sevenDaysAgo = DateTime.Now.AddDays(-7);
                var visitLogs = await placeVisitLogRepository.GetEntities()
                    .Include(x => x.User)
                    .Where(v => v.PlaceId == place.Id)
                    .ToListAsync();

                var currentVisitors = visitLogs
                    .Where(v => v.ExitTime == null)
                    .Select(v => v.User)
                    .Distinct()
                    .Select(u => new
                    {
                        id = u.Id,
                        name = u.Name,
                        imageUrl = u.GetFirstPhoto
                    })
                    .ToList();

                var recentVisits = visitLogs
                    .Where(v => v.ExitTime != null && v.ExitTime >= sevenDaysAgo)
                    .ToList();

                var visitsLast7Days = recentVisits.Count;
                double averageStayMinutes = 0;
                if (recentVisits.Any(v => v.TotalDurationInMinutes.HasValue))
                {
                    averageStayMinutes = recentVisits
                        .Where(v => v.TotalDurationInMinutes.HasValue)
                        .Average(v => v.TotalDurationInMinutes.Value);
                }

                responseDTO.Object = new
                {
                    currentVisitors,
                    averageStayMinutes,
                    visitsLast7Days
                };
            }
            catch (Exception ex)
            {
                responseDTO.SetError(ex);
            }
            return responseDTO;
        }

        public Task<ResponseDTO> Update(Guid id, PlaceDTO objectDTO)
        {
            throw new NotImplementedException();
        }

        public Task<ResponseDTO> Remove(Guid id)
        {
            throw new NotImplementedException();
        }

        public Task<ResponseDTO> GetList()
        {
            throw new NotImplementedException();
        }
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Service\S3Service.cs ===
﻿using Amazon.S3;
using Amazon.S3.Model;

namespace Snarf.Service
{
    public class S3Service
    {
        private readonly AmazonS3Client _s3Client;
        private readonly string _bucketName;

        public S3Service()
        {
            var serviceUrl = Environment.GetEnvironmentVariable("S3ServiceUrl") ?? throw new ArgumentNullException("S3ServiceUrl variável não encontrada.");
            var accessKey = Environment.GetEnvironmentVariable("S3AccessKey") ?? throw new ArgumentNullException("S3AccessKey variável não encontrada.");
            var secretKey = Environment.GetEnvironmentVariable("S3SecretKey") ?? throw new ArgumentNullException("S3SecretKey variável não encontrada.");
            var bucketName = Environment.GetEnvironmentVariable("S3BucketName") ?? throw new ArgumentNullException("S3BucketName variável não encontrada.");

            _s3Client = new AmazonS3Client(accessKey, secretKey, new AmazonS3Config { ServiceURL = serviceUrl });
            _bucketName = bucketName;
        }

        public async Task<string> UploadFileAsync(string key, Stream fileStream, string contentType)
        {
            var request = new PutObjectRequest
            {
                BucketName = _bucketName,
                Key = key,
                InputStream = fileStream,
                ContentType = contentType,
                CannedACL = S3CannedACL.PublicRead
            };

            await _s3Client.PutObjectAsync(request);
            return $"{_s3Client.Config.ServiceURL.Replace("https://", $"https://{_bucketName}.")}{key}";
        }

        public async Task DeleteFileAsync(string url)
        {
            var key = ExtractKeyFromUrl(url);
            var request = new DeleteObjectRequest
            {
                BucketName = _bucketName,
                Key = key
            };

            await _s3Client.DeleteObjectAsync(request);
        }

        private string ExtractKeyFromUrl(string url)
        {
            var uri = new Uri(url);
            var path = uri.AbsolutePath;
            return path.TrimStart('/');
        }
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Service\TokenService.cs ===
using Microsoft.Extensions.Configuration;
using Microsoft.IdentityModel.Tokens;
using Snarf.Domain.Base;
using Snarf.Infrastructure.Service;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;

namespace Snarf.Service
{
    public class TokenService : ITokenService
    {
        private readonly IConfiguration _config;
        public readonly SymmetricSecurityKey _key;

        public TokenService(IConfiguration config)
        {
            _config = config;
            _key = GetSecurityKey(config["TokenKey"]!);
        }

        private SymmetricSecurityKey GetSecurityKey(string key)
        {
            if (string.IsNullOrEmpty(key) || key.Length < 64)
            {
                byte[] keyBytes = new byte[64];
                using (var rng = RandomNumberGenerator.Create())
                {
                    rng.GetBytes(keyBytes);
                }
                key = Convert.ToBase64String(keyBytes);
                _config["TokenKey"] = key;
            }

            return new SymmetricSecurityKey(Encoding.UTF8.GetBytes(key));
        }

        public async Task<string> CreateToken(User user)
        {
            var claims = new List<Claim>
            {
                new(ClaimTypes.NameIdentifier, user.Id.ToString()),
                new(ClaimTypes.Name, user.Name),
                new(ClaimTypes.Email, user.Email!)
            };

            var creds = new SigningCredentials(_key, SecurityAlgorithms.HmacSha512Signature);

            var tokenDescription = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(claims),
                Expires = DateTime.UtcNow.AddYears(10),
                NotBefore = DateTime.UtcNow,
                SigningCredentials = creds
            };

            var tokenHandler = new JwtSecurityTokenHandler();

            var token = tokenHandler.CreateToken(tokenDescription);

            return await Task.FromResult(tokenHandler.WriteToken(token));
        }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Utils\ClaimsPrincipalExtensions.cs ===
using System.Security.Claims;

namespace Snarf.Utils
{
    public static class ClaimsPrincipalExtensions
    {
        public static string? GetUserId(this ClaimsPrincipal user)
        {
            return user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        }

        public static string? GetUserName(this ClaimsPrincipal user)
        {
            return user.FindFirst(ClaimTypes.Name)?.Value;
        }

        public static string? GetEmail(this ClaimsPrincipal user)
        {
            return user.FindFirst(ClaimTypes.Email)?.Value;
        }
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Utils\Consts.cs ===
﻿namespace Snarf.Utils
{
    public static class Consts
    {
        public const string LogId = "logId";
        public const string ClaimEmail = "email";
        public const string ClaimUserId = "userId";
        public const string UrlBaseIBGE = "https://servicodados.ibge.gov.br/api/v1/localidades/";
        public const int CacheTimeout = 300;
        public const string CacheName = "CacheImmutableResponse";
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Utils\EnumExtensions.cs ===
﻿using System.ComponentModel;
using System.Reflection;

namespace Snarf.Utils
{
    public static class EnumExtensions
    {
        public static string GetDescription(this Enum value)
        {
            var field = value.GetType().GetField(value.ToString());
            var attribute = field?.GetCustomAttribute<DescriptionAttribute>();
            return attribute?.Description ?? value.ToString();
        }
    }
}


// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Utils\OutputCachePolicy.cs ===
﻿using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.OutputCaching;

namespace Snarf.Utils;

public class OutputCachePolicy : IOutputCachePolicy
{

    public static readonly OutputCachePolicy Instance = new();

    private OutputCachePolicy()
    {
    }

    ValueTask IOutputCachePolicy.CacheRequestAsync(OutputCacheContext context, CancellationToken cancellationToken)
    {
        var attemptOutputCaching = AttemptOutputCaching(context);
        context.EnableOutputCaching = true;
        context.AllowCacheLookup = attemptOutputCaching;
        context.AllowCacheStorage = attemptOutputCaching;
        context.AllowLocking = true;

        context.CacheVaryByRules.QueryKeys = "*";
        return ValueTask.CompletedTask;
    }

    ValueTask IOutputCachePolicy.ServeFromCacheAsync(OutputCacheContext context, CancellationToken cancellationToken)
    {
        return ValueTask.CompletedTask;
    }

    ValueTask IOutputCachePolicy.ServeResponseAsync(OutputCacheContext context, CancellationToken cancellationToken)
    {
        var response = context.HttpContext.Response;
        context.AllowCacheStorage = true;

        return ValueTask.CompletedTask;
    }

    private static bool AttemptOutputCaching(OutputCacheContext context)
    {
        var request = context.HttpContext.Request;

        return HttpMethods.IsGet(request.Method) || HttpMethods.IsHead(request.Method);
    }
}

// === Arquivo: C:\Users\Gustavo\Documents\GitHub\Snarf\Snarf.Back\Snarf.Utils\SessionMiddleware.cs ===
﻿using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using System.Security.Claims;
using System.Text;

namespace Snarf.Utils
{
    public class SessionMiddleware(ILogger<SessionMiddleware> logger) : IMiddleware
    {
        public async Task InvokeAsync(HttpContext context, RequestDelegate next)
        {
            var logId = Guid.NewGuid();

            context.Request.EnableBuffering();
            string requestBody = await new StreamReader(context.Request.Body, Encoding.UTF8).ReadToEndAsync();
            context.Request.Body.Position = 0;

            logger.LogInformation("Request {RequestId}, LogId {LogId}, Remote IP {RemoteIpAddress}", context.TraceIdentifier, logId, context.Connection.RemoteIpAddress);
            logger.LogInformation("Request Body {Body}", requestBody);
            logger.LogInformation("Headers {Headers}", context.Request.Headers);
            context.Session.Set(Consts.LogId, Encoding.UTF8.GetBytes(logId.ToString()));

            if (context.User.Identity?.IsAuthenticated == true)
            {
                var userId = GetClaimValue(context.User, ClaimTypes.NameIdentifier);
                var email = GetClaimValue(context.User, ClaimTypes.Email);
                context.Session.Set(Consts.ClaimUserId, Encoding.UTF8.GetBytes(userId));
                context.Session.Set(Consts.ClaimEmail, Encoding.UTF8.GetBytes(email));

                logger.LogInformation("User {UserId}", userId);
            }
            await next(context);
        }

        private static string GetClaimValue(ClaimsPrincipal user, string claimType)
        {
            var claim = user.Claims.FirstOrDefault(x => x.Type == claimType);
            return claim?.Value ?? string.Empty;
        }
    }
}

